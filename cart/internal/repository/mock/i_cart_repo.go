// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"cart/internal/models"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ICartRepoMock implements mm_repository.ICartRepo
type ICartRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, cart models.Cart) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, cart models.Cart)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mICartRepoMockAddItem

	funcClearCartByUserID          func(ctx context.Context, userID models.UserID) (err error)
	funcClearCartByUserIDOrigin    string
	inspectFuncClearCartByUserID   func(ctx context.Context, userID models.UserID)
	afterClearCartByUserIDCounter  uint64
	beforeClearCartByUserIDCounter uint64
	ClearCartByUserIDMock          mICartRepoMockClearCartByUserID

	funcDeleteItem          func(ctx context.Context, userID models.UserID, skuID models.SKUID) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, userID models.UserID, skuID models.SKUID)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mICartRepoMockDeleteItem

	funcGetCartByUserID          func(ctx context.Context, userID models.UserID) (ca1 []models.CartItem, err error)
	funcGetCartByUserIDOrigin    string
	inspectFuncGetCartByUserID   func(ctx context.Context, userID models.UserID)
	afterGetCartByUserIDCounter  uint64
	beforeGetCartByUserIDCounter uint64
	GetCartByUserIDMock          mICartRepoMockGetCartByUserID

	funcGetCartID          func(ctx context.Context, userID models.UserID, skuID models.SKUID) (c2 models.CartID, err error)
	funcGetCartIDOrigin    string
	inspectFuncGetCartID   func(ctx context.Context, userID models.UserID, skuID models.SKUID)
	afterGetCartIDCounter  uint64
	beforeGetCartIDCounter uint64
	GetCartIDMock          mICartRepoMockGetCartID

	funcUpdateItemByUserID          func(ctx context.Context, cart models.Cart) (err error)
	funcUpdateItemByUserIDOrigin    string
	inspectFuncUpdateItemByUserID   func(ctx context.Context, cart models.Cart)
	afterUpdateItemByUserIDCounter  uint64
	beforeUpdateItemByUserIDCounter uint64
	UpdateItemByUserIDMock          mICartRepoMockUpdateItemByUserID
}

// NewICartRepoMock returns a mock for mm_repository.ICartRepo
func NewICartRepoMock(t minimock.Tester) *ICartRepoMock {
	m := &ICartRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mICartRepoMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ICartRepoMockAddItemParams{}

	m.ClearCartByUserIDMock = mICartRepoMockClearCartByUserID{mock: m}
	m.ClearCartByUserIDMock.callArgs = []*ICartRepoMockClearCartByUserIDParams{}

	m.DeleteItemMock = mICartRepoMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ICartRepoMockDeleteItemParams{}

	m.GetCartByUserIDMock = mICartRepoMockGetCartByUserID{mock: m}
	m.GetCartByUserIDMock.callArgs = []*ICartRepoMockGetCartByUserIDParams{}

	m.GetCartIDMock = mICartRepoMockGetCartID{mock: m}
	m.GetCartIDMock.callArgs = []*ICartRepoMockGetCartIDParams{}

	m.UpdateItemByUserIDMock = mICartRepoMockUpdateItemByUserID{mock: m}
	m.UpdateItemByUserIDMock.callArgs = []*ICartRepoMockUpdateItemByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mICartRepoMockAddItem struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockAddItemExpectation
	expectations       []*ICartRepoMockAddItemExpectation

	callArgs []*ICartRepoMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockAddItemExpectation specifies expectation struct of the ICartRepo.AddItem
type ICartRepoMockAddItemExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockAddItemParams
	paramPtrs          *ICartRepoMockAddItemParamPtrs
	expectationOrigins ICartRepoMockAddItemExpectationOrigins
	results            *ICartRepoMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockAddItemParams contains parameters of the ICartRepo.AddItem
type ICartRepoMockAddItemParams struct {
	ctx  context.Context
	cart models.Cart
}

// ICartRepoMockAddItemParamPtrs contains pointers to parameters of the ICartRepo.AddItem
type ICartRepoMockAddItemParamPtrs struct {
	ctx  *context.Context
	cart *models.Cart
}

// ICartRepoMockAddItemResults contains results of the ICartRepo.AddItem
type ICartRepoMockAddItemResults struct {
	err error
}

// ICartRepoMockAddItemOrigins contains origins of expectations of the ICartRepo.AddItem
type ICartRepoMockAddItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originCart string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mICartRepoMockAddItem) Optional() *mICartRepoMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for ICartRepo.AddItem
func (mmAddItem *mICartRepoMockAddItem) Expect(ctx context.Context, cart models.Cart) *mICartRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ICartRepoMockAddItemParams{ctx, cart}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.AddItem
func (mmAddItem *mICartRepoMockAddItem) ExpectCtxParam1(ctx context.Context) *mICartRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartRepoMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectCartParam2 sets up expected param cart for ICartRepo.AddItem
func (mmAddItem *mICartRepoMockAddItem) ExpectCartParam2(cart models.Cart) *mICartRepoMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepoMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartRepoMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.cart = &cart
	mmAddItem.defaultExpectation.expectationOrigins.originCart = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.AddItem
func (mmAddItem *mICartRepoMockAddItem) Inspect(f func(ctx context.Context, cart models.Cart)) *mICartRepoMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by ICartRepo.AddItem
func (mmAddItem *mICartRepoMockAddItem) Return(err error) *ICartRepoMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepoMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ICartRepoMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the ICartRepo.AddItem method
func (mmAddItem *mICartRepoMockAddItem) Set(f func(ctx context.Context, cart models.Cart) (err error)) *ICartRepoMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the ICartRepo.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the ICartRepo.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the ICartRepo.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mICartRepoMockAddItem) When(ctx context.Context, cart models.Cart) *ICartRepoMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepoMock.AddItem mock is already set by Set")
	}

	expectation := &ICartRepoMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &ICartRepoMockAddItemParams{ctx, cart},
		expectationOrigins: ICartRepoMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.AddItem return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockAddItemExpectation) Then(err error) *ICartRepoMock {
	e.results = &ICartRepoMockAddItemResults{err}
	return e.mock
}

// Times sets number of times ICartRepo.AddItem should be invoked
func (mmAddItem *mICartRepoMockAddItem) Times(n uint64) *mICartRepoMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ICartRepoMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mICartRepoMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_repository.ICartRepo
func (mmAddItem *ICartRepoMock) AddItem(ctx context.Context, cart models.Cart) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, cart)
	}

	mm_params := ICartRepoMockAddItemParams{ctx, cart}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockAddItemParams{ctx, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ICartRepoMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmAddItem.t.Errorf("ICartRepoMock.AddItem got unexpected parameter cart, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCart, *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ICartRepoMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ICartRepoMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, cart)
	}
	mmAddItem.t.Fatalf("Unexpected call to ICartRepoMock.AddItem. %v %v", ctx, cart)
	return
}

// AddItemAfterCounter returns a count of finished ICartRepoMock.AddItem invocations
func (mmAddItem *ICartRepoMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ICartRepoMock.AddItem invocations
func (mmAddItem *ICartRepoMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mICartRepoMockAddItem) Calls() []*ICartRepoMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ICartRepoMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mICartRepoMockClearCartByUserID struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockClearCartByUserIDExpectation
	expectations       []*ICartRepoMockClearCartByUserIDExpectation

	callArgs []*ICartRepoMockClearCartByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockClearCartByUserIDExpectation specifies expectation struct of the ICartRepo.ClearCartByUserID
type ICartRepoMockClearCartByUserIDExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockClearCartByUserIDParams
	paramPtrs          *ICartRepoMockClearCartByUserIDParamPtrs
	expectationOrigins ICartRepoMockClearCartByUserIDExpectationOrigins
	results            *ICartRepoMockClearCartByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockClearCartByUserIDParams contains parameters of the ICartRepo.ClearCartByUserID
type ICartRepoMockClearCartByUserIDParams struct {
	ctx    context.Context
	userID models.UserID
}

// ICartRepoMockClearCartByUserIDParamPtrs contains pointers to parameters of the ICartRepo.ClearCartByUserID
type ICartRepoMockClearCartByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
}

// ICartRepoMockClearCartByUserIDResults contains results of the ICartRepo.ClearCartByUserID
type ICartRepoMockClearCartByUserIDResults struct {
	err error
}

// ICartRepoMockClearCartByUserIDOrigins contains origins of expectations of the ICartRepo.ClearCartByUserID
type ICartRepoMockClearCartByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Optional() *mICartRepoMockClearCartByUserID {
	mmClearCartByUserID.optional = true
	return mmClearCartByUserID
}

// Expect sets up expected params for ICartRepo.ClearCartByUserID
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Expect(ctx context.Context, userID models.UserID) *mICartRepoMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartRepoMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by ExpectParams functions")
	}

	mmClearCartByUserID.defaultExpectation.params = &ICartRepoMockClearCartByUserIDParams{ctx, userID}
	mmClearCartByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCartByUserID.expectations {
		if minimock.Equal(e.params, mmClearCartByUserID.defaultExpectation.params) {
			mmClearCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCartByUserID.defaultExpectation.params)
		}
	}

	return mmClearCartByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.ClearCartByUserID
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) ExpectCtxParam1(ctx context.Context) *mICartRepoMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartRepoMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.params != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Expect")
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs == nil {
		mmClearCartByUserID.defaultExpectation.paramPtrs = &ICartRepoMockClearCartByUserIDParamPtrs{}
	}
	mmClearCartByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCartByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCartByUserID
}

// ExpectUserIDParam2 sets up expected param userID for ICartRepo.ClearCartByUserID
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) ExpectUserIDParam2(userID models.UserID) *mICartRepoMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartRepoMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.params != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Expect")
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs == nil {
		mmClearCartByUserID.defaultExpectation.paramPtrs = &ICartRepoMockClearCartByUserIDParamPtrs{}
	}
	mmClearCartByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmClearCartByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.ClearCartByUserID
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Inspect(f func(ctx context.Context, userID models.UserID)) *mICartRepoMockClearCartByUserID {
	if mmClearCartByUserID.mock.inspectFuncClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.ClearCartByUserID")
	}

	mmClearCartByUserID.mock.inspectFuncClearCartByUserID = f

	return mmClearCartByUserID
}

// Return sets up results that will be returned by ICartRepo.ClearCartByUserID
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Return(err error) *ICartRepoMock {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartRepoMockClearCartByUserIDExpectation{mock: mmClearCartByUserID.mock}
	}
	mmClearCartByUserID.defaultExpectation.results = &ICartRepoMockClearCartByUserIDResults{err}
	mmClearCartByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID.mock
}

// Set uses given function f to mock the ICartRepo.ClearCartByUserID method
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Set(f func(ctx context.Context, userID models.UserID) (err error)) *ICartRepoMock {
	if mmClearCartByUserID.defaultExpectation != nil {
		mmClearCartByUserID.mock.t.Fatalf("Default expectation is already set for the ICartRepo.ClearCartByUserID method")
	}

	if len(mmClearCartByUserID.expectations) > 0 {
		mmClearCartByUserID.mock.t.Fatalf("Some expectations are already set for the ICartRepo.ClearCartByUserID method")
	}

	mmClearCartByUserID.mock.funcClearCartByUserID = f
	mmClearCartByUserID.mock.funcClearCartByUserIDOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID.mock
}

// When sets expectation for the ICartRepo.ClearCartByUserID which will trigger the result defined by the following
// Then helper
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) When(ctx context.Context, userID models.UserID) *ICartRepoMockClearCartByUserIDExpectation {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartRepoMock.ClearCartByUserID mock is already set by Set")
	}

	expectation := &ICartRepoMockClearCartByUserIDExpectation{
		mock:               mmClearCartByUserID.mock,
		params:             &ICartRepoMockClearCartByUserIDParams{ctx, userID},
		expectationOrigins: ICartRepoMockClearCartByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCartByUserID.expectations = append(mmClearCartByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.ClearCartByUserID return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockClearCartByUserIDExpectation) Then(err error) *ICartRepoMock {
	e.results = &ICartRepoMockClearCartByUserIDResults{err}
	return e.mock
}

// Times sets number of times ICartRepo.ClearCartByUserID should be invoked
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Times(n uint64) *mICartRepoMockClearCartByUserID {
	if n == 0 {
		mmClearCartByUserID.mock.t.Fatalf("Times of ICartRepoMock.ClearCartByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCartByUserID.expectedInvocations, n)
	mmClearCartByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID
}

func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) invocationsDone() bool {
	if len(mmClearCartByUserID.expectations) == 0 && mmClearCartByUserID.defaultExpectation == nil && mmClearCartByUserID.mock.funcClearCartByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCartByUserID.mock.afterClearCartByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCartByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCartByUserID implements mm_repository.ICartRepo
func (mmClearCartByUserID *ICartRepoMock) ClearCartByUserID(ctx context.Context, userID models.UserID) (err error) {
	mm_atomic.AddUint64(&mmClearCartByUserID.beforeClearCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCartByUserID.afterClearCartByUserIDCounter, 1)

	mmClearCartByUserID.t.Helper()

	if mmClearCartByUserID.inspectFuncClearCartByUserID != nil {
		mmClearCartByUserID.inspectFuncClearCartByUserID(ctx, userID)
	}

	mm_params := ICartRepoMockClearCartByUserIDParams{ctx, userID}

	// Record call args
	mmClearCartByUserID.ClearCartByUserIDMock.mutex.Lock()
	mmClearCartByUserID.ClearCartByUserIDMock.callArgs = append(mmClearCartByUserID.ClearCartByUserIDMock.callArgs, &mm_params)
	mmClearCartByUserID.ClearCartByUserIDMock.mutex.Unlock()

	for _, e := range mmClearCartByUserID.ClearCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockClearCartByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCartByUserID.t.Errorf("ICartRepoMock.ClearCartByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCartByUserID.t.Errorf("ICartRepoMock.ClearCartByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCartByUserID.t.Errorf("ICartRepoMock.ClearCartByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCartByUserID.t.Fatal("No results are set for the ICartRepoMock.ClearCartByUserID")
		}
		return (*mm_results).err
	}
	if mmClearCartByUserID.funcClearCartByUserID != nil {
		return mmClearCartByUserID.funcClearCartByUserID(ctx, userID)
	}
	mmClearCartByUserID.t.Fatalf("Unexpected call to ICartRepoMock.ClearCartByUserID. %v %v", ctx, userID)
	return
}

// ClearCartByUserIDAfterCounter returns a count of finished ICartRepoMock.ClearCartByUserID invocations
func (mmClearCartByUserID *ICartRepoMock) ClearCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartByUserID.afterClearCartByUserIDCounter)
}

// ClearCartByUserIDBeforeCounter returns a count of ICartRepoMock.ClearCartByUserID invocations
func (mmClearCartByUserID *ICartRepoMock) ClearCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartByUserID.beforeClearCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.ClearCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCartByUserID *mICartRepoMockClearCartByUserID) Calls() []*ICartRepoMockClearCartByUserIDParams {
	mmClearCartByUserID.mutex.RLock()

	argCopy := make([]*ICartRepoMockClearCartByUserIDParams, len(mmClearCartByUserID.callArgs))
	copy(argCopy, mmClearCartByUserID.callArgs)

	mmClearCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartByUserIDDone returns true if the count of the ClearCartByUserID invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockClearCartByUserIDDone() bool {
	if m.ClearCartByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartByUserIDMock.invocationsDone()
}

// MinimockClearCartByUserIDInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockClearCartByUserIDInspect() {
	for _, e := range m.ClearCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.ClearCartByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartByUserIDCounter := mm_atomic.LoadUint64(&m.afterClearCartByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartByUserIDMock.defaultExpectation != nil && afterClearCartByUserIDCounter < 1 {
		if m.ClearCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.ClearCartByUserID at\n%s", m.ClearCartByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.ClearCartByUserID at\n%s with params: %#v", m.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCartByUserID != nil && afterClearCartByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.ClearCartByUserID at\n%s", m.funcClearCartByUserIDOrigin)
	}

	if !m.ClearCartByUserIDMock.invocationsDone() && afterClearCartByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.ClearCartByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartByUserIDMock.expectedInvocations), m.ClearCartByUserIDMock.expectedInvocationsOrigin, afterClearCartByUserIDCounter)
	}
}

type mICartRepoMockDeleteItem struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockDeleteItemExpectation
	expectations       []*ICartRepoMockDeleteItemExpectation

	callArgs []*ICartRepoMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockDeleteItemExpectation specifies expectation struct of the ICartRepo.DeleteItem
type ICartRepoMockDeleteItemExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockDeleteItemParams
	paramPtrs          *ICartRepoMockDeleteItemParamPtrs
	expectationOrigins ICartRepoMockDeleteItemExpectationOrigins
	results            *ICartRepoMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockDeleteItemParams contains parameters of the ICartRepo.DeleteItem
type ICartRepoMockDeleteItemParams struct {
	ctx    context.Context
	userID models.UserID
	skuID  models.SKUID
}

// ICartRepoMockDeleteItemParamPtrs contains pointers to parameters of the ICartRepo.DeleteItem
type ICartRepoMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
	skuID  *models.SKUID
}

// ICartRepoMockDeleteItemResults contains results of the ICartRepo.DeleteItem
type ICartRepoMockDeleteItemResults struct {
	err error
}

// ICartRepoMockDeleteItemOrigins contains origins of expectations of the ICartRepo.DeleteItem
type ICartRepoMockDeleteItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mICartRepoMockDeleteItem) Optional() *mICartRepoMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) Expect(ctx context.Context, userID models.UserID, skuID models.SKUID) *mICartRepoMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepoMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &ICartRepoMockDeleteItemParams{ctx, userID, skuID}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mICartRepoMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepoMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepoMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) ExpectUserIDParam2(userID models.UserID) *mICartRepoMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepoMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepoMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSkuIDParam3 sets up expected param skuID for ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) ExpectSkuIDParam3(skuID models.SKUID) *mICartRepoMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepoMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepoMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) Inspect(f func(ctx context.Context, userID models.UserID, skuID models.SKUID)) *mICartRepoMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by ICartRepo.DeleteItem
func (mmDeleteItem *mICartRepoMockDeleteItem) Return(err error) *ICartRepoMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepoMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &ICartRepoMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the ICartRepo.DeleteItem method
func (mmDeleteItem *mICartRepoMockDeleteItem) Set(f func(ctx context.Context, userID models.UserID, skuID models.SKUID) (err error)) *ICartRepoMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the ICartRepo.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the ICartRepo.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the ICartRepo.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mICartRepoMockDeleteItem) When(ctx context.Context, userID models.UserID, skuID models.SKUID) *ICartRepoMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepoMock.DeleteItem mock is already set by Set")
	}

	expectation := &ICartRepoMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &ICartRepoMockDeleteItemParams{ctx, userID, skuID},
		expectationOrigins: ICartRepoMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.DeleteItem return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockDeleteItemExpectation) Then(err error) *ICartRepoMock {
	e.results = &ICartRepoMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times ICartRepo.DeleteItem should be invoked
func (mmDeleteItem *mICartRepoMockDeleteItem) Times(n uint64) *mICartRepoMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of ICartRepoMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mICartRepoMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_repository.ICartRepo
func (mmDeleteItem *ICartRepoMock) DeleteItem(ctx context.Context, userID models.UserID, skuID models.SKUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, skuID)
	}

	mm_params := ICartRepoMockDeleteItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockDeleteItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("ICartRepoMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("ICartRepoMock.DeleteItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteItem.t.Errorf("ICartRepoMock.DeleteItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ICartRepoMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the ICartRepoMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ICartRepoMock.DeleteItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished ICartRepoMock.DeleteItem invocations
func (mmDeleteItem *ICartRepoMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ICartRepoMock.DeleteItem invocations
func (mmDeleteItem *ICartRepoMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mICartRepoMockDeleteItem) Calls() []*ICartRepoMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ICartRepoMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mICartRepoMockGetCartByUserID struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockGetCartByUserIDExpectation
	expectations       []*ICartRepoMockGetCartByUserIDExpectation

	callArgs []*ICartRepoMockGetCartByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockGetCartByUserIDExpectation specifies expectation struct of the ICartRepo.GetCartByUserID
type ICartRepoMockGetCartByUserIDExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockGetCartByUserIDParams
	paramPtrs          *ICartRepoMockGetCartByUserIDParamPtrs
	expectationOrigins ICartRepoMockGetCartByUserIDExpectationOrigins
	results            *ICartRepoMockGetCartByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockGetCartByUserIDParams contains parameters of the ICartRepo.GetCartByUserID
type ICartRepoMockGetCartByUserIDParams struct {
	ctx    context.Context
	userID models.UserID
}

// ICartRepoMockGetCartByUserIDParamPtrs contains pointers to parameters of the ICartRepo.GetCartByUserID
type ICartRepoMockGetCartByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
}

// ICartRepoMockGetCartByUserIDResults contains results of the ICartRepo.GetCartByUserID
type ICartRepoMockGetCartByUserIDResults struct {
	ca1 []models.CartItem
	err error
}

// ICartRepoMockGetCartByUserIDOrigins contains origins of expectations of the ICartRepo.GetCartByUserID
type ICartRepoMockGetCartByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Optional() *mICartRepoMockGetCartByUserID {
	mmGetCartByUserID.optional = true
	return mmGetCartByUserID
}

// Expect sets up expected params for ICartRepo.GetCartByUserID
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Expect(ctx context.Context, userID models.UserID) *mICartRepoMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &ICartRepoMockGetCartByUserIDExpectation{}
	}

	if mmGetCartByUserID.defaultExpectation.paramPtrs != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by ExpectParams functions")
	}

	mmGetCartByUserID.defaultExpectation.params = &ICartRepoMockGetCartByUserIDParams{ctx, userID}
	mmGetCartByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartByUserID.expectations {
		if minimock.Equal(e.params, mmGetCartByUserID.defaultExpectation.params) {
			mmGetCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartByUserID.defaultExpectation.params)
		}
	}

	return mmGetCartByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.GetCartByUserID
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) ExpectCtxParam1(ctx context.Context) *mICartRepoMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &ICartRepoMockGetCartByUserIDExpectation{}
	}

	if mmGetCartByUserID.defaultExpectation.params != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Expect")
	}

	if mmGetCartByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserID.defaultExpectation.paramPtrs = &ICartRepoMockGetCartByUserIDParamPtrs{}
	}
	mmGetCartByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartByUserID
}

// ExpectUserIDParam2 sets up expected param userID for ICartRepo.GetCartByUserID
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) ExpectUserIDParam2(userID models.UserID) *mICartRepoMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &ICartRepoMockGetCartByUserIDExpectation{}
	}

	if mmGetCartByUserID.defaultExpectation.params != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Expect")
	}

	if mmGetCartByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserID.defaultExpectation.paramPtrs = &ICartRepoMockGetCartByUserIDParamPtrs{}
	}
	mmGetCartByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetCartByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.GetCartByUserID
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Inspect(f func(ctx context.Context, userID models.UserID)) *mICartRepoMockGetCartByUserID {
	if mmGetCartByUserID.mock.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.GetCartByUserID")
	}

	mmGetCartByUserID.mock.inspectFuncGetCartByUserID = f

	return mmGetCartByUserID
}

// Return sets up results that will be returned by ICartRepo.GetCartByUserID
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Return(ca1 []models.CartItem, err error) *ICartRepoMock {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &ICartRepoMockGetCartByUserIDExpectation{mock: mmGetCartByUserID.mock}
	}
	mmGetCartByUserID.defaultExpectation.results = &ICartRepoMockGetCartByUserIDResults{ca1, err}
	mmGetCartByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserID.mock
}

// Set uses given function f to mock the ICartRepo.GetCartByUserID method
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Set(f func(ctx context.Context, userID models.UserID) (ca1 []models.CartItem, err error)) *ICartRepoMock {
	if mmGetCartByUserID.defaultExpectation != nil {
		mmGetCartByUserID.mock.t.Fatalf("Default expectation is already set for the ICartRepo.GetCartByUserID method")
	}

	if len(mmGetCartByUserID.expectations) > 0 {
		mmGetCartByUserID.mock.t.Fatalf("Some expectations are already set for the ICartRepo.GetCartByUserID method")
	}

	mmGetCartByUserID.mock.funcGetCartByUserID = f
	mmGetCartByUserID.mock.funcGetCartByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserID.mock
}

// When sets expectation for the ICartRepo.GetCartByUserID which will trigger the result defined by the following
// Then helper
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) When(ctx context.Context, userID models.UserID) *ICartRepoMockGetCartByUserIDExpectation {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("ICartRepoMock.GetCartByUserID mock is already set by Set")
	}

	expectation := &ICartRepoMockGetCartByUserIDExpectation{
		mock:               mmGetCartByUserID.mock,
		params:             &ICartRepoMockGetCartByUserIDParams{ctx, userID},
		expectationOrigins: ICartRepoMockGetCartByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartByUserID.expectations = append(mmGetCartByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.GetCartByUserID return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockGetCartByUserIDExpectation) Then(ca1 []models.CartItem, err error) *ICartRepoMock {
	e.results = &ICartRepoMockGetCartByUserIDResults{ca1, err}
	return e.mock
}

// Times sets number of times ICartRepo.GetCartByUserID should be invoked
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Times(n uint64) *mICartRepoMockGetCartByUserID {
	if n == 0 {
		mmGetCartByUserID.mock.t.Fatalf("Times of ICartRepoMock.GetCartByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartByUserID.expectedInvocations, n)
	mmGetCartByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserID
}

func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) invocationsDone() bool {
	if len(mmGetCartByUserID.expectations) == 0 && mmGetCartByUserID.defaultExpectation == nil && mmGetCartByUserID.mock.funcGetCartByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartByUserID.mock.afterGetCartByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartByUserID implements mm_repository.ICartRepo
func (mmGetCartByUserID *ICartRepoMock) GetCartByUserID(ctx context.Context, userID models.UserID) (ca1 []models.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter, 1)

	mmGetCartByUserID.t.Helper()

	if mmGetCartByUserID.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.inspectFuncGetCartByUserID(ctx, userID)
	}

	mm_params := ICartRepoMockGetCartByUserIDParams{ctx, userID}

	// Record call args
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Lock()
	mmGetCartByUserID.GetCartByUserIDMock.callArgs = append(mmGetCartByUserID.GetCartByUserIDMock.callArgs, &mm_params)
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Unlock()

	for _, e := range mmGetCartByUserID.GetCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockGetCartByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartByUserID.t.Errorf("ICartRepoMock.GetCartByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCartByUserID.t.Errorf("ICartRepoMock.GetCartByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartByUserID.t.Errorf("ICartRepoMock.GetCartByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartByUserID.t.Fatal("No results are set for the ICartRepoMock.GetCartByUserID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetCartByUserID.funcGetCartByUserID != nil {
		return mmGetCartByUserID.funcGetCartByUserID(ctx, userID)
	}
	mmGetCartByUserID.t.Fatalf("Unexpected call to ICartRepoMock.GetCartByUserID. %v %v", ctx, userID)
	return
}

// GetCartByUserIDAfterCounter returns a count of finished ICartRepoMock.GetCartByUserID invocations
func (mmGetCartByUserID *ICartRepoMock) GetCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter)
}

// GetCartByUserIDBeforeCounter returns a count of ICartRepoMock.GetCartByUserID invocations
func (mmGetCartByUserID *ICartRepoMock) GetCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.GetCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartByUserID *mICartRepoMockGetCartByUserID) Calls() []*ICartRepoMockGetCartByUserIDParams {
	mmGetCartByUserID.mutex.RLock()

	argCopy := make([]*ICartRepoMockGetCartByUserIDParams, len(mmGetCartByUserID.callArgs))
	copy(argCopy, mmGetCartByUserID.callArgs)

	mmGetCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartByUserIDDone returns true if the count of the GetCartByUserID invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockGetCartByUserIDDone() bool {
	if m.GetCartByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartByUserIDMock.invocationsDone()
}

// MinimockGetCartByUserIDInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockGetCartByUserIDInspect() {
	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIDMock.defaultExpectation != nil && afterGetCartByUserIDCounter < 1 {
		if m.GetCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartByUserID at\n%s", m.GetCartByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartByUserID at\n%s with params: %#v", m.GetCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserID != nil && afterGetCartByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.GetCartByUserID at\n%s", m.funcGetCartByUserIDOrigin)
	}

	if !m.GetCartByUserIDMock.invocationsDone() && afterGetCartByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.GetCartByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartByUserIDMock.expectedInvocations), m.GetCartByUserIDMock.expectedInvocationsOrigin, afterGetCartByUserIDCounter)
	}
}

type mICartRepoMockGetCartID struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockGetCartIDExpectation
	expectations       []*ICartRepoMockGetCartIDExpectation

	callArgs []*ICartRepoMockGetCartIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockGetCartIDExpectation specifies expectation struct of the ICartRepo.GetCartID
type ICartRepoMockGetCartIDExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockGetCartIDParams
	paramPtrs          *ICartRepoMockGetCartIDParamPtrs
	expectationOrigins ICartRepoMockGetCartIDExpectationOrigins
	results            *ICartRepoMockGetCartIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockGetCartIDParams contains parameters of the ICartRepo.GetCartID
type ICartRepoMockGetCartIDParams struct {
	ctx    context.Context
	userID models.UserID
	skuID  models.SKUID
}

// ICartRepoMockGetCartIDParamPtrs contains pointers to parameters of the ICartRepo.GetCartID
type ICartRepoMockGetCartIDParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
	skuID  *models.SKUID
}

// ICartRepoMockGetCartIDResults contains results of the ICartRepo.GetCartID
type ICartRepoMockGetCartIDResults struct {
	c2  models.CartID
	err error
}

// ICartRepoMockGetCartIDOrigins contains origins of expectations of the ICartRepo.GetCartID
type ICartRepoMockGetCartIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartID *mICartRepoMockGetCartID) Optional() *mICartRepoMockGetCartID {
	mmGetCartID.optional = true
	return mmGetCartID
}

// Expect sets up expected params for ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) Expect(ctx context.Context, userID models.UserID, skuID models.SKUID) *mICartRepoMockGetCartID {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	if mmGetCartID.defaultExpectation == nil {
		mmGetCartID.defaultExpectation = &ICartRepoMockGetCartIDExpectation{}
	}

	if mmGetCartID.defaultExpectation.paramPtrs != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by ExpectParams functions")
	}

	mmGetCartID.defaultExpectation.params = &ICartRepoMockGetCartIDParams{ctx, userID, skuID}
	mmGetCartID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartID.expectations {
		if minimock.Equal(e.params, mmGetCartID.defaultExpectation.params) {
			mmGetCartID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartID.defaultExpectation.params)
		}
	}

	return mmGetCartID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) ExpectCtxParam1(ctx context.Context) *mICartRepoMockGetCartID {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	if mmGetCartID.defaultExpectation == nil {
		mmGetCartID.defaultExpectation = &ICartRepoMockGetCartIDExpectation{}
	}

	if mmGetCartID.defaultExpectation.params != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Expect")
	}

	if mmGetCartID.defaultExpectation.paramPtrs == nil {
		mmGetCartID.defaultExpectation.paramPtrs = &ICartRepoMockGetCartIDParamPtrs{}
	}
	mmGetCartID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartID
}

// ExpectUserIDParam2 sets up expected param userID for ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) ExpectUserIDParam2(userID models.UserID) *mICartRepoMockGetCartID {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	if mmGetCartID.defaultExpectation == nil {
		mmGetCartID.defaultExpectation = &ICartRepoMockGetCartIDExpectation{}
	}

	if mmGetCartID.defaultExpectation.params != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Expect")
	}

	if mmGetCartID.defaultExpectation.paramPtrs == nil {
		mmGetCartID.defaultExpectation.paramPtrs = &ICartRepoMockGetCartIDParamPtrs{}
	}
	mmGetCartID.defaultExpectation.paramPtrs.userID = &userID
	mmGetCartID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCartID
}

// ExpectSkuIDParam3 sets up expected param skuID for ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) ExpectSkuIDParam3(skuID models.SKUID) *mICartRepoMockGetCartID {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	if mmGetCartID.defaultExpectation == nil {
		mmGetCartID.defaultExpectation = &ICartRepoMockGetCartIDExpectation{}
	}

	if mmGetCartID.defaultExpectation.params != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Expect")
	}

	if mmGetCartID.defaultExpectation.paramPtrs == nil {
		mmGetCartID.defaultExpectation.paramPtrs = &ICartRepoMockGetCartIDParamPtrs{}
	}
	mmGetCartID.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetCartID.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetCartID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) Inspect(f func(ctx context.Context, userID models.UserID, skuID models.SKUID)) *mICartRepoMockGetCartID {
	if mmGetCartID.mock.inspectFuncGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.GetCartID")
	}

	mmGetCartID.mock.inspectFuncGetCartID = f

	return mmGetCartID
}

// Return sets up results that will be returned by ICartRepo.GetCartID
func (mmGetCartID *mICartRepoMockGetCartID) Return(c2 models.CartID, err error) *ICartRepoMock {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	if mmGetCartID.defaultExpectation == nil {
		mmGetCartID.defaultExpectation = &ICartRepoMockGetCartIDExpectation{mock: mmGetCartID.mock}
	}
	mmGetCartID.defaultExpectation.results = &ICartRepoMockGetCartIDResults{c2, err}
	mmGetCartID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartID.mock
}

// Set uses given function f to mock the ICartRepo.GetCartID method
func (mmGetCartID *mICartRepoMockGetCartID) Set(f func(ctx context.Context, userID models.UserID, skuID models.SKUID) (c2 models.CartID, err error)) *ICartRepoMock {
	if mmGetCartID.defaultExpectation != nil {
		mmGetCartID.mock.t.Fatalf("Default expectation is already set for the ICartRepo.GetCartID method")
	}

	if len(mmGetCartID.expectations) > 0 {
		mmGetCartID.mock.t.Fatalf("Some expectations are already set for the ICartRepo.GetCartID method")
	}

	mmGetCartID.mock.funcGetCartID = f
	mmGetCartID.mock.funcGetCartIDOrigin = minimock.CallerInfo(1)
	return mmGetCartID.mock
}

// When sets expectation for the ICartRepo.GetCartID which will trigger the result defined by the following
// Then helper
func (mmGetCartID *mICartRepoMockGetCartID) When(ctx context.Context, userID models.UserID, skuID models.SKUID) *ICartRepoMockGetCartIDExpectation {
	if mmGetCartID.mock.funcGetCartID != nil {
		mmGetCartID.mock.t.Fatalf("ICartRepoMock.GetCartID mock is already set by Set")
	}

	expectation := &ICartRepoMockGetCartIDExpectation{
		mock:               mmGetCartID.mock,
		params:             &ICartRepoMockGetCartIDParams{ctx, userID, skuID},
		expectationOrigins: ICartRepoMockGetCartIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartID.expectations = append(mmGetCartID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.GetCartID return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockGetCartIDExpectation) Then(c2 models.CartID, err error) *ICartRepoMock {
	e.results = &ICartRepoMockGetCartIDResults{c2, err}
	return e.mock
}

// Times sets number of times ICartRepo.GetCartID should be invoked
func (mmGetCartID *mICartRepoMockGetCartID) Times(n uint64) *mICartRepoMockGetCartID {
	if n == 0 {
		mmGetCartID.mock.t.Fatalf("Times of ICartRepoMock.GetCartID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartID.expectedInvocations, n)
	mmGetCartID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartID
}

func (mmGetCartID *mICartRepoMockGetCartID) invocationsDone() bool {
	if len(mmGetCartID.expectations) == 0 && mmGetCartID.defaultExpectation == nil && mmGetCartID.mock.funcGetCartID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartID.mock.afterGetCartIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartID implements mm_repository.ICartRepo
func (mmGetCartID *ICartRepoMock) GetCartID(ctx context.Context, userID models.UserID, skuID models.SKUID) (c2 models.CartID, err error) {
	mm_atomic.AddUint64(&mmGetCartID.beforeGetCartIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartID.afterGetCartIDCounter, 1)

	mmGetCartID.t.Helper()

	if mmGetCartID.inspectFuncGetCartID != nil {
		mmGetCartID.inspectFuncGetCartID(ctx, userID, skuID)
	}

	mm_params := ICartRepoMockGetCartIDParams{ctx, userID, skuID}

	// Record call args
	mmGetCartID.GetCartIDMock.mutex.Lock()
	mmGetCartID.GetCartIDMock.callArgs = append(mmGetCartID.GetCartIDMock.callArgs, &mm_params)
	mmGetCartID.GetCartIDMock.mutex.Unlock()

	for _, e := range mmGetCartID.GetCartIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartID.GetCartIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartID.GetCartIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartID.GetCartIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartID.GetCartIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockGetCartIDParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartID.t.Errorf("ICartRepoMock.GetCartID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartID.GetCartIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCartID.t.Errorf("ICartRepoMock.GetCartID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartID.GetCartIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetCartID.t.Errorf("ICartRepoMock.GetCartID got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartID.GetCartIDMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartID.t.Errorf("ICartRepoMock.GetCartID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartID.GetCartIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartID.GetCartIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartID.t.Fatal("No results are set for the ICartRepoMock.GetCartID")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartID.funcGetCartID != nil {
		return mmGetCartID.funcGetCartID(ctx, userID, skuID)
	}
	mmGetCartID.t.Fatalf("Unexpected call to ICartRepoMock.GetCartID. %v %v %v", ctx, userID, skuID)
	return
}

// GetCartIDAfterCounter returns a count of finished ICartRepoMock.GetCartID invocations
func (mmGetCartID *ICartRepoMock) GetCartIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartID.afterGetCartIDCounter)
}

// GetCartIDBeforeCounter returns a count of ICartRepoMock.GetCartID invocations
func (mmGetCartID *ICartRepoMock) GetCartIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartID.beforeGetCartIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.GetCartID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartID *mICartRepoMockGetCartID) Calls() []*ICartRepoMockGetCartIDParams {
	mmGetCartID.mutex.RLock()

	argCopy := make([]*ICartRepoMockGetCartIDParams, len(mmGetCartID.callArgs))
	copy(argCopy, mmGetCartID.callArgs)

	mmGetCartID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartIDDone returns true if the count of the GetCartID invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockGetCartIDDone() bool {
	if m.GetCartIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartIDMock.invocationsDone()
}

// MinimockGetCartIDInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockGetCartIDInspect() {
	for _, e := range m.GetCartIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartIDCounter := mm_atomic.LoadUint64(&m.afterGetCartIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartIDMock.defaultExpectation != nil && afterGetCartIDCounter < 1 {
		if m.GetCartIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartID at\n%s", m.GetCartIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.GetCartID at\n%s with params: %#v", m.GetCartIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCartIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartID != nil && afterGetCartIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.GetCartID at\n%s", m.funcGetCartIDOrigin)
	}

	if !m.GetCartIDMock.invocationsDone() && afterGetCartIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.GetCartID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartIDMock.expectedInvocations), m.GetCartIDMock.expectedInvocationsOrigin, afterGetCartIDCounter)
	}
}

type mICartRepoMockUpdateItemByUserID struct {
	optional           bool
	mock               *ICartRepoMock
	defaultExpectation *ICartRepoMockUpdateItemByUserIDExpectation
	expectations       []*ICartRepoMockUpdateItemByUserIDExpectation

	callArgs []*ICartRepoMockUpdateItemByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepoMockUpdateItemByUserIDExpectation specifies expectation struct of the ICartRepo.UpdateItemByUserID
type ICartRepoMockUpdateItemByUserIDExpectation struct {
	mock               *ICartRepoMock
	params             *ICartRepoMockUpdateItemByUserIDParams
	paramPtrs          *ICartRepoMockUpdateItemByUserIDParamPtrs
	expectationOrigins ICartRepoMockUpdateItemByUserIDExpectationOrigins
	results            *ICartRepoMockUpdateItemByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepoMockUpdateItemByUserIDParams contains parameters of the ICartRepo.UpdateItemByUserID
type ICartRepoMockUpdateItemByUserIDParams struct {
	ctx  context.Context
	cart models.Cart
}

// ICartRepoMockUpdateItemByUserIDParamPtrs contains pointers to parameters of the ICartRepo.UpdateItemByUserID
type ICartRepoMockUpdateItemByUserIDParamPtrs struct {
	ctx  *context.Context
	cart *models.Cart
}

// ICartRepoMockUpdateItemByUserIDResults contains results of the ICartRepo.UpdateItemByUserID
type ICartRepoMockUpdateItemByUserIDResults struct {
	err error
}

// ICartRepoMockUpdateItemByUserIDOrigins contains origins of expectations of the ICartRepo.UpdateItemByUserID
type ICartRepoMockUpdateItemByUserIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originCart string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Optional() *mICartRepoMockUpdateItemByUserID {
	mmUpdateItemByUserID.optional = true
	return mmUpdateItemByUserID
}

// Expect sets up expected params for ICartRepo.UpdateItemByUserID
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Expect(ctx context.Context, cart models.Cart) *mICartRepoMockUpdateItemByUserID {
	if mmUpdateItemByUserID.mock.funcUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Set")
	}

	if mmUpdateItemByUserID.defaultExpectation == nil {
		mmUpdateItemByUserID.defaultExpectation = &ICartRepoMockUpdateItemByUserIDExpectation{}
	}

	if mmUpdateItemByUserID.defaultExpectation.paramPtrs != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by ExpectParams functions")
	}

	mmUpdateItemByUserID.defaultExpectation.params = &ICartRepoMockUpdateItemByUserIDParams{ctx, cart}
	mmUpdateItemByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateItemByUserID.expectations {
		if minimock.Equal(e.params, mmUpdateItemByUserID.defaultExpectation.params) {
			mmUpdateItemByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateItemByUserID.defaultExpectation.params)
		}
	}

	return mmUpdateItemByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepo.UpdateItemByUserID
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) ExpectCtxParam1(ctx context.Context) *mICartRepoMockUpdateItemByUserID {
	if mmUpdateItemByUserID.mock.funcUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Set")
	}

	if mmUpdateItemByUserID.defaultExpectation == nil {
		mmUpdateItemByUserID.defaultExpectation = &ICartRepoMockUpdateItemByUserIDExpectation{}
	}

	if mmUpdateItemByUserID.defaultExpectation.params != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Expect")
	}

	if mmUpdateItemByUserID.defaultExpectation.paramPtrs == nil {
		mmUpdateItemByUserID.defaultExpectation.paramPtrs = &ICartRepoMockUpdateItemByUserIDParamPtrs{}
	}
	mmUpdateItemByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateItemByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateItemByUserID
}

// ExpectCartParam2 sets up expected param cart for ICartRepo.UpdateItemByUserID
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) ExpectCartParam2(cart models.Cart) *mICartRepoMockUpdateItemByUserID {
	if mmUpdateItemByUserID.mock.funcUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Set")
	}

	if mmUpdateItemByUserID.defaultExpectation == nil {
		mmUpdateItemByUserID.defaultExpectation = &ICartRepoMockUpdateItemByUserIDExpectation{}
	}

	if mmUpdateItemByUserID.defaultExpectation.params != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Expect")
	}

	if mmUpdateItemByUserID.defaultExpectation.paramPtrs == nil {
		mmUpdateItemByUserID.defaultExpectation.paramPtrs = &ICartRepoMockUpdateItemByUserIDParamPtrs{}
	}
	mmUpdateItemByUserID.defaultExpectation.paramPtrs.cart = &cart
	mmUpdateItemByUserID.defaultExpectation.expectationOrigins.originCart = minimock.CallerInfo(1)

	return mmUpdateItemByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepo.UpdateItemByUserID
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Inspect(f func(ctx context.Context, cart models.Cart)) *mICartRepoMockUpdateItemByUserID {
	if mmUpdateItemByUserID.mock.inspectFuncUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("Inspect function is already set for ICartRepoMock.UpdateItemByUserID")
	}

	mmUpdateItemByUserID.mock.inspectFuncUpdateItemByUserID = f

	return mmUpdateItemByUserID
}

// Return sets up results that will be returned by ICartRepo.UpdateItemByUserID
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Return(err error) *ICartRepoMock {
	if mmUpdateItemByUserID.mock.funcUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Set")
	}

	if mmUpdateItemByUserID.defaultExpectation == nil {
		mmUpdateItemByUserID.defaultExpectation = &ICartRepoMockUpdateItemByUserIDExpectation{mock: mmUpdateItemByUserID.mock}
	}
	mmUpdateItemByUserID.defaultExpectation.results = &ICartRepoMockUpdateItemByUserIDResults{err}
	mmUpdateItemByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateItemByUserID.mock
}

// Set uses given function f to mock the ICartRepo.UpdateItemByUserID method
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Set(f func(ctx context.Context, cart models.Cart) (err error)) *ICartRepoMock {
	if mmUpdateItemByUserID.defaultExpectation != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("Default expectation is already set for the ICartRepo.UpdateItemByUserID method")
	}

	if len(mmUpdateItemByUserID.expectations) > 0 {
		mmUpdateItemByUserID.mock.t.Fatalf("Some expectations are already set for the ICartRepo.UpdateItemByUserID method")
	}

	mmUpdateItemByUserID.mock.funcUpdateItemByUserID = f
	mmUpdateItemByUserID.mock.funcUpdateItemByUserIDOrigin = minimock.CallerInfo(1)
	return mmUpdateItemByUserID.mock
}

// When sets expectation for the ICartRepo.UpdateItemByUserID which will trigger the result defined by the following
// Then helper
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) When(ctx context.Context, cart models.Cart) *ICartRepoMockUpdateItemByUserIDExpectation {
	if mmUpdateItemByUserID.mock.funcUpdateItemByUserID != nil {
		mmUpdateItemByUserID.mock.t.Fatalf("ICartRepoMock.UpdateItemByUserID mock is already set by Set")
	}

	expectation := &ICartRepoMockUpdateItemByUserIDExpectation{
		mock:               mmUpdateItemByUserID.mock,
		params:             &ICartRepoMockUpdateItemByUserIDParams{ctx, cart},
		expectationOrigins: ICartRepoMockUpdateItemByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateItemByUserID.expectations = append(mmUpdateItemByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepo.UpdateItemByUserID return parameters for the expectation previously defined by the When method
func (e *ICartRepoMockUpdateItemByUserIDExpectation) Then(err error) *ICartRepoMock {
	e.results = &ICartRepoMockUpdateItemByUserIDResults{err}
	return e.mock
}

// Times sets number of times ICartRepo.UpdateItemByUserID should be invoked
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Times(n uint64) *mICartRepoMockUpdateItemByUserID {
	if n == 0 {
		mmUpdateItemByUserID.mock.t.Fatalf("Times of ICartRepoMock.UpdateItemByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateItemByUserID.expectedInvocations, n)
	mmUpdateItemByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateItemByUserID
}

func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) invocationsDone() bool {
	if len(mmUpdateItemByUserID.expectations) == 0 && mmUpdateItemByUserID.defaultExpectation == nil && mmUpdateItemByUserID.mock.funcUpdateItemByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateItemByUserID.mock.afterUpdateItemByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateItemByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateItemByUserID implements mm_repository.ICartRepo
func (mmUpdateItemByUserID *ICartRepoMock) UpdateItemByUserID(ctx context.Context, cart models.Cart) (err error) {
	mm_atomic.AddUint64(&mmUpdateItemByUserID.beforeUpdateItemByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateItemByUserID.afterUpdateItemByUserIDCounter, 1)

	mmUpdateItemByUserID.t.Helper()

	if mmUpdateItemByUserID.inspectFuncUpdateItemByUserID != nil {
		mmUpdateItemByUserID.inspectFuncUpdateItemByUserID(ctx, cart)
	}

	mm_params := ICartRepoMockUpdateItemByUserIDParams{ctx, cart}

	// Record call args
	mmUpdateItemByUserID.UpdateItemByUserIDMock.mutex.Lock()
	mmUpdateItemByUserID.UpdateItemByUserIDMock.callArgs = append(mmUpdateItemByUserID.UpdateItemByUserIDMock.callArgs, &mm_params)
	mmUpdateItemByUserID.UpdateItemByUserIDMock.mutex.Unlock()

	for _, e := range mmUpdateItemByUserID.UpdateItemByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepoMockUpdateItemByUserIDParams{ctx, cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateItemByUserID.t.Errorf("ICartRepoMock.UpdateItemByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmUpdateItemByUserID.t.Errorf("ICartRepoMock.UpdateItemByUserID got unexpected parameter cart, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.expectationOrigins.originCart, *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateItemByUserID.t.Errorf("ICartRepoMock.UpdateItemByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateItemByUserID.UpdateItemByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateItemByUserID.t.Fatal("No results are set for the ICartRepoMock.UpdateItemByUserID")
		}
		return (*mm_results).err
	}
	if mmUpdateItemByUserID.funcUpdateItemByUserID != nil {
		return mmUpdateItemByUserID.funcUpdateItemByUserID(ctx, cart)
	}
	mmUpdateItemByUserID.t.Fatalf("Unexpected call to ICartRepoMock.UpdateItemByUserID. %v %v", ctx, cart)
	return
}

// UpdateItemByUserIDAfterCounter returns a count of finished ICartRepoMock.UpdateItemByUserID invocations
func (mmUpdateItemByUserID *ICartRepoMock) UpdateItemByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateItemByUserID.afterUpdateItemByUserIDCounter)
}

// UpdateItemByUserIDBeforeCounter returns a count of ICartRepoMock.UpdateItemByUserID invocations
func (mmUpdateItemByUserID *ICartRepoMock) UpdateItemByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateItemByUserID.beforeUpdateItemByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepoMock.UpdateItemByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateItemByUserID *mICartRepoMockUpdateItemByUserID) Calls() []*ICartRepoMockUpdateItemByUserIDParams {
	mmUpdateItemByUserID.mutex.RLock()

	argCopy := make([]*ICartRepoMockUpdateItemByUserIDParams, len(mmUpdateItemByUserID.callArgs))
	copy(argCopy, mmUpdateItemByUserID.callArgs)

	mmUpdateItemByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateItemByUserIDDone returns true if the count of the UpdateItemByUserID invocations corresponds
// the number of defined expectations
func (m *ICartRepoMock) MinimockUpdateItemByUserIDDone() bool {
	if m.UpdateItemByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateItemByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateItemByUserIDMock.invocationsDone()
}

// MinimockUpdateItemByUserIDInspect logs each unmet expectation
func (m *ICartRepoMock) MinimockUpdateItemByUserIDInspect() {
	for _, e := range m.UpdateItemByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepoMock.UpdateItemByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateItemByUserIDCounter := mm_atomic.LoadUint64(&m.afterUpdateItemByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateItemByUserIDMock.defaultExpectation != nil && afterUpdateItemByUserIDCounter < 1 {
		if m.UpdateItemByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepoMock.UpdateItemByUserID at\n%s", m.UpdateItemByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepoMock.UpdateItemByUserID at\n%s with params: %#v", m.UpdateItemByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateItemByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateItemByUserID != nil && afterUpdateItemByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepoMock.UpdateItemByUserID at\n%s", m.funcUpdateItemByUserIDOrigin)
	}

	if !m.UpdateItemByUserIDMock.invocationsDone() && afterUpdateItemByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepoMock.UpdateItemByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateItemByUserIDMock.expectedInvocations), m.UpdateItemByUserIDMock.expectedInvocationsOrigin, afterUpdateItemByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICartRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockClearCartByUserIDInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetCartByUserIDInspect()

			m.MinimockGetCartIDInspect()

			m.MinimockUpdateItemByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICartRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICartRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockClearCartByUserIDDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetCartByUserIDDone() &&
		m.MinimockGetCartIDDone() &&
		m.MinimockUpdateItemByUserIDDone()
}
