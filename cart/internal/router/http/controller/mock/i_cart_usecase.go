// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"cart/internal/models"
	"cart/internal/usecase"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ICartUsecaseMock implements mm_controller.ICartUsecase
type ICartUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, addItem usecase.AddItemDTO) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, addItem usecase.AddItemDTO)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mICartUsecaseMockAddItem

	funcClearCartByUserID          func(ctx context.Context, userID models.UserID) (err error)
	funcClearCartByUserIDOrigin    string
	inspectFuncClearCartByUserID   func(ctx context.Context, userID models.UserID)
	afterClearCartByUserIDCounter  uint64
	beforeClearCartByUserIDCounter uint64
	ClearCartByUserIDMock          mICartUsecaseMockClearCartByUserID

	funcDeleteItem          func(ctx context.Context, delItem usecase.DeleteItemDTO) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, delItem usecase.DeleteItemDTO)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mICartUsecaseMockDeleteItem

	funcGetItemsByUserID          func(ctx context.Context, userID models.UserID) (l1 usecase.ListItemsDTO, err error)
	funcGetItemsByUserIDOrigin    string
	inspectFuncGetItemsByUserID   func(ctx context.Context, userID models.UserID)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mICartUsecaseMockGetItemsByUserID
}

// NewICartUsecaseMock returns a mock for mm_controller.ICartUsecase
func NewICartUsecaseMock(t minimock.Tester) *ICartUsecaseMock {
	m := &ICartUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mICartUsecaseMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ICartUsecaseMockAddItemParams{}

	m.ClearCartByUserIDMock = mICartUsecaseMockClearCartByUserID{mock: m}
	m.ClearCartByUserIDMock.callArgs = []*ICartUsecaseMockClearCartByUserIDParams{}

	m.DeleteItemMock = mICartUsecaseMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ICartUsecaseMockDeleteItemParams{}

	m.GetItemsByUserIDMock = mICartUsecaseMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*ICartUsecaseMockGetItemsByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mICartUsecaseMockAddItem struct {
	optional           bool
	mock               *ICartUsecaseMock
	defaultExpectation *ICartUsecaseMockAddItemExpectation
	expectations       []*ICartUsecaseMockAddItemExpectation

	callArgs []*ICartUsecaseMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartUsecaseMockAddItemExpectation specifies expectation struct of the ICartUsecase.AddItem
type ICartUsecaseMockAddItemExpectation struct {
	mock               *ICartUsecaseMock
	params             *ICartUsecaseMockAddItemParams
	paramPtrs          *ICartUsecaseMockAddItemParamPtrs
	expectationOrigins ICartUsecaseMockAddItemExpectationOrigins
	results            *ICartUsecaseMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartUsecaseMockAddItemParams contains parameters of the ICartUsecase.AddItem
type ICartUsecaseMockAddItemParams struct {
	ctx     context.Context
	addItem usecase.AddItemDTO
}

// ICartUsecaseMockAddItemParamPtrs contains pointers to parameters of the ICartUsecase.AddItem
type ICartUsecaseMockAddItemParamPtrs struct {
	ctx     *context.Context
	addItem *usecase.AddItemDTO
}

// ICartUsecaseMockAddItemResults contains results of the ICartUsecase.AddItem
type ICartUsecaseMockAddItemResults struct {
	err error
}

// ICartUsecaseMockAddItemOrigins contains origins of expectations of the ICartUsecase.AddItem
type ICartUsecaseMockAddItemExpectationOrigins struct {
	origin        string
	originCtx     string
	originAddItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mICartUsecaseMockAddItem) Optional() *mICartUsecaseMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for ICartUsecase.AddItem
func (mmAddItem *mICartUsecaseMockAddItem) Expect(ctx context.Context, addItem usecase.AddItemDTO) *mICartUsecaseMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartUsecaseMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ICartUsecaseMockAddItemParams{ctx, addItem}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartUsecase.AddItem
func (mmAddItem *mICartUsecaseMockAddItem) ExpectCtxParam1(ctx context.Context) *mICartUsecaseMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartUsecaseMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartUsecaseMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectAddItemParam2 sets up expected param addItem for ICartUsecase.AddItem
func (mmAddItem *mICartUsecaseMockAddItem) ExpectAddItemParam2(addItem usecase.AddItemDTO) *mICartUsecaseMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartUsecaseMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartUsecaseMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.addItem = &addItem
	mmAddItem.defaultExpectation.expectationOrigins.originAddItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the ICartUsecase.AddItem
func (mmAddItem *mICartUsecaseMockAddItem) Inspect(f func(ctx context.Context, addItem usecase.AddItemDTO)) *mICartUsecaseMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ICartUsecaseMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by ICartUsecase.AddItem
func (mmAddItem *mICartUsecaseMockAddItem) Return(err error) *ICartUsecaseMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartUsecaseMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ICartUsecaseMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the ICartUsecase.AddItem method
func (mmAddItem *mICartUsecaseMockAddItem) Set(f func(ctx context.Context, addItem usecase.AddItemDTO) (err error)) *ICartUsecaseMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the ICartUsecase.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the ICartUsecase.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the ICartUsecase.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mICartUsecaseMockAddItem) When(ctx context.Context, addItem usecase.AddItemDTO) *ICartUsecaseMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartUsecaseMock.AddItem mock is already set by Set")
	}

	expectation := &ICartUsecaseMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &ICartUsecaseMockAddItemParams{ctx, addItem},
		expectationOrigins: ICartUsecaseMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up ICartUsecase.AddItem return parameters for the expectation previously defined by the When method
func (e *ICartUsecaseMockAddItemExpectation) Then(err error) *ICartUsecaseMock {
	e.results = &ICartUsecaseMockAddItemResults{err}
	return e.mock
}

// Times sets number of times ICartUsecase.AddItem should be invoked
func (mmAddItem *mICartUsecaseMockAddItem) Times(n uint64) *mICartUsecaseMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ICartUsecaseMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mICartUsecaseMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_controller.ICartUsecase
func (mmAddItem *ICartUsecaseMock) AddItem(ctx context.Context, addItem usecase.AddItemDTO) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, addItem)
	}

	mm_params := ICartUsecaseMockAddItemParams{ctx, addItem}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ICartUsecaseMockAddItemParams{ctx, addItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ICartUsecaseMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.addItem != nil && !minimock.Equal(*mm_want_ptrs.addItem, mm_got.addItem) {
				mmAddItem.t.Errorf("ICartUsecaseMock.AddItem got unexpected parameter addItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originAddItem, *mm_want_ptrs.addItem, mm_got.addItem, minimock.Diff(*mm_want_ptrs.addItem, mm_got.addItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ICartUsecaseMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ICartUsecaseMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, addItem)
	}
	mmAddItem.t.Fatalf("Unexpected call to ICartUsecaseMock.AddItem. %v %v", ctx, addItem)
	return
}

// AddItemAfterCounter returns a count of finished ICartUsecaseMock.AddItem invocations
func (mmAddItem *ICartUsecaseMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ICartUsecaseMock.AddItem invocations
func (mmAddItem *ICartUsecaseMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ICartUsecaseMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mICartUsecaseMockAddItem) Calls() []*ICartUsecaseMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ICartUsecaseMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ICartUsecaseMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ICartUsecaseMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartUsecaseMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartUsecaseMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartUsecaseMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to ICartUsecaseMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartUsecaseMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mICartUsecaseMockClearCartByUserID struct {
	optional           bool
	mock               *ICartUsecaseMock
	defaultExpectation *ICartUsecaseMockClearCartByUserIDExpectation
	expectations       []*ICartUsecaseMockClearCartByUserIDExpectation

	callArgs []*ICartUsecaseMockClearCartByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartUsecaseMockClearCartByUserIDExpectation specifies expectation struct of the ICartUsecase.ClearCartByUserID
type ICartUsecaseMockClearCartByUserIDExpectation struct {
	mock               *ICartUsecaseMock
	params             *ICartUsecaseMockClearCartByUserIDParams
	paramPtrs          *ICartUsecaseMockClearCartByUserIDParamPtrs
	expectationOrigins ICartUsecaseMockClearCartByUserIDExpectationOrigins
	results            *ICartUsecaseMockClearCartByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartUsecaseMockClearCartByUserIDParams contains parameters of the ICartUsecase.ClearCartByUserID
type ICartUsecaseMockClearCartByUserIDParams struct {
	ctx    context.Context
	userID models.UserID
}

// ICartUsecaseMockClearCartByUserIDParamPtrs contains pointers to parameters of the ICartUsecase.ClearCartByUserID
type ICartUsecaseMockClearCartByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
}

// ICartUsecaseMockClearCartByUserIDResults contains results of the ICartUsecase.ClearCartByUserID
type ICartUsecaseMockClearCartByUserIDResults struct {
	err error
}

// ICartUsecaseMockClearCartByUserIDOrigins contains origins of expectations of the ICartUsecase.ClearCartByUserID
type ICartUsecaseMockClearCartByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Optional() *mICartUsecaseMockClearCartByUserID {
	mmClearCartByUserID.optional = true
	return mmClearCartByUserID
}

// Expect sets up expected params for ICartUsecase.ClearCartByUserID
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Expect(ctx context.Context, userID models.UserID) *mICartUsecaseMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartUsecaseMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by ExpectParams functions")
	}

	mmClearCartByUserID.defaultExpectation.params = &ICartUsecaseMockClearCartByUserIDParams{ctx, userID}
	mmClearCartByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCartByUserID.expectations {
		if minimock.Equal(e.params, mmClearCartByUserID.defaultExpectation.params) {
			mmClearCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCartByUserID.defaultExpectation.params)
		}
	}

	return mmClearCartByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartUsecase.ClearCartByUserID
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) ExpectCtxParam1(ctx context.Context) *mICartUsecaseMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartUsecaseMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.params != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Expect")
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs == nil {
		mmClearCartByUserID.defaultExpectation.paramPtrs = &ICartUsecaseMockClearCartByUserIDParamPtrs{}
	}
	mmClearCartByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCartByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCartByUserID
}

// ExpectUserIDParam2 sets up expected param userID for ICartUsecase.ClearCartByUserID
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) ExpectUserIDParam2(userID models.UserID) *mICartUsecaseMockClearCartByUserID {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartUsecaseMockClearCartByUserIDExpectation{}
	}

	if mmClearCartByUserID.defaultExpectation.params != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Expect")
	}

	if mmClearCartByUserID.defaultExpectation.paramPtrs == nil {
		mmClearCartByUserID.defaultExpectation.paramPtrs = &ICartUsecaseMockClearCartByUserIDParamPtrs{}
	}
	mmClearCartByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmClearCartByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartUsecase.ClearCartByUserID
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Inspect(f func(ctx context.Context, userID models.UserID)) *mICartUsecaseMockClearCartByUserID {
	if mmClearCartByUserID.mock.inspectFuncClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("Inspect function is already set for ICartUsecaseMock.ClearCartByUserID")
	}

	mmClearCartByUserID.mock.inspectFuncClearCartByUserID = f

	return mmClearCartByUserID
}

// Return sets up results that will be returned by ICartUsecase.ClearCartByUserID
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Return(err error) *ICartUsecaseMock {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Set")
	}

	if mmClearCartByUserID.defaultExpectation == nil {
		mmClearCartByUserID.defaultExpectation = &ICartUsecaseMockClearCartByUserIDExpectation{mock: mmClearCartByUserID.mock}
	}
	mmClearCartByUserID.defaultExpectation.results = &ICartUsecaseMockClearCartByUserIDResults{err}
	mmClearCartByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID.mock
}

// Set uses given function f to mock the ICartUsecase.ClearCartByUserID method
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Set(f func(ctx context.Context, userID models.UserID) (err error)) *ICartUsecaseMock {
	if mmClearCartByUserID.defaultExpectation != nil {
		mmClearCartByUserID.mock.t.Fatalf("Default expectation is already set for the ICartUsecase.ClearCartByUserID method")
	}

	if len(mmClearCartByUserID.expectations) > 0 {
		mmClearCartByUserID.mock.t.Fatalf("Some expectations are already set for the ICartUsecase.ClearCartByUserID method")
	}

	mmClearCartByUserID.mock.funcClearCartByUserID = f
	mmClearCartByUserID.mock.funcClearCartByUserIDOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID.mock
}

// When sets expectation for the ICartUsecase.ClearCartByUserID which will trigger the result defined by the following
// Then helper
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) When(ctx context.Context, userID models.UserID) *ICartUsecaseMockClearCartByUserIDExpectation {
	if mmClearCartByUserID.mock.funcClearCartByUserID != nil {
		mmClearCartByUserID.mock.t.Fatalf("ICartUsecaseMock.ClearCartByUserID mock is already set by Set")
	}

	expectation := &ICartUsecaseMockClearCartByUserIDExpectation{
		mock:               mmClearCartByUserID.mock,
		params:             &ICartUsecaseMockClearCartByUserIDParams{ctx, userID},
		expectationOrigins: ICartUsecaseMockClearCartByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCartByUserID.expectations = append(mmClearCartByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartUsecase.ClearCartByUserID return parameters for the expectation previously defined by the When method
func (e *ICartUsecaseMockClearCartByUserIDExpectation) Then(err error) *ICartUsecaseMock {
	e.results = &ICartUsecaseMockClearCartByUserIDResults{err}
	return e.mock
}

// Times sets number of times ICartUsecase.ClearCartByUserID should be invoked
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Times(n uint64) *mICartUsecaseMockClearCartByUserID {
	if n == 0 {
		mmClearCartByUserID.mock.t.Fatalf("Times of ICartUsecaseMock.ClearCartByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCartByUserID.expectedInvocations, n)
	mmClearCartByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCartByUserID
}

func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) invocationsDone() bool {
	if len(mmClearCartByUserID.expectations) == 0 && mmClearCartByUserID.defaultExpectation == nil && mmClearCartByUserID.mock.funcClearCartByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCartByUserID.mock.afterClearCartByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCartByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCartByUserID implements mm_controller.ICartUsecase
func (mmClearCartByUserID *ICartUsecaseMock) ClearCartByUserID(ctx context.Context, userID models.UserID) (err error) {
	mm_atomic.AddUint64(&mmClearCartByUserID.beforeClearCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCartByUserID.afterClearCartByUserIDCounter, 1)

	mmClearCartByUserID.t.Helper()

	if mmClearCartByUserID.inspectFuncClearCartByUserID != nil {
		mmClearCartByUserID.inspectFuncClearCartByUserID(ctx, userID)
	}

	mm_params := ICartUsecaseMockClearCartByUserIDParams{ctx, userID}

	// Record call args
	mmClearCartByUserID.ClearCartByUserIDMock.mutex.Lock()
	mmClearCartByUserID.ClearCartByUserIDMock.callArgs = append(mmClearCartByUserID.ClearCartByUserIDMock.callArgs, &mm_params)
	mmClearCartByUserID.ClearCartByUserIDMock.mutex.Unlock()

	for _, e := range mmClearCartByUserID.ClearCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartUsecaseMockClearCartByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCartByUserID.t.Errorf("ICartUsecaseMock.ClearCartByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCartByUserID.t.Errorf("ICartUsecaseMock.ClearCartByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCartByUserID.t.Errorf("ICartUsecaseMock.ClearCartByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCartByUserID.ClearCartByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCartByUserID.t.Fatal("No results are set for the ICartUsecaseMock.ClearCartByUserID")
		}
		return (*mm_results).err
	}
	if mmClearCartByUserID.funcClearCartByUserID != nil {
		return mmClearCartByUserID.funcClearCartByUserID(ctx, userID)
	}
	mmClearCartByUserID.t.Fatalf("Unexpected call to ICartUsecaseMock.ClearCartByUserID. %v %v", ctx, userID)
	return
}

// ClearCartByUserIDAfterCounter returns a count of finished ICartUsecaseMock.ClearCartByUserID invocations
func (mmClearCartByUserID *ICartUsecaseMock) ClearCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartByUserID.afterClearCartByUserIDCounter)
}

// ClearCartByUserIDBeforeCounter returns a count of ICartUsecaseMock.ClearCartByUserID invocations
func (mmClearCartByUserID *ICartUsecaseMock) ClearCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartByUserID.beforeClearCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartUsecaseMock.ClearCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCartByUserID *mICartUsecaseMockClearCartByUserID) Calls() []*ICartUsecaseMockClearCartByUserIDParams {
	mmClearCartByUserID.mutex.RLock()

	argCopy := make([]*ICartUsecaseMockClearCartByUserIDParams, len(mmClearCartByUserID.callArgs))
	copy(argCopy, mmClearCartByUserID.callArgs)

	mmClearCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartByUserIDDone returns true if the count of the ClearCartByUserID invocations corresponds
// the number of defined expectations
func (m *ICartUsecaseMock) MinimockClearCartByUserIDDone() bool {
	if m.ClearCartByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartByUserIDMock.invocationsDone()
}

// MinimockClearCartByUserIDInspect logs each unmet expectation
func (m *ICartUsecaseMock) MinimockClearCartByUserIDInspect() {
	for _, e := range m.ClearCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartUsecaseMock.ClearCartByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartByUserIDCounter := mm_atomic.LoadUint64(&m.afterClearCartByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartByUserIDMock.defaultExpectation != nil && afterClearCartByUserIDCounter < 1 {
		if m.ClearCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartUsecaseMock.ClearCartByUserID at\n%s", m.ClearCartByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartUsecaseMock.ClearCartByUserID at\n%s with params: %#v", m.ClearCartByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCartByUserID != nil && afterClearCartByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartUsecaseMock.ClearCartByUserID at\n%s", m.funcClearCartByUserIDOrigin)
	}

	if !m.ClearCartByUserIDMock.invocationsDone() && afterClearCartByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartUsecaseMock.ClearCartByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartByUserIDMock.expectedInvocations), m.ClearCartByUserIDMock.expectedInvocationsOrigin, afterClearCartByUserIDCounter)
	}
}

type mICartUsecaseMockDeleteItem struct {
	optional           bool
	mock               *ICartUsecaseMock
	defaultExpectation *ICartUsecaseMockDeleteItemExpectation
	expectations       []*ICartUsecaseMockDeleteItemExpectation

	callArgs []*ICartUsecaseMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartUsecaseMockDeleteItemExpectation specifies expectation struct of the ICartUsecase.DeleteItem
type ICartUsecaseMockDeleteItemExpectation struct {
	mock               *ICartUsecaseMock
	params             *ICartUsecaseMockDeleteItemParams
	paramPtrs          *ICartUsecaseMockDeleteItemParamPtrs
	expectationOrigins ICartUsecaseMockDeleteItemExpectationOrigins
	results            *ICartUsecaseMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartUsecaseMockDeleteItemParams contains parameters of the ICartUsecase.DeleteItem
type ICartUsecaseMockDeleteItemParams struct {
	ctx     context.Context
	delItem usecase.DeleteItemDTO
}

// ICartUsecaseMockDeleteItemParamPtrs contains pointers to parameters of the ICartUsecase.DeleteItem
type ICartUsecaseMockDeleteItemParamPtrs struct {
	ctx     *context.Context
	delItem *usecase.DeleteItemDTO
}

// ICartUsecaseMockDeleteItemResults contains results of the ICartUsecase.DeleteItem
type ICartUsecaseMockDeleteItemResults struct {
	err error
}

// ICartUsecaseMockDeleteItemOrigins contains origins of expectations of the ICartUsecase.DeleteItem
type ICartUsecaseMockDeleteItemExpectationOrigins struct {
	origin        string
	originCtx     string
	originDelItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Optional() *mICartUsecaseMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for ICartUsecase.DeleteItem
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Expect(ctx context.Context, delItem usecase.DeleteItemDTO) *mICartUsecaseMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartUsecaseMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &ICartUsecaseMockDeleteItemParams{ctx, delItem}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartUsecase.DeleteItem
func (mmDeleteItem *mICartUsecaseMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mICartUsecaseMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartUsecaseMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartUsecaseMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectDelItemParam2 sets up expected param delItem for ICartUsecase.DeleteItem
func (mmDeleteItem *mICartUsecaseMockDeleteItem) ExpectDelItemParam2(delItem usecase.DeleteItemDTO) *mICartUsecaseMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartUsecaseMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartUsecaseMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.delItem = &delItem
	mmDeleteItem.defaultExpectation.expectationOrigins.originDelItem = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the ICartUsecase.DeleteItem
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Inspect(f func(ctx context.Context, delItem usecase.DeleteItemDTO)) *mICartUsecaseMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ICartUsecaseMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by ICartUsecase.DeleteItem
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Return(err error) *ICartUsecaseMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartUsecaseMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &ICartUsecaseMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the ICartUsecase.DeleteItem method
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Set(f func(ctx context.Context, delItem usecase.DeleteItemDTO) (err error)) *ICartUsecaseMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the ICartUsecase.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the ICartUsecase.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the ICartUsecase.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mICartUsecaseMockDeleteItem) When(ctx context.Context, delItem usecase.DeleteItemDTO) *ICartUsecaseMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartUsecaseMock.DeleteItem mock is already set by Set")
	}

	expectation := &ICartUsecaseMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &ICartUsecaseMockDeleteItemParams{ctx, delItem},
		expectationOrigins: ICartUsecaseMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up ICartUsecase.DeleteItem return parameters for the expectation previously defined by the When method
func (e *ICartUsecaseMockDeleteItemExpectation) Then(err error) *ICartUsecaseMock {
	e.results = &ICartUsecaseMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times ICartUsecase.DeleteItem should be invoked
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Times(n uint64) *mICartUsecaseMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of ICartUsecaseMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mICartUsecaseMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_controller.ICartUsecase
func (mmDeleteItem *ICartUsecaseMock) DeleteItem(ctx context.Context, delItem usecase.DeleteItemDTO) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, delItem)
	}

	mm_params := ICartUsecaseMockDeleteItemParams{ctx, delItem}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := ICartUsecaseMockDeleteItemParams{ctx, delItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("ICartUsecaseMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.delItem != nil && !minimock.Equal(*mm_want_ptrs.delItem, mm_got.delItem) {
				mmDeleteItem.t.Errorf("ICartUsecaseMock.DeleteItem got unexpected parameter delItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originDelItem, *mm_want_ptrs.delItem, mm_got.delItem, minimock.Diff(*mm_want_ptrs.delItem, mm_got.delItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ICartUsecaseMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the ICartUsecaseMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, delItem)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ICartUsecaseMock.DeleteItem. %v %v", ctx, delItem)
	return
}

// DeleteItemAfterCounter returns a count of finished ICartUsecaseMock.DeleteItem invocations
func (mmDeleteItem *ICartUsecaseMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ICartUsecaseMock.DeleteItem invocations
func (mmDeleteItem *ICartUsecaseMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ICartUsecaseMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mICartUsecaseMockDeleteItem) Calls() []*ICartUsecaseMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ICartUsecaseMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ICartUsecaseMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ICartUsecaseMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartUsecaseMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartUsecaseMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartUsecaseMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to ICartUsecaseMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartUsecaseMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mICartUsecaseMockGetItemsByUserID struct {
	optional           bool
	mock               *ICartUsecaseMock
	defaultExpectation *ICartUsecaseMockGetItemsByUserIDExpectation
	expectations       []*ICartUsecaseMockGetItemsByUserIDExpectation

	callArgs []*ICartUsecaseMockGetItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartUsecaseMockGetItemsByUserIDExpectation specifies expectation struct of the ICartUsecase.GetItemsByUserID
type ICartUsecaseMockGetItemsByUserIDExpectation struct {
	mock               *ICartUsecaseMock
	params             *ICartUsecaseMockGetItemsByUserIDParams
	paramPtrs          *ICartUsecaseMockGetItemsByUserIDParamPtrs
	expectationOrigins ICartUsecaseMockGetItemsByUserIDExpectationOrigins
	results            *ICartUsecaseMockGetItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartUsecaseMockGetItemsByUserIDParams contains parameters of the ICartUsecase.GetItemsByUserID
type ICartUsecaseMockGetItemsByUserIDParams struct {
	ctx    context.Context
	userID models.UserID
}

// ICartUsecaseMockGetItemsByUserIDParamPtrs contains pointers to parameters of the ICartUsecase.GetItemsByUserID
type ICartUsecaseMockGetItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *models.UserID
}

// ICartUsecaseMockGetItemsByUserIDResults contains results of the ICartUsecase.GetItemsByUserID
type ICartUsecaseMockGetItemsByUserIDResults struct {
	l1  usecase.ListItemsDTO
	err error
}

// ICartUsecaseMockGetItemsByUserIDOrigins contains origins of expectations of the ICartUsecase.GetItemsByUserID
type ICartUsecaseMockGetItemsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Optional() *mICartUsecaseMockGetItemsByUserID {
	mmGetItemsByUserID.optional = true
	return mmGetItemsByUserID
}

// Expect sets up expected params for ICartUsecase.GetItemsByUserID
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Expect(ctx context.Context, userID models.UserID) *mICartUsecaseMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartUsecaseMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by ExpectParams functions")
	}

	mmGetItemsByUserID.defaultExpectation.params = &ICartUsecaseMockGetItemsByUserIDParams{ctx, userID}
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartUsecase.GetItemsByUserID
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) ExpectCtxParam1(ctx context.Context) *mICartUsecaseMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartUsecaseMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &ICartUsecaseMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for ICartUsecase.GetItemsByUserID
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) ExpectUserIDParam2(userID models.UserID) *mICartUsecaseMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartUsecaseMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &ICartUsecaseMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartUsecase.GetItemsByUserID
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Inspect(f func(ctx context.Context, userID models.UserID)) *mICartUsecaseMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for ICartUsecaseMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by ICartUsecase.GetItemsByUserID
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Return(l1 usecase.ListItemsDTO, err error) *ICartUsecaseMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartUsecaseMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &ICartUsecaseMockGetItemsByUserIDResults{l1, err}
	mmGetItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the ICartUsecase.GetItemsByUserID method
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Set(f func(ctx context.Context, userID models.UserID) (l1 usecase.ListItemsDTO, err error)) *ICartUsecaseMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the ICartUsecase.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the ICartUsecase.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	mmGetItemsByUserID.mock.funcGetItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// When sets expectation for the ICartUsecase.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) When(ctx context.Context, userID models.UserID) *ICartUsecaseMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartUsecaseMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &ICartUsecaseMockGetItemsByUserIDExpectation{
		mock:               mmGetItemsByUserID.mock,
		params:             &ICartUsecaseMockGetItemsByUserIDParams{ctx, userID},
		expectationOrigins: ICartUsecaseMockGetItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartUsecase.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ICartUsecaseMockGetItemsByUserIDExpectation) Then(l1 usecase.ListItemsDTO, err error) *ICartUsecaseMock {
	e.results = &ICartUsecaseMockGetItemsByUserIDResults{l1, err}
	return e.mock
}

// Times sets number of times ICartUsecase.GetItemsByUserID should be invoked
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Times(n uint64) *mICartUsecaseMockGetItemsByUserID {
	if n == 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Times of ICartUsecaseMock.GetItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUserID.expectedInvocations, n)
	mmGetItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID
}

func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) invocationsDone() bool {
	if len(mmGetItemsByUserID.expectations) == 0 && mmGetItemsByUserID.defaultExpectation == nil && mmGetItemsByUserID.mock.funcGetItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.mock.afterGetItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUserID implements mm_controller.ICartUsecase
func (mmGetItemsByUserID *ICartUsecaseMock) GetItemsByUserID(ctx context.Context, userID models.UserID) (l1 usecase.ListItemsDTO, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	mmGetItemsByUserID.t.Helper()

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, userID)
	}

	mm_params := ICartUsecaseMockGetItemsByUserIDParams{ctx, userID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, &mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartUsecaseMockGetItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByUserID.t.Errorf("ICartUsecaseMock.GetItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItemsByUserID.t.Errorf("ICartUsecaseMock.GetItemsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("ICartUsecaseMock.GetItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the ICartUsecaseMock.GetItemsByUserID")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, userID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to ICartUsecaseMock.GetItemsByUserID. %v %v", ctx, userID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished ICartUsecaseMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ICartUsecaseMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of ICartUsecaseMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ICartUsecaseMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartUsecaseMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mICartUsecaseMockGetItemsByUserID) Calls() []*ICartUsecaseMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*ICartUsecaseMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ICartUsecaseMock) MinimockGetItemsByUserIDDone() bool {
	if m.GetItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserIDMock.invocationsDone()
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *ICartUsecaseMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartUsecaseMock.GetItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && afterGetItemsByUserIDCounter < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartUsecaseMock.GetItemsByUserID at\n%s", m.GetItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartUsecaseMock.GetItemsByUserID at\n%s with params: %#v", m.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && afterGetItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartUsecaseMock.GetItemsByUserID at\n%s", m.funcGetItemsByUserIDOrigin)
	}

	if !m.GetItemsByUserIDMock.invocationsDone() && afterGetItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartUsecaseMock.GetItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserIDMock.expectedInvocations), m.GetItemsByUserIDMock.expectedInvocationsOrigin, afterGetItemsByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICartUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockClearCartByUserIDInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetItemsByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICartUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICartUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockClearCartByUserIDDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetItemsByUserIDDone()
}
