// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"cart/internal/producer"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IProducerMock implements mm_usecase.IProducer
type IProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcProduce          func(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time)
	funcProduceOrigin    string
	inspectFuncProduce   func(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time)
	afterProduceCounter  uint64
	beforeProduceCounter uint64
	ProduceMock          mIProducerMockProduce
}

// NewIProducerMock returns a mock for mm_usecase.IProducer
func NewIProducerMock(t minimock.Tester) *IProducerMock {
	m := &IProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ProduceMock = mIProducerMockProduce{mock: m}
	m.ProduceMock.callArgs = []*IProducerMockProduceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIProducerMockProduce struct {
	optional           bool
	mock               *IProducerMock
	defaultExpectation *IProducerMockProduceExpectation
	expectations       []*IProducerMockProduceExpectation

	callArgs []*IProducerMockProduceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IProducerMockProduceExpectation specifies expectation struct of the IProducer.Produce
type IProducerMockProduceExpectation struct {
	mock               *IProducerMock
	params             *IProducerMockProduceParams
	paramPtrs          *IProducerMockProduceParamPtrs
	expectationOrigins IProducerMockProduceExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// IProducerMockProduceParams contains parameters of the IProducer.Produce
type IProducerMockProduceParams struct {
	messsageDTO producer.ProducerMessageDTO
	topic       string
	partionID   int32
	t           time.Time
}

// IProducerMockProduceParamPtrs contains pointers to parameters of the IProducer.Produce
type IProducerMockProduceParamPtrs struct {
	messsageDTO *producer.ProducerMessageDTO
	topic       *string
	partionID   *int32
	t           *time.Time
}

// IProducerMockProduceOrigins contains origins of expectations of the IProducer.Produce
type IProducerMockProduceExpectationOrigins struct {
	origin            string
	originMesssageDTO string
	originTopic       string
	originPartionID   string
	originT           string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProduce *mIProducerMockProduce) Optional() *mIProducerMockProduce {
	mmProduce.optional = true
	return mmProduce
}

// Expect sets up expected params for IProducer.Produce
func (mmProduce *mIProducerMockProduce) Expect(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time) *mIProducerMockProduce {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{}
	}

	if mmProduce.defaultExpectation.paramPtrs != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by ExpectParams functions")
	}

	mmProduce.defaultExpectation.params = &IProducerMockProduceParams{messsageDTO, topic, partionID, t}
	mmProduce.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProduce.expectations {
		if minimock.Equal(e.params, mmProduce.defaultExpectation.params) {
			mmProduce.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProduce.defaultExpectation.params)
		}
	}

	return mmProduce
}

// ExpectMesssageDTOParam1 sets up expected param messsageDTO for IProducer.Produce
func (mmProduce *mIProducerMockProduce) ExpectMesssageDTOParam1(messsageDTO producer.ProducerMessageDTO) *mIProducerMockProduce {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{}
	}

	if mmProduce.defaultExpectation.params != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Expect")
	}

	if mmProduce.defaultExpectation.paramPtrs == nil {
		mmProduce.defaultExpectation.paramPtrs = &IProducerMockProduceParamPtrs{}
	}
	mmProduce.defaultExpectation.paramPtrs.messsageDTO = &messsageDTO
	mmProduce.defaultExpectation.expectationOrigins.originMesssageDTO = minimock.CallerInfo(1)

	return mmProduce
}

// ExpectTopicParam2 sets up expected param topic for IProducer.Produce
func (mmProduce *mIProducerMockProduce) ExpectTopicParam2(topic string) *mIProducerMockProduce {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{}
	}

	if mmProduce.defaultExpectation.params != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Expect")
	}

	if mmProduce.defaultExpectation.paramPtrs == nil {
		mmProduce.defaultExpectation.paramPtrs = &IProducerMockProduceParamPtrs{}
	}
	mmProduce.defaultExpectation.paramPtrs.topic = &topic
	mmProduce.defaultExpectation.expectationOrigins.originTopic = minimock.CallerInfo(1)

	return mmProduce
}

// ExpectPartionIDParam3 sets up expected param partionID for IProducer.Produce
func (mmProduce *mIProducerMockProduce) ExpectPartionIDParam3(partionID int32) *mIProducerMockProduce {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{}
	}

	if mmProduce.defaultExpectation.params != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Expect")
	}

	if mmProduce.defaultExpectation.paramPtrs == nil {
		mmProduce.defaultExpectation.paramPtrs = &IProducerMockProduceParamPtrs{}
	}
	mmProduce.defaultExpectation.paramPtrs.partionID = &partionID
	mmProduce.defaultExpectation.expectationOrigins.originPartionID = minimock.CallerInfo(1)

	return mmProduce
}

// ExpectTParam4 sets up expected param t for IProducer.Produce
func (mmProduce *mIProducerMockProduce) ExpectTParam4(t time.Time) *mIProducerMockProduce {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{}
	}

	if mmProduce.defaultExpectation.params != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Expect")
	}

	if mmProduce.defaultExpectation.paramPtrs == nil {
		mmProduce.defaultExpectation.paramPtrs = &IProducerMockProduceParamPtrs{}
	}
	mmProduce.defaultExpectation.paramPtrs.t = &t
	mmProduce.defaultExpectation.expectationOrigins.originT = minimock.CallerInfo(1)

	return mmProduce
}

// Inspect accepts an inspector function that has same arguments as the IProducer.Produce
func (mmProduce *mIProducerMockProduce) Inspect(f func(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time)) *mIProducerMockProduce {
	if mmProduce.mock.inspectFuncProduce != nil {
		mmProduce.mock.t.Fatalf("Inspect function is already set for IProducerMock.Produce")
	}

	mmProduce.mock.inspectFuncProduce = f

	return mmProduce
}

// Return sets up results that will be returned by IProducer.Produce
func (mmProduce *mIProducerMockProduce) Return() *IProducerMock {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	if mmProduce.defaultExpectation == nil {
		mmProduce.defaultExpectation = &IProducerMockProduceExpectation{mock: mmProduce.mock}
	}

	mmProduce.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProduce.mock
}

// Set uses given function f to mock the IProducer.Produce method
func (mmProduce *mIProducerMockProduce) Set(f func(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time)) *IProducerMock {
	if mmProduce.defaultExpectation != nil {
		mmProduce.mock.t.Fatalf("Default expectation is already set for the IProducer.Produce method")
	}

	if len(mmProduce.expectations) > 0 {
		mmProduce.mock.t.Fatalf("Some expectations are already set for the IProducer.Produce method")
	}

	mmProduce.mock.funcProduce = f
	mmProduce.mock.funcProduceOrigin = minimock.CallerInfo(1)
	return mmProduce.mock
}

// When sets expectation for the IProducer.Produce which will trigger the result defined by the following
// Then helper
func (mmProduce *mIProducerMockProduce) When(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time) *IProducerMockProduceExpectation {
	if mmProduce.mock.funcProduce != nil {
		mmProduce.mock.t.Fatalf("IProducerMock.Produce mock is already set by Set")
	}

	expectation := &IProducerMockProduceExpectation{
		mock:               mmProduce.mock,
		params:             &IProducerMockProduceParams{messsageDTO, topic, partionID, t},
		expectationOrigins: IProducerMockProduceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProduce.expectations = append(mmProduce.expectations, expectation)
	return expectation
}

// Then sets up IProducer.Produce return parameters for the expectation previously defined by the When method

func (e *IProducerMockProduceExpectation) Then() *IProducerMock {
	return e.mock
}

// Times sets number of times IProducer.Produce should be invoked
func (mmProduce *mIProducerMockProduce) Times(n uint64) *mIProducerMockProduce {
	if n == 0 {
		mmProduce.mock.t.Fatalf("Times of IProducerMock.Produce mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProduce.expectedInvocations, n)
	mmProduce.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProduce
}

func (mmProduce *mIProducerMockProduce) invocationsDone() bool {
	if len(mmProduce.expectations) == 0 && mmProduce.defaultExpectation == nil && mmProduce.mock.funcProduce == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProduce.mock.afterProduceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProduce.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Produce implements mm_usecase.IProducer
func (mmProduce *IProducerMock) Produce(messsageDTO producer.ProducerMessageDTO, topic string, partionID int32, t time.Time) {
	mm_atomic.AddUint64(&mmProduce.beforeProduceCounter, 1)
	defer mm_atomic.AddUint64(&mmProduce.afterProduceCounter, 1)

	mmProduce.t.Helper()

	if mmProduce.inspectFuncProduce != nil {
		mmProduce.inspectFuncProduce(messsageDTO, topic, partionID, t)
	}

	mm_params := IProducerMockProduceParams{messsageDTO, topic, partionID, t}

	// Record call args
	mmProduce.ProduceMock.mutex.Lock()
	mmProduce.ProduceMock.callArgs = append(mmProduce.ProduceMock.callArgs, &mm_params)
	mmProduce.ProduceMock.mutex.Unlock()

	for _, e := range mmProduce.ProduceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmProduce.ProduceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProduce.ProduceMock.defaultExpectation.Counter, 1)
		mm_want := mmProduce.ProduceMock.defaultExpectation.params
		mm_want_ptrs := mmProduce.ProduceMock.defaultExpectation.paramPtrs

		mm_got := IProducerMockProduceParams{messsageDTO, topic, partionID, t}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.messsageDTO != nil && !minimock.Equal(*mm_want_ptrs.messsageDTO, mm_got.messsageDTO) {
				mmProduce.t.Errorf("IProducerMock.Produce got unexpected parameter messsageDTO, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProduce.ProduceMock.defaultExpectation.expectationOrigins.originMesssageDTO, *mm_want_ptrs.messsageDTO, mm_got.messsageDTO, minimock.Diff(*mm_want_ptrs.messsageDTO, mm_got.messsageDTO))
			}

			if mm_want_ptrs.topic != nil && !minimock.Equal(*mm_want_ptrs.topic, mm_got.topic) {
				mmProduce.t.Errorf("IProducerMock.Produce got unexpected parameter topic, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProduce.ProduceMock.defaultExpectation.expectationOrigins.originTopic, *mm_want_ptrs.topic, mm_got.topic, minimock.Diff(*mm_want_ptrs.topic, mm_got.topic))
			}

			if mm_want_ptrs.partionID != nil && !minimock.Equal(*mm_want_ptrs.partionID, mm_got.partionID) {
				mmProduce.t.Errorf("IProducerMock.Produce got unexpected parameter partionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProduce.ProduceMock.defaultExpectation.expectationOrigins.originPartionID, *mm_want_ptrs.partionID, mm_got.partionID, minimock.Diff(*mm_want_ptrs.partionID, mm_got.partionID))
			}

			if mm_want_ptrs.t != nil && !minimock.Equal(*mm_want_ptrs.t, mm_got.t) {
				mmProduce.t.Errorf("IProducerMock.Produce got unexpected parameter t, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProduce.ProduceMock.defaultExpectation.expectationOrigins.originT, *mm_want_ptrs.t, mm_got.t, minimock.Diff(*mm_want_ptrs.t, mm_got.t))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProduce.t.Errorf("IProducerMock.Produce got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProduce.ProduceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmProduce.funcProduce != nil {
		mmProduce.funcProduce(messsageDTO, topic, partionID, t)
		return
	}
	mmProduce.t.Fatalf("Unexpected call to IProducerMock.Produce. %v %v %v %v", messsageDTO, topic, partionID, t)

}

// ProduceAfterCounter returns a count of finished IProducerMock.Produce invocations
func (mmProduce *IProducerMock) ProduceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProduce.afterProduceCounter)
}

// ProduceBeforeCounter returns a count of IProducerMock.Produce invocations
func (mmProduce *IProducerMock) ProduceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProduce.beforeProduceCounter)
}

// Calls returns a list of arguments used in each call to IProducerMock.Produce.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProduce *mIProducerMockProduce) Calls() []*IProducerMockProduceParams {
	mmProduce.mutex.RLock()

	argCopy := make([]*IProducerMockProduceParams, len(mmProduce.callArgs))
	copy(argCopy, mmProduce.callArgs)

	mmProduce.mutex.RUnlock()

	return argCopy
}

// MinimockProduceDone returns true if the count of the Produce invocations corresponds
// the number of defined expectations
func (m *IProducerMock) MinimockProduceDone() bool {
	if m.ProduceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProduceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProduceMock.invocationsDone()
}

// MinimockProduceInspect logs each unmet expectation
func (m *IProducerMock) MinimockProduceInspect() {
	for _, e := range m.ProduceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProducerMock.Produce at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProduceCounter := mm_atomic.LoadUint64(&m.afterProduceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProduceMock.defaultExpectation != nil && afterProduceCounter < 1 {
		if m.ProduceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IProducerMock.Produce at\n%s", m.ProduceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IProducerMock.Produce at\n%s with params: %#v", m.ProduceMock.defaultExpectation.expectationOrigins.origin, *m.ProduceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProduce != nil && afterProduceCounter < 1 {
		m.t.Errorf("Expected call to IProducerMock.Produce at\n%s", m.funcProduceOrigin)
	}

	if !m.ProduceMock.invocationsDone() && afterProduceCounter > 0 {
		m.t.Errorf("Expected %d calls to IProducerMock.Produce at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProduceMock.expectedInvocations), m.ProduceMock.expectedInvocationsOrigin, afterProduceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockProduceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockProduceDone()
}
