// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	mm_log "cart/internal/observability/log"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerMock implements mm_log.Logger
type LoggerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg string, fields ...mm_log.Field)
	funcDebugOrigin    string
	inspectFuncDebug   func(msg string, fields ...mm_log.Field)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerMockDebug

	funcDebugf          func(format string, args ...interface{})
	funcDebugfOrigin    string
	inspectFuncDebugf   func(format string, args ...interface{})
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerMockDebugf

	funcError          func(msg string, fields ...mm_log.Field)
	funcErrorOrigin    string
	inspectFuncError   func(msg string, fields ...mm_log.Field)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerMockError

	funcErrorf          func(format string, args ...interface{})
	funcErrorfOrigin    string
	inspectFuncErrorf   func(format string, args ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerMockErrorf

	funcFatal          func(msg string, fields ...mm_log.Field)
	funcFatalOrigin    string
	inspectFuncFatal   func(msg string, fields ...mm_log.Field)
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerMockFatal

	funcFatalf          func(format string, args ...interface{})
	funcFatalfOrigin    string
	inspectFuncFatalf   func(format string, args ...interface{})
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mLoggerMockFatalf

	funcInfo          func(msg string, fields ...mm_log.Field)
	funcInfoOrigin    string
	inspectFuncInfo   func(msg string, fields ...mm_log.Field)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerMockInfo

	funcInfof          func(format string, args ...interface{})
	funcInfofOrigin    string
	inspectFuncInfof   func(format string, args ...interface{})
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerMockInfof

	funcTrace          func(msg string, fields ...mm_log.Field)
	funcTraceOrigin    string
	inspectFuncTrace   func(msg string, fields ...mm_log.Field)
	afterTraceCounter  uint64
	beforeTraceCounter uint64
	TraceMock          mLoggerMockTrace

	funcTracef          func(format string, args ...interface{})
	funcTracefOrigin    string
	inspectFuncTracef   func(format string, args ...interface{})
	afterTracefCounter  uint64
	beforeTracefCounter uint64
	TracefMock          mLoggerMockTracef

	funcWarn          func(msg string, fields ...mm_log.Field)
	funcWarnOrigin    string
	inspectFuncWarn   func(msg string, fields ...mm_log.Field)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerMockWarn

	funcWarnf          func(format string, args ...interface{})
	funcWarnfOrigin    string
	inspectFuncWarnf   func(format string, args ...interface{})
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerMockWarnf
}

// NewLoggerMock returns a mock for mm_log.Logger
func NewLoggerMock(t minimock.Tester) *LoggerMock {
	m := &LoggerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerMockDebugParams{}

	m.DebugfMock = mLoggerMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerMockDebugfParams{}

	m.ErrorMock = mLoggerMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerMockErrorParams{}

	m.ErrorfMock = mLoggerMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerMockErrorfParams{}

	m.FatalMock = mLoggerMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerMockFatalParams{}

	m.FatalfMock = mLoggerMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*LoggerMockFatalfParams{}

	m.InfoMock = mLoggerMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerMockInfoParams{}

	m.InfofMock = mLoggerMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerMockInfofParams{}

	m.TraceMock = mLoggerMockTrace{mock: m}
	m.TraceMock.callArgs = []*LoggerMockTraceParams{}

	m.TracefMock = mLoggerMockTracef{mock: m}
	m.TracefMock.callArgs = []*LoggerMockTracefParams{}

	m.WarnMock = mLoggerMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerMockWarnParams{}

	m.WarnfMock = mLoggerMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerMockDebug struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugExpectation
	expectations       []*LoggerMockDebugExpectation

	callArgs []*LoggerMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugExpectation specifies expectation struct of the Logger.Debug
type LoggerMockDebugExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugParams
	paramPtrs          *LoggerMockDebugParamPtrs
	expectationOrigins LoggerMockDebugExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugParams contains parameters of the Logger.Debug
type LoggerMockDebugParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockDebugParamPtrs contains pointers to parameters of the Logger.Debug
type LoggerMockDebugParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockDebugOrigins contains origins of expectations of the Logger.Debug
type LoggerMockDebugExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerMockDebug) Optional() *mLoggerMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for Logger.Debug
func (mmDebug *mLoggerMockDebug) Expect(msg string, fields ...mm_log.Field) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerMockDebugParams{msg, fields}
	mmDebug.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectMsgParam1(msg string) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg
	mmDebug.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebug
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Debug
func (mmDebug *mLoggerMockDebug) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.fields = &fields
	mmDebug.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debug
func (mmDebug *mLoggerMockDebug) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Logger.Debug
func (mmDebug *mLoggerMockDebug) Return() *LoggerMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerMockDebugExpectation{mock: mmDebug.mock}
	}

	mmDebug.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Set uses given function f to mock the Logger.Debug method
func (mmDebug *mLoggerMockDebug) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Logger.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Logger.Debug method")
	}

	mmDebug.mock.funcDebug = f
	mmDebug.mock.funcDebugOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// When sets expectation for the Logger.Debug which will trigger the result defined by the following
// Then helper
func (mmDebug *mLoggerMockDebug) When(msg string, fields ...mm_log.Field) *LoggerMockDebugExpectation {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerMock.Debug mock is already set by Set")
	}

	expectation := &LoggerMockDebugExpectation{
		mock:               mmDebug.mock,
		params:             &LoggerMockDebugParams{msg, fields},
		expectationOrigins: LoggerMockDebugExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebug.expectations = append(mmDebug.expectations, expectation)
	return expectation
}

// Then sets up Logger.Debug return parameters for the expectation previously defined by the When method

func (e *LoggerMockDebugExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Debug should be invoked
func (mmDebug *mLoggerMockDebug) Times(n uint64) *mLoggerMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	mmDebug.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebug
}

func (mmDebug *mLoggerMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements mm_log.Logger
func (mmDebug *LoggerMock) Debug(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	mmDebug.t.Helper()

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, fields...)
	}

	mm_params := LoggerMockDebugParams{msg, fields}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerMock.Debug got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebug.DebugMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, fields...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerMock.Debug. %v %v", msg, fields)

}

// DebugAfterCounter returns a count of finished LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerMock.Debug invocations
func (mmDebug *LoggerMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerMockDebug) Calls() []*LoggerMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.DebugMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debug at\n%s with params: %#v", m.DebugMock.defaultExpectation.expectationOrigins.origin, *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debug at\n%s", m.funcDebugOrigin)
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debug at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), m.DebugMock.expectedInvocationsOrigin, afterDebugCounter)
	}
}

type mLoggerMockDebugf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockDebugfExpectation
	expectations       []*LoggerMockDebugfExpectation

	callArgs []*LoggerMockDebugfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockDebugfExpectation specifies expectation struct of the Logger.Debugf
type LoggerMockDebugfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockDebugfParams
	paramPtrs          *LoggerMockDebugfParamPtrs
	expectationOrigins LoggerMockDebugfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockDebugfParams contains parameters of the Logger.Debugf
type LoggerMockDebugfParams struct {
	format string
	args   []interface{}
}

// LoggerMockDebugfParamPtrs contains pointers to parameters of the Logger.Debugf
type LoggerMockDebugfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockDebugfOrigins contains origins of expectations of the Logger.Debugf
type LoggerMockDebugfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugf *mLoggerMockDebugf) Optional() *mLoggerMockDebugf {
	mmDebugf.optional = true
	return mmDebugf
}

// Expect sets up expected params for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Expect(format string, args ...interface{}) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.paramPtrs != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by ExpectParams functions")
	}

	mmDebugf.defaultExpectation.params = &LoggerMockDebugfParams{format, args}
	mmDebugf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// ExpectFormatParam1 sets up expected param format for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectFormatParam1(format string) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.format = &format
	mmDebugf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmDebugf
}

// ExpectArgsParam2 sets up expected param args for Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) ExpectArgsParam2(args ...interface{}) *mLoggerMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.args = &args
	mmDebugf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Inspect(f func(format string, args ...interface{})) *mLoggerMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by Logger.Debugf
func (mmDebugf *mLoggerMockDebugf) Return() *LoggerMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerMockDebugfExpectation{mock: mmDebugf.mock}
	}

	mmDebugf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// Set uses given function f to mock the Logger.Debugf method
func (mmDebugf *mLoggerMockDebugf) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the Logger.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the Logger.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	mmDebugf.mock.funcDebugfOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// When sets expectation for the Logger.Debugf which will trigger the result defined by the following
// Then helper
func (mmDebugf *mLoggerMockDebugf) When(format string, args ...interface{}) *LoggerMockDebugfExpectation {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerMock.Debugf mock is already set by Set")
	}

	expectation := &LoggerMockDebugfExpectation{
		mock:               mmDebugf.mock,
		params:             &LoggerMockDebugfParams{format, args},
		expectationOrigins: LoggerMockDebugfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebugf.expectations = append(mmDebugf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Debugf return parameters for the expectation previously defined by the When method

func (e *LoggerMockDebugfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Debugf should be invoked
func (mmDebugf *mLoggerMockDebugf) Times(n uint64) *mLoggerMockDebugf {
	if n == 0 {
		mmDebugf.mock.t.Fatalf("Times of LoggerMock.Debugf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugf.expectedInvocations, n)
	mmDebugf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebugf
}

func (mmDebugf *mLoggerMockDebugf) invocationsDone() bool {
	if len(mmDebugf.expectations) == 0 && mmDebugf.defaultExpectation == nil && mmDebugf.mock.funcDebugf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugf.mock.afterDebugfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debugf implements mm_log.Logger
func (mmDebugf *LoggerMock) Debugf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	mmDebugf.t.Helper()

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(format, args...)
	}

	mm_params := LoggerMockDebugfParams{format, args}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_want_ptrs := mmDebugf.DebugfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockDebugfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerMock.Debugf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(format, args...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerMock.Debugf. %v %v", format, args)

}

// DebugfAfterCounter returns a count of finished LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerMock.Debugf invocations
func (mmDebugf *LoggerMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerMockDebugf) Calls() []*LoggerMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockDebugfDone() bool {
	if m.DebugfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugfMock.invocationsDone()
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugfCounter := mm_atomic.LoadUint64(&m.afterDebugfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && afterDebugfCounter < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s", m.DebugfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s with params: %#v", m.DebugfMock.defaultExpectation.expectationOrigins.origin, *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && afterDebugfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Debugf at\n%s", m.funcDebugfOrigin)
	}

	if !m.DebugfMock.invocationsDone() && afterDebugfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Debugf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugfMock.expectedInvocations), m.DebugfMock.expectedInvocationsOrigin, afterDebugfCounter)
	}
}

type mLoggerMockError struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorExpectation
	expectations       []*LoggerMockErrorExpectation

	callArgs []*LoggerMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorExpectation specifies expectation struct of the Logger.Error
type LoggerMockErrorExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorParams
	paramPtrs          *LoggerMockErrorParamPtrs
	expectationOrigins LoggerMockErrorExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorParams contains parameters of the Logger.Error
type LoggerMockErrorParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockErrorParamPtrs contains pointers to parameters of the Logger.Error
type LoggerMockErrorParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockErrorOrigins contains origins of expectations of the Logger.Error
type LoggerMockErrorExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerMockError) Optional() *mLoggerMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for Logger.Error
func (mmError *mLoggerMockError) Expect(msg string, fields ...mm_log.Field) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerMockErrorParams{msg, fields}
	mmError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for Logger.Error
func (mmError *mLoggerMockError) ExpectMsgParam1(msg string) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg
	mmError.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmError
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Error
func (mmError *mLoggerMockError) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.fields = &fields
	mmError.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Logger.Error
func (mmError *mLoggerMockError) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Logger.Error
func (mmError *mLoggerMockError) Return() *LoggerMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerMockErrorExpectation{mock: mmError.mock}
	}

	mmError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Set uses given function f to mock the Logger.Error method
func (mmError *mLoggerMockError) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Logger.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Logger.Error method")
	}

	mmError.mock.funcError = f
	mmError.mock.funcErrorOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// When sets expectation for the Logger.Error which will trigger the result defined by the following
// Then helper
func (mmError *mLoggerMockError) When(msg string, fields ...mm_log.Field) *LoggerMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerMock.Error mock is already set by Set")
	}

	expectation := &LoggerMockErrorExpectation{
		mock:               mmError.mock,
		params:             &LoggerMockErrorParams{msg, fields},
		expectationOrigins: LoggerMockErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up Logger.Error return parameters for the expectation previously defined by the When method

func (e *LoggerMockErrorExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Error should be invoked
func (mmError *mLoggerMockError) Times(n uint64) *mLoggerMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	mmError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmError
}

func (mmError *mLoggerMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements mm_log.Logger
func (mmError *LoggerMock) Error(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	mmError.t.Helper()

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, fields...)
	}

	mm_params := LoggerMockErrorParams{msg, fields}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmError.t.Errorf("LoggerMock.Error got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerMock.Error got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmError.ErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, fields...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerMock.Error. %v %v", msg, fields)

}

// ErrorAfterCounter returns a count of finished LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerMock.Error invocations
func (mmError *LoggerMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerMockError) Calls() []*LoggerMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.ErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Error at\n%s with params: %#v", m.ErrorMock.defaultExpectation.expectationOrigins.origin, *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Error at\n%s", m.funcErrorOrigin)
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Error at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), m.ErrorMock.expectedInvocationsOrigin, afterErrorCounter)
	}
}

type mLoggerMockErrorf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockErrorfExpectation
	expectations       []*LoggerMockErrorfExpectation

	callArgs []*LoggerMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockErrorfExpectation specifies expectation struct of the Logger.Errorf
type LoggerMockErrorfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockErrorfParams
	paramPtrs          *LoggerMockErrorfParamPtrs
	expectationOrigins LoggerMockErrorfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockErrorfParams contains parameters of the Logger.Errorf
type LoggerMockErrorfParams struct {
	format string
	args   []interface{}
}

// LoggerMockErrorfParamPtrs contains pointers to parameters of the Logger.Errorf
type LoggerMockErrorfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockErrorfOrigins contains origins of expectations of the Logger.Errorf
type LoggerMockErrorfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mLoggerMockErrorf) Optional() *mLoggerMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Expect(format string, args ...interface{}) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &LoggerMockErrorfParams{format, args}
	mmErrorf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectFormatParam1 sets up expected param format for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectFormatParam1(format string) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.format = &format
	mmErrorf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmErrorf
}

// ExpectArgsParam2 sets up expected param args for Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) ExpectArgsParam2(args ...interface{}) *mLoggerMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.args = &args
	mmErrorf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Inspect(f func(format string, args ...interface{})) *mLoggerMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by Logger.Errorf
func (mmErrorf *mLoggerMockErrorf) Return() *LoggerMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerMockErrorfExpectation{mock: mmErrorf.mock}
	}

	mmErrorf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// Set uses given function f to mock the Logger.Errorf method
func (mmErrorf *mLoggerMockErrorf) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the Logger.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the Logger.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	mmErrorf.mock.funcErrorfOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// When sets expectation for the Logger.Errorf which will trigger the result defined by the following
// Then helper
func (mmErrorf *mLoggerMockErrorf) When(format string, args ...interface{}) *LoggerMockErrorfExpectation {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerMock.Errorf mock is already set by Set")
	}

	expectation := &LoggerMockErrorfExpectation{
		mock:               mmErrorf.mock,
		params:             &LoggerMockErrorfParams{format, args},
		expectationOrigins: LoggerMockErrorfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmErrorf.expectations = append(mmErrorf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Errorf return parameters for the expectation previously defined by the When method

func (e *LoggerMockErrorfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Errorf should be invoked
func (mmErrorf *mLoggerMockErrorf) Times(n uint64) *mLoggerMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of LoggerMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	mmErrorf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErrorf
}

func (mmErrorf *mLoggerMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements mm_log.Logger
func (mmErrorf *LoggerMock) Errorf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	mmErrorf.t.Helper()

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(format, args...)
	}

	mm_params := LoggerMockErrorfParams{format, args}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockErrorfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerMock.Errorf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(format, args...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerMock.Errorf. %v %v", format, args)

}

// ErrorfAfterCounter returns a count of finished LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerMock.Errorf invocations
func (mmErrorf *LoggerMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerMockErrorf) Calls() []*LoggerMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s", m.ErrorfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s with params: %#v", m.ErrorfMock.defaultExpectation.expectationOrigins.origin, *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Errorf at\n%s", m.funcErrorfOrigin)
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Errorf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), m.ErrorfMock.expectedInvocationsOrigin, afterErrorfCounter)
	}
}

type mLoggerMockFatal struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalExpectation
	expectations       []*LoggerMockFatalExpectation

	callArgs []*LoggerMockFatalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockFatalExpectation specifies expectation struct of the Logger.Fatal
type LoggerMockFatalExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockFatalParams
	paramPtrs          *LoggerMockFatalParamPtrs
	expectationOrigins LoggerMockFatalExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockFatalParams contains parameters of the Logger.Fatal
type LoggerMockFatalParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockFatalParamPtrs contains pointers to parameters of the Logger.Fatal
type LoggerMockFatalParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockFatalOrigins contains origins of expectations of the Logger.Fatal
type LoggerMockFatalExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatal *mLoggerMockFatal) Optional() *mLoggerMockFatal {
	mmFatal.optional = true
	return mmFatal
}

// Expect sets up expected params for Logger.Fatal
func (mmFatal *mLoggerMockFatal) Expect(msg string, fields ...mm_log.Field) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.paramPtrs != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by ExpectParams functions")
	}

	mmFatal.defaultExpectation.params = &LoggerMockFatalParams{msg, fields}
	mmFatal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// ExpectMsgParam1 sets up expected param msg for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectMsgParam1(msg string) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.msg = &msg
	mmFatal.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmFatal
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Fatal
func (mmFatal *mLoggerMockFatal) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.fields = &fields
	mmFatal.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatal
func (mmFatal *mLoggerMockFatal) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Logger.Fatal
func (mmFatal *mLoggerMockFatal) Return() *LoggerMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerMockFatalExpectation{mock: mmFatal.mock}
	}

	mmFatal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// Set uses given function f to mock the Logger.Fatal method
func (mmFatal *mLoggerMockFatal) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Logger.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Logger.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	mmFatal.mock.funcFatalOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// When sets expectation for the Logger.Fatal which will trigger the result defined by the following
// Then helper
func (mmFatal *mLoggerMockFatal) When(msg string, fields ...mm_log.Field) *LoggerMockFatalExpectation {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerMock.Fatal mock is already set by Set")
	}

	expectation := &LoggerMockFatalExpectation{
		mock:               mmFatal.mock,
		params:             &LoggerMockFatalParams{msg, fields},
		expectationOrigins: LoggerMockFatalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFatal.expectations = append(mmFatal.expectations, expectation)
	return expectation
}

// Then sets up Logger.Fatal return parameters for the expectation previously defined by the When method

func (e *LoggerMockFatalExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Fatal should be invoked
func (mmFatal *mLoggerMockFatal) Times(n uint64) *mLoggerMockFatal {
	if n == 0 {
		mmFatal.mock.t.Fatalf("Times of LoggerMock.Fatal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatal.expectedInvocations, n)
	mmFatal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFatal
}

func (mmFatal *mLoggerMockFatal) invocationsDone() bool {
	if len(mmFatal.expectations) == 0 && mmFatal.defaultExpectation == nil && mmFatal.mock.funcFatal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatal.mock.afterFatalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatal implements mm_log.Logger
func (mmFatal *LoggerMock) Fatal(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	mmFatal.t.Helper()

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(msg, fields...)
	}

	mm_params := LoggerMockFatalParams{msg, fields}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, &mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_want_ptrs := mmFatal.FatalMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockFatalParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("LoggerMock.Fatal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFatal.FatalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(msg, fields...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerMock.Fatal. %v %v", msg, fields)

}

// FatalAfterCounter returns a count of finished LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerMock.Fatal invocations
func (mmFatal *LoggerMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerMockFatal) Calls() []*LoggerMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalDone() bool {
	if m.FatalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalMock.invocationsDone()
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFatalCounter := mm_atomic.LoadUint64(&m.afterFatalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && afterFatalCounter < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s", m.FatalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s with params: %#v", m.FatalMock.defaultExpectation.expectationOrigins.origin, *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && afterFatalCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Fatal at\n%s", m.funcFatalOrigin)
	}

	if !m.FatalMock.invocationsDone() && afterFatalCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Fatal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FatalMock.expectedInvocations), m.FatalMock.expectedInvocationsOrigin, afterFatalCounter)
	}
}

type mLoggerMockFatalf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockFatalfExpectation
	expectations       []*LoggerMockFatalfExpectation

	callArgs []*LoggerMockFatalfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockFatalfExpectation specifies expectation struct of the Logger.Fatalf
type LoggerMockFatalfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockFatalfParams
	paramPtrs          *LoggerMockFatalfParamPtrs
	expectationOrigins LoggerMockFatalfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockFatalfParams contains parameters of the Logger.Fatalf
type LoggerMockFatalfParams struct {
	format string
	args   []interface{}
}

// LoggerMockFatalfParamPtrs contains pointers to parameters of the Logger.Fatalf
type LoggerMockFatalfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockFatalfOrigins contains origins of expectations of the Logger.Fatalf
type LoggerMockFatalfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatalf *mLoggerMockFatalf) Optional() *mLoggerMockFatalf {
	mmFatalf.optional = true
	return mmFatalf
}

// Expect sets up expected params for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Expect(format string, args ...interface{}) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.paramPtrs != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by ExpectParams functions")
	}

	mmFatalf.defaultExpectation.params = &LoggerMockFatalfParams{format, args}
	mmFatalf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// ExpectFormatParam1 sets up expected param format for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) ExpectFormatParam1(format string) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.format = &format
	mmFatalf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmFatalf
}

// ExpectArgsParam2 sets up expected param args for Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) ExpectArgsParam2(args ...interface{}) *mLoggerMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.args = &args
	mmFatalf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Inspect(f func(format string, args ...interface{})) *mLoggerMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by Logger.Fatalf
func (mmFatalf *mLoggerMockFatalf) Return() *LoggerMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerMockFatalfExpectation{mock: mmFatalf.mock}
	}

	mmFatalf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFatalf.mock
}

// Set uses given function f to mock the Logger.Fatalf method
func (mmFatalf *mLoggerMockFatalf) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the Logger.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the Logger.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	mmFatalf.mock.funcFatalfOrigin = minimock.CallerInfo(1)
	return mmFatalf.mock
}

// When sets expectation for the Logger.Fatalf which will trigger the result defined by the following
// Then helper
func (mmFatalf *mLoggerMockFatalf) When(format string, args ...interface{}) *LoggerMockFatalfExpectation {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerMock.Fatalf mock is already set by Set")
	}

	expectation := &LoggerMockFatalfExpectation{
		mock:               mmFatalf.mock,
		params:             &LoggerMockFatalfParams{format, args},
		expectationOrigins: LoggerMockFatalfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFatalf.expectations = append(mmFatalf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Fatalf return parameters for the expectation previously defined by the When method

func (e *LoggerMockFatalfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Fatalf should be invoked
func (mmFatalf *mLoggerMockFatalf) Times(n uint64) *mLoggerMockFatalf {
	if n == 0 {
		mmFatalf.mock.t.Fatalf("Times of LoggerMock.Fatalf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatalf.expectedInvocations, n)
	mmFatalf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFatalf
}

func (mmFatalf *mLoggerMockFatalf) invocationsDone() bool {
	if len(mmFatalf.expectations) == 0 && mmFatalf.defaultExpectation == nil && mmFatalf.mock.funcFatalf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatalf.mock.afterFatalfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatalf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatalf implements mm_log.Logger
func (mmFatalf *LoggerMock) Fatalf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	mmFatalf.t.Helper()

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(format, args...)
	}

	mm_params := LoggerMockFatalfParams{format, args}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, &mm_params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		mm_want := mmFatalf.FatalfMock.defaultExpectation.params
		mm_want_ptrs := mmFatalf.FatalfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockFatalfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatalf.t.Errorf("LoggerMock.Fatalf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(format, args...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to LoggerMock.Fatalf. %v %v", format, args)

}

// FatalfAfterCounter returns a count of finished LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of LoggerMock.Fatalf invocations
func (mmFatalf *LoggerMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mLoggerMockFatalf) Calls() []*LoggerMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*LoggerMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockFatalfDone() bool {
	if m.FatalfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalfMock.invocationsDone()
}

// MinimockFatalfInspect logs each unmet expectation
func (m *LoggerMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Fatalf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFatalfCounter := mm_atomic.LoadUint64(&m.afterFatalfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && afterFatalfCounter < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Fatalf at\n%s", m.FatalfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Fatalf at\n%s with params: %#v", m.FatalfMock.defaultExpectation.expectationOrigins.origin, *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && afterFatalfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Fatalf at\n%s", m.funcFatalfOrigin)
	}

	if !m.FatalfMock.invocationsDone() && afterFatalfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Fatalf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FatalfMock.expectedInvocations), m.FatalfMock.expectedInvocationsOrigin, afterFatalfCounter)
	}
}

type mLoggerMockInfo struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfoExpectation
	expectations       []*LoggerMockInfoExpectation

	callArgs []*LoggerMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfoExpectation specifies expectation struct of the Logger.Info
type LoggerMockInfoExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfoParams
	paramPtrs          *LoggerMockInfoParamPtrs
	expectationOrigins LoggerMockInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfoParams contains parameters of the Logger.Info
type LoggerMockInfoParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockInfoParamPtrs contains pointers to parameters of the Logger.Info
type LoggerMockInfoParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockInfoOrigins contains origins of expectations of the Logger.Info
type LoggerMockInfoExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerMockInfo) Optional() *mLoggerMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for Logger.Info
func (mmInfo *mLoggerMockInfo) Expect(msg string, fields ...mm_log.Field) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerMockInfoParams{msg, fields}
	mmInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectMsgParam1(msg string) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg
	mmInfo.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfo
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Info
func (mmInfo *mLoggerMockInfo) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.fields = &fields
	mmInfo.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Logger.Info
func (mmInfo *mLoggerMockInfo) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Logger.Info
func (mmInfo *mLoggerMockInfo) Return() *LoggerMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerMockInfoExpectation{mock: mmInfo.mock}
	}

	mmInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Set uses given function f to mock the Logger.Info method
func (mmInfo *mLoggerMockInfo) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Logger.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Logger.Info method")
	}

	mmInfo.mock.funcInfo = f
	mmInfo.mock.funcInfoOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// When sets expectation for the Logger.Info which will trigger the result defined by the following
// Then helper
func (mmInfo *mLoggerMockInfo) When(msg string, fields ...mm_log.Field) *LoggerMockInfoExpectation {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerMock.Info mock is already set by Set")
	}

	expectation := &LoggerMockInfoExpectation{
		mock:               mmInfo.mock,
		params:             &LoggerMockInfoParams{msg, fields},
		expectationOrigins: LoggerMockInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfo.expectations = append(mmInfo.expectations, expectation)
	return expectation
}

// Then sets up Logger.Info return parameters for the expectation previously defined by the When method

func (e *LoggerMockInfoExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Info should be invoked
func (mmInfo *mLoggerMockInfo) Times(n uint64) *mLoggerMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	mmInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfo
}

func (mmInfo *mLoggerMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements mm_log.Logger
func (mmInfo *LoggerMock) Info(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	mmInfo.t.Helper()

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, fields...)
	}

	mm_params := LoggerMockInfoParams{msg, fields}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfoParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmInfo.t.Errorf("LoggerMock.Info got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerMock.Info got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfo.InfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, fields...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerMock.Info. %v %v", msg, fields)

}

// InfoAfterCounter returns a count of finished LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerMock.Info invocations
func (mmInfo *LoggerMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerMockInfo) Calls() []*LoggerMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.InfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Info at\n%s with params: %#v", m.InfoMock.defaultExpectation.expectationOrigins.origin, *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Info at\n%s", m.funcInfoOrigin)
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Info at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), m.InfoMock.expectedInvocationsOrigin, afterInfoCounter)
	}
}

type mLoggerMockInfof struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockInfofExpectation
	expectations       []*LoggerMockInfofExpectation

	callArgs []*LoggerMockInfofParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockInfofExpectation specifies expectation struct of the Logger.Infof
type LoggerMockInfofExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockInfofParams
	paramPtrs          *LoggerMockInfofParamPtrs
	expectationOrigins LoggerMockInfofExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockInfofParams contains parameters of the Logger.Infof
type LoggerMockInfofParams struct {
	format string
	args   []interface{}
}

// LoggerMockInfofParamPtrs contains pointers to parameters of the Logger.Infof
type LoggerMockInfofParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockInfofOrigins contains origins of expectations of the Logger.Infof
type LoggerMockInfofExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfof *mLoggerMockInfof) Optional() *mLoggerMockInfof {
	mmInfof.optional = true
	return mmInfof
}

// Expect sets up expected params for Logger.Infof
func (mmInfof *mLoggerMockInfof) Expect(format string, args ...interface{}) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.paramPtrs != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by ExpectParams functions")
	}

	mmInfof.defaultExpectation.params = &LoggerMockInfofParams{format, args}
	mmInfof.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// ExpectFormatParam1 sets up expected param format for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectFormatParam1(format string) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.format = &format
	mmInfof.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmInfof
}

// ExpectArgsParam2 sets up expected param args for Logger.Infof
func (mmInfof *mLoggerMockInfof) ExpectArgsParam2(args ...interface{}) *mLoggerMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.args = &args
	mmInfof.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the Logger.Infof
func (mmInfof *mLoggerMockInfof) Inspect(f func(format string, args ...interface{})) *mLoggerMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by Logger.Infof
func (mmInfof *mLoggerMockInfof) Return() *LoggerMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerMockInfofExpectation{mock: mmInfof.mock}
	}

	mmInfof.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// Set uses given function f to mock the Logger.Infof method
func (mmInfof *mLoggerMockInfof) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the Logger.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the Logger.Infof method")
	}

	mmInfof.mock.funcInfof = f
	mmInfof.mock.funcInfofOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// When sets expectation for the Logger.Infof which will trigger the result defined by the following
// Then helper
func (mmInfof *mLoggerMockInfof) When(format string, args ...interface{}) *LoggerMockInfofExpectation {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerMock.Infof mock is already set by Set")
	}

	expectation := &LoggerMockInfofExpectation{
		mock:               mmInfof.mock,
		params:             &LoggerMockInfofParams{format, args},
		expectationOrigins: LoggerMockInfofExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfof.expectations = append(mmInfof.expectations, expectation)
	return expectation
}

// Then sets up Logger.Infof return parameters for the expectation previously defined by the When method

func (e *LoggerMockInfofExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Infof should be invoked
func (mmInfof *mLoggerMockInfof) Times(n uint64) *mLoggerMockInfof {
	if n == 0 {
		mmInfof.mock.t.Fatalf("Times of LoggerMock.Infof mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfof.expectedInvocations, n)
	mmInfof.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfof
}

func (mmInfof *mLoggerMockInfof) invocationsDone() bool {
	if len(mmInfof.expectations) == 0 && mmInfof.defaultExpectation == nil && mmInfof.mock.funcInfof == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfof.mock.afterInfofCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfof.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Infof implements mm_log.Logger
func (mmInfof *LoggerMock) Infof(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	mmInfof.t.Helper()

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(format, args...)
	}

	mm_params := LoggerMockInfofParams{format, args}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_want_ptrs := mmInfof.InfofMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockInfofParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerMock.Infof got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfof.InfofMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(format, args...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerMock.Infof. %v %v", format, args)

}

// InfofAfterCounter returns a count of finished LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerMock.Infof invocations
func (mmInfof *LoggerMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerMockInfof) Calls() []*LoggerMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockInfofDone() bool {
	if m.InfofMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfofMock.invocationsDone()
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfofCounter := mm_atomic.LoadUint64(&m.afterInfofCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && afterInfofCounter < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s", m.InfofMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Infof at\n%s with params: %#v", m.InfofMock.defaultExpectation.expectationOrigins.origin, *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && afterInfofCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Infof at\n%s", m.funcInfofOrigin)
	}

	if !m.InfofMock.invocationsDone() && afterInfofCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Infof at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfofMock.expectedInvocations), m.InfofMock.expectedInvocationsOrigin, afterInfofCounter)
	}
}

type mLoggerMockTrace struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockTraceExpectation
	expectations       []*LoggerMockTraceExpectation

	callArgs []*LoggerMockTraceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockTraceExpectation specifies expectation struct of the Logger.Trace
type LoggerMockTraceExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockTraceParams
	paramPtrs          *LoggerMockTraceParamPtrs
	expectationOrigins LoggerMockTraceExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockTraceParams contains parameters of the Logger.Trace
type LoggerMockTraceParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockTraceParamPtrs contains pointers to parameters of the Logger.Trace
type LoggerMockTraceParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockTraceOrigins contains origins of expectations of the Logger.Trace
type LoggerMockTraceExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTrace *mLoggerMockTrace) Optional() *mLoggerMockTrace {
	mmTrace.optional = true
	return mmTrace
}

// Expect sets up expected params for Logger.Trace
func (mmTrace *mLoggerMockTrace) Expect(msg string, fields ...mm_log.Field) *mLoggerMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.paramPtrs != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by ExpectParams functions")
	}

	mmTrace.defaultExpectation.params = &LoggerMockTraceParams{msg, fields}
	mmTrace.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTrace.expectations {
		if minimock.Equal(e.params, mmTrace.defaultExpectation.params) {
			mmTrace.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTrace.defaultExpectation.params)
		}
	}

	return mmTrace
}

// ExpectMsgParam1 sets up expected param msg for Logger.Trace
func (mmTrace *mLoggerMockTrace) ExpectMsgParam1(msg string) *mLoggerMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.params != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Expect")
	}

	if mmTrace.defaultExpectation.paramPtrs == nil {
		mmTrace.defaultExpectation.paramPtrs = &LoggerMockTraceParamPtrs{}
	}
	mmTrace.defaultExpectation.paramPtrs.msg = &msg
	mmTrace.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmTrace
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Trace
func (mmTrace *mLoggerMockTrace) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.params != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Expect")
	}

	if mmTrace.defaultExpectation.paramPtrs == nil {
		mmTrace.defaultExpectation.paramPtrs = &LoggerMockTraceParamPtrs{}
	}
	mmTrace.defaultExpectation.paramPtrs.fields = &fields
	mmTrace.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmTrace
}

// Inspect accepts an inspector function that has same arguments as the Logger.Trace
func (mmTrace *mLoggerMockTrace) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockTrace {
	if mmTrace.mock.inspectFuncTrace != nil {
		mmTrace.mock.t.Fatalf("Inspect function is already set for LoggerMock.Trace")
	}

	mmTrace.mock.inspectFuncTrace = f

	return mmTrace
}

// Return sets up results that will be returned by Logger.Trace
func (mmTrace *mLoggerMockTrace) Return() *LoggerMock {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerMockTraceExpectation{mock: mmTrace.mock}
	}

	mmTrace.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTrace.mock
}

// Set uses given function f to mock the Logger.Trace method
func (mmTrace *mLoggerMockTrace) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmTrace.defaultExpectation != nil {
		mmTrace.mock.t.Fatalf("Default expectation is already set for the Logger.Trace method")
	}

	if len(mmTrace.expectations) > 0 {
		mmTrace.mock.t.Fatalf("Some expectations are already set for the Logger.Trace method")
	}

	mmTrace.mock.funcTrace = f
	mmTrace.mock.funcTraceOrigin = minimock.CallerInfo(1)
	return mmTrace.mock
}

// When sets expectation for the Logger.Trace which will trigger the result defined by the following
// Then helper
func (mmTrace *mLoggerMockTrace) When(msg string, fields ...mm_log.Field) *LoggerMockTraceExpectation {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerMock.Trace mock is already set by Set")
	}

	expectation := &LoggerMockTraceExpectation{
		mock:               mmTrace.mock,
		params:             &LoggerMockTraceParams{msg, fields},
		expectationOrigins: LoggerMockTraceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTrace.expectations = append(mmTrace.expectations, expectation)
	return expectation
}

// Then sets up Logger.Trace return parameters for the expectation previously defined by the When method

func (e *LoggerMockTraceExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Trace should be invoked
func (mmTrace *mLoggerMockTrace) Times(n uint64) *mLoggerMockTrace {
	if n == 0 {
		mmTrace.mock.t.Fatalf("Times of LoggerMock.Trace mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTrace.expectedInvocations, n)
	mmTrace.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTrace
}

func (mmTrace *mLoggerMockTrace) invocationsDone() bool {
	if len(mmTrace.expectations) == 0 && mmTrace.defaultExpectation == nil && mmTrace.mock.funcTrace == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTrace.mock.afterTraceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTrace.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Trace implements mm_log.Logger
func (mmTrace *LoggerMock) Trace(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmTrace.beforeTraceCounter, 1)
	defer mm_atomic.AddUint64(&mmTrace.afterTraceCounter, 1)

	mmTrace.t.Helper()

	if mmTrace.inspectFuncTrace != nil {
		mmTrace.inspectFuncTrace(msg, fields...)
	}

	mm_params := LoggerMockTraceParams{msg, fields}

	// Record call args
	mmTrace.TraceMock.mutex.Lock()
	mmTrace.TraceMock.callArgs = append(mmTrace.TraceMock.callArgs, &mm_params)
	mmTrace.TraceMock.mutex.Unlock()

	for _, e := range mmTrace.TraceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTrace.TraceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTrace.TraceMock.defaultExpectation.Counter, 1)
		mm_want := mmTrace.TraceMock.defaultExpectation.params
		mm_want_ptrs := mmTrace.TraceMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockTraceParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmTrace.t.Errorf("LoggerMock.Trace got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTrace.TraceMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmTrace.t.Errorf("LoggerMock.Trace got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTrace.TraceMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTrace.t.Errorf("LoggerMock.Trace got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTrace.TraceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTrace.funcTrace != nil {
		mmTrace.funcTrace(msg, fields...)
		return
	}
	mmTrace.t.Fatalf("Unexpected call to LoggerMock.Trace. %v %v", msg, fields)

}

// TraceAfterCounter returns a count of finished LoggerMock.Trace invocations
func (mmTrace *LoggerMock) TraceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrace.afterTraceCounter)
}

// TraceBeforeCounter returns a count of LoggerMock.Trace invocations
func (mmTrace *LoggerMock) TraceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrace.beforeTraceCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Trace.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTrace *mLoggerMockTrace) Calls() []*LoggerMockTraceParams {
	mmTrace.mutex.RLock()

	argCopy := make([]*LoggerMockTraceParams, len(mmTrace.callArgs))
	copy(argCopy, mmTrace.callArgs)

	mmTrace.mutex.RUnlock()

	return argCopy
}

// MinimockTraceDone returns true if the count of the Trace invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockTraceDone() bool {
	if m.TraceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TraceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TraceMock.invocationsDone()
}

// MinimockTraceInspect logs each unmet expectation
func (m *LoggerMock) MinimockTraceInspect() {
	for _, e := range m.TraceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Trace at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTraceCounter := mm_atomic.LoadUint64(&m.afterTraceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TraceMock.defaultExpectation != nil && afterTraceCounter < 1 {
		if m.TraceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Trace at\n%s", m.TraceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Trace at\n%s with params: %#v", m.TraceMock.defaultExpectation.expectationOrigins.origin, *m.TraceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrace != nil && afterTraceCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Trace at\n%s", m.funcTraceOrigin)
	}

	if !m.TraceMock.invocationsDone() && afterTraceCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Trace at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TraceMock.expectedInvocations), m.TraceMock.expectedInvocationsOrigin, afterTraceCounter)
	}
}

type mLoggerMockTracef struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockTracefExpectation
	expectations       []*LoggerMockTracefExpectation

	callArgs []*LoggerMockTracefParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockTracefExpectation specifies expectation struct of the Logger.Tracef
type LoggerMockTracefExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockTracefParams
	paramPtrs          *LoggerMockTracefParamPtrs
	expectationOrigins LoggerMockTracefExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockTracefParams contains parameters of the Logger.Tracef
type LoggerMockTracefParams struct {
	format string
	args   []interface{}
}

// LoggerMockTracefParamPtrs contains pointers to parameters of the Logger.Tracef
type LoggerMockTracefParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockTracefOrigins contains origins of expectations of the Logger.Tracef
type LoggerMockTracefExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTracef *mLoggerMockTracef) Optional() *mLoggerMockTracef {
	mmTracef.optional = true
	return mmTracef
}

// Expect sets up expected params for Logger.Tracef
func (mmTracef *mLoggerMockTracef) Expect(format string, args ...interface{}) *mLoggerMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.paramPtrs != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by ExpectParams functions")
	}

	mmTracef.defaultExpectation.params = &LoggerMockTracefParams{format, args}
	mmTracef.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTracef.expectations {
		if minimock.Equal(e.params, mmTracef.defaultExpectation.params) {
			mmTracef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTracef.defaultExpectation.params)
		}
	}

	return mmTracef
}

// ExpectFormatParam1 sets up expected param format for Logger.Tracef
func (mmTracef *mLoggerMockTracef) ExpectFormatParam1(format string) *mLoggerMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.params != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Expect")
	}

	if mmTracef.defaultExpectation.paramPtrs == nil {
		mmTracef.defaultExpectation.paramPtrs = &LoggerMockTracefParamPtrs{}
	}
	mmTracef.defaultExpectation.paramPtrs.format = &format
	mmTracef.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmTracef
}

// ExpectArgsParam2 sets up expected param args for Logger.Tracef
func (mmTracef *mLoggerMockTracef) ExpectArgsParam2(args ...interface{}) *mLoggerMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.params != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Expect")
	}

	if mmTracef.defaultExpectation.paramPtrs == nil {
		mmTracef.defaultExpectation.paramPtrs = &LoggerMockTracefParamPtrs{}
	}
	mmTracef.defaultExpectation.paramPtrs.args = &args
	mmTracef.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmTracef
}

// Inspect accepts an inspector function that has same arguments as the Logger.Tracef
func (mmTracef *mLoggerMockTracef) Inspect(f func(format string, args ...interface{})) *mLoggerMockTracef {
	if mmTracef.mock.inspectFuncTracef != nil {
		mmTracef.mock.t.Fatalf("Inspect function is already set for LoggerMock.Tracef")
	}

	mmTracef.mock.inspectFuncTracef = f

	return mmTracef
}

// Return sets up results that will be returned by Logger.Tracef
func (mmTracef *mLoggerMockTracef) Return() *LoggerMock {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerMockTracefExpectation{mock: mmTracef.mock}
	}

	mmTracef.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTracef.mock
}

// Set uses given function f to mock the Logger.Tracef method
func (mmTracef *mLoggerMockTracef) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmTracef.defaultExpectation != nil {
		mmTracef.mock.t.Fatalf("Default expectation is already set for the Logger.Tracef method")
	}

	if len(mmTracef.expectations) > 0 {
		mmTracef.mock.t.Fatalf("Some expectations are already set for the Logger.Tracef method")
	}

	mmTracef.mock.funcTracef = f
	mmTracef.mock.funcTracefOrigin = minimock.CallerInfo(1)
	return mmTracef.mock
}

// When sets expectation for the Logger.Tracef which will trigger the result defined by the following
// Then helper
func (mmTracef *mLoggerMockTracef) When(format string, args ...interface{}) *LoggerMockTracefExpectation {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerMock.Tracef mock is already set by Set")
	}

	expectation := &LoggerMockTracefExpectation{
		mock:               mmTracef.mock,
		params:             &LoggerMockTracefParams{format, args},
		expectationOrigins: LoggerMockTracefExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTracef.expectations = append(mmTracef.expectations, expectation)
	return expectation
}

// Then sets up Logger.Tracef return parameters for the expectation previously defined by the When method

func (e *LoggerMockTracefExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Tracef should be invoked
func (mmTracef *mLoggerMockTracef) Times(n uint64) *mLoggerMockTracef {
	if n == 0 {
		mmTracef.mock.t.Fatalf("Times of LoggerMock.Tracef mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTracef.expectedInvocations, n)
	mmTracef.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTracef
}

func (mmTracef *mLoggerMockTracef) invocationsDone() bool {
	if len(mmTracef.expectations) == 0 && mmTracef.defaultExpectation == nil && mmTracef.mock.funcTracef == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTracef.mock.afterTracefCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTracef.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Tracef implements mm_log.Logger
func (mmTracef *LoggerMock) Tracef(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmTracef.beforeTracefCounter, 1)
	defer mm_atomic.AddUint64(&mmTracef.afterTracefCounter, 1)

	mmTracef.t.Helper()

	if mmTracef.inspectFuncTracef != nil {
		mmTracef.inspectFuncTracef(format, args...)
	}

	mm_params := LoggerMockTracefParams{format, args}

	// Record call args
	mmTracef.TracefMock.mutex.Lock()
	mmTracef.TracefMock.callArgs = append(mmTracef.TracefMock.callArgs, &mm_params)
	mmTracef.TracefMock.mutex.Unlock()

	for _, e := range mmTracef.TracefMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTracef.TracefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTracef.TracefMock.defaultExpectation.Counter, 1)
		mm_want := mmTracef.TracefMock.defaultExpectation.params
		mm_want_ptrs := mmTracef.TracefMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockTracefParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmTracef.t.Errorf("LoggerMock.Tracef got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTracef.TracefMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmTracef.t.Errorf("LoggerMock.Tracef got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTracef.TracefMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTracef.t.Errorf("LoggerMock.Tracef got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTracef.TracefMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTracef.funcTracef != nil {
		mmTracef.funcTracef(format, args...)
		return
	}
	mmTracef.t.Fatalf("Unexpected call to LoggerMock.Tracef. %v %v", format, args)

}

// TracefAfterCounter returns a count of finished LoggerMock.Tracef invocations
func (mmTracef *LoggerMock) TracefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracef.afterTracefCounter)
}

// TracefBeforeCounter returns a count of LoggerMock.Tracef invocations
func (mmTracef *LoggerMock) TracefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracef.beforeTracefCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Tracef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTracef *mLoggerMockTracef) Calls() []*LoggerMockTracefParams {
	mmTracef.mutex.RLock()

	argCopy := make([]*LoggerMockTracefParams, len(mmTracef.callArgs))
	copy(argCopy, mmTracef.callArgs)

	mmTracef.mutex.RUnlock()

	return argCopy
}

// MinimockTracefDone returns true if the count of the Tracef invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockTracefDone() bool {
	if m.TracefMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TracefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TracefMock.invocationsDone()
}

// MinimockTracefInspect logs each unmet expectation
func (m *LoggerMock) MinimockTracefInspect() {
	for _, e := range m.TracefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Tracef at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTracefCounter := mm_atomic.LoadUint64(&m.afterTracefCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TracefMock.defaultExpectation != nil && afterTracefCounter < 1 {
		if m.TracefMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Tracef at\n%s", m.TracefMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Tracef at\n%s with params: %#v", m.TracefMock.defaultExpectation.expectationOrigins.origin, *m.TracefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracef != nil && afterTracefCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Tracef at\n%s", m.funcTracefOrigin)
	}

	if !m.TracefMock.invocationsDone() && afterTracefCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Tracef at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TracefMock.expectedInvocations), m.TracefMock.expectedInvocationsOrigin, afterTracefCounter)
	}
}

type mLoggerMockWarn struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnExpectation
	expectations       []*LoggerMockWarnExpectation

	callArgs []*LoggerMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnExpectation specifies expectation struct of the Logger.Warn
type LoggerMockWarnExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnParams
	paramPtrs          *LoggerMockWarnParamPtrs
	expectationOrigins LoggerMockWarnExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnParams contains parameters of the Logger.Warn
type LoggerMockWarnParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerMockWarnParamPtrs contains pointers to parameters of the Logger.Warn
type LoggerMockWarnParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerMockWarnOrigins contains origins of expectations of the Logger.Warn
type LoggerMockWarnExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerMockWarn) Optional() *mLoggerMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for Logger.Warn
func (mmWarn *mLoggerMockWarn) Expect(msg string, fields ...mm_log.Field) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerMockWarnParams{msg, fields}
	mmWarn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectMsgParam1(msg string) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg
	mmWarn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarn
}

// ExpectFieldsParam2 sets up expected param fields for Logger.Warn
func (mmWarn *mLoggerMockWarn) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.fields = &fields
	mmWarn.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warn
func (mmWarn *mLoggerMockWarn) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Logger.Warn
func (mmWarn *mLoggerMockWarn) Return() *LoggerMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerMockWarnExpectation{mock: mmWarn.mock}
	}

	mmWarn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Set uses given function f to mock the Logger.Warn method
func (mmWarn *mLoggerMockWarn) Set(f func(msg string, fields ...mm_log.Field)) *LoggerMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Logger.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Logger.Warn method")
	}

	mmWarn.mock.funcWarn = f
	mmWarn.mock.funcWarnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// When sets expectation for the Logger.Warn which will trigger the result defined by the following
// Then helper
func (mmWarn *mLoggerMockWarn) When(msg string, fields ...mm_log.Field) *LoggerMockWarnExpectation {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerMock.Warn mock is already set by Set")
	}

	expectation := &LoggerMockWarnExpectation{
		mock:               mmWarn.mock,
		params:             &LoggerMockWarnParams{msg, fields},
		expectationOrigins: LoggerMockWarnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarn.expectations = append(mmWarn.expectations, expectation)
	return expectation
}

// Then sets up Logger.Warn return parameters for the expectation previously defined by the When method

func (e *LoggerMockWarnExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Warn should be invoked
func (mmWarn *mLoggerMockWarn) Times(n uint64) *mLoggerMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	mmWarn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarn
}

func (mmWarn *mLoggerMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements mm_log.Logger
func (mmWarn *LoggerMock) Warn(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	mmWarn.t.Helper()

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, fields...)
	}

	mm_params := LoggerMockWarnParams{msg, fields}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerMock.Warn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarn.WarnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, fields...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerMock.Warn. %v %v", msg, fields)

}

// WarnAfterCounter returns a count of finished LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerMock.Warn invocations
func (mmWarn *LoggerMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerMockWarn) Calls() []*LoggerMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.WarnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warn at\n%s with params: %#v", m.WarnMock.defaultExpectation.expectationOrigins.origin, *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warn at\n%s", m.funcWarnOrigin)
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), m.WarnMock.expectedInvocationsOrigin, afterWarnCounter)
	}
}

type mLoggerMockWarnf struct {
	optional           bool
	mock               *LoggerMock
	defaultExpectation *LoggerMockWarnfExpectation
	expectations       []*LoggerMockWarnfExpectation

	callArgs []*LoggerMockWarnfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerMockWarnfExpectation specifies expectation struct of the Logger.Warnf
type LoggerMockWarnfExpectation struct {
	mock               *LoggerMock
	params             *LoggerMockWarnfParams
	paramPtrs          *LoggerMockWarnfParamPtrs
	expectationOrigins LoggerMockWarnfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerMockWarnfParams contains parameters of the Logger.Warnf
type LoggerMockWarnfParams struct {
	format string
	args   []interface{}
}

// LoggerMockWarnfParamPtrs contains pointers to parameters of the Logger.Warnf
type LoggerMockWarnfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerMockWarnfOrigins contains origins of expectations of the Logger.Warnf
type LoggerMockWarnfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnf *mLoggerMockWarnf) Optional() *mLoggerMockWarnf {
	mmWarnf.optional = true
	return mmWarnf
}

// Expect sets up expected params for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Expect(format string, args ...interface{}) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.paramPtrs != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by ExpectParams functions")
	}

	mmWarnf.defaultExpectation.params = &LoggerMockWarnfParams{format, args}
	mmWarnf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// ExpectFormatParam1 sets up expected param format for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectFormatParam1(format string) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.format = &format
	mmWarnf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmWarnf
}

// ExpectArgsParam2 sets up expected param args for Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) ExpectArgsParam2(args ...interface{}) *mLoggerMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.args = &args
	mmWarnf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Inspect(f func(format string, args ...interface{})) *mLoggerMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by Logger.Warnf
func (mmWarnf *mLoggerMockWarnf) Return() *LoggerMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerMockWarnfExpectation{mock: mmWarnf.mock}
	}

	mmWarnf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// Set uses given function f to mock the Logger.Warnf method
func (mmWarnf *mLoggerMockWarnf) Set(f func(format string, args ...interface{})) *LoggerMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the Logger.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the Logger.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	mmWarnf.mock.funcWarnfOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// When sets expectation for the Logger.Warnf which will trigger the result defined by the following
// Then helper
func (mmWarnf *mLoggerMockWarnf) When(format string, args ...interface{}) *LoggerMockWarnfExpectation {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerMock.Warnf mock is already set by Set")
	}

	expectation := &LoggerMockWarnfExpectation{
		mock:               mmWarnf.mock,
		params:             &LoggerMockWarnfParams{format, args},
		expectationOrigins: LoggerMockWarnfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarnf.expectations = append(mmWarnf.expectations, expectation)
	return expectation
}

// Then sets up Logger.Warnf return parameters for the expectation previously defined by the When method

func (e *LoggerMockWarnfExpectation) Then() *LoggerMock {
	return e.mock
}

// Times sets number of times Logger.Warnf should be invoked
func (mmWarnf *mLoggerMockWarnf) Times(n uint64) *mLoggerMockWarnf {
	if n == 0 {
		mmWarnf.mock.t.Fatalf("Times of LoggerMock.Warnf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnf.expectedInvocations, n)
	mmWarnf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarnf
}

func (mmWarnf *mLoggerMockWarnf) invocationsDone() bool {
	if len(mmWarnf.expectations) == 0 && mmWarnf.defaultExpectation == nil && mmWarnf.mock.funcWarnf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnf.mock.afterWarnfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warnf implements mm_log.Logger
func (mmWarnf *LoggerMock) Warnf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	mmWarnf.t.Helper()

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(format, args...)
	}

	mm_params := LoggerMockWarnfParams{format, args}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_want_ptrs := mmWarnf.WarnfMock.defaultExpectation.paramPtrs

		mm_got := LoggerMockWarnfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerMock.Warnf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(format, args...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerMock.Warnf. %v %v", format, args)

}

// WarnfAfterCounter returns a count of finished LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerMock.Warnf invocations
func (mmWarnf *LoggerMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerMockWarnf) Calls() []*LoggerMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerMock) MinimockWarnfDone() bool {
	if m.WarnfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnfMock.invocationsDone()
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnfCounter := mm_atomic.LoadUint64(&m.afterWarnfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && afterWarnfCounter < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s", m.WarnfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s with params: %#v", m.WarnfMock.defaultExpectation.expectationOrigins.origin, *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && afterWarnfCounter < 1 {
		m.t.Errorf("Expected call to LoggerMock.Warnf at\n%s", m.funcWarnfOrigin)
	}

	if !m.WarnfMock.invocationsDone() && afterWarnfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerMock.Warnf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnfMock.expectedInvocations), m.WarnfMock.expectedInvocationsOrigin, afterWarnfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockDebugfInspect()

			m.MinimockErrorInspect()

			m.MinimockErrorfInspect()

			m.MinimockFatalInspect()

			m.MinimockFatalfInspect()

			m.MinimockInfoInspect()

			m.MinimockInfofInspect()

			m.MinimockTraceInspect()

			m.MinimockTracefInspect()

			m.MinimockWarnInspect()

			m.MinimockWarnfInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockFatalDone() &&
		m.MinimockFatalfDone() &&
		m.MinimockInfoDone() &&
		m.MinimockInfofDone() &&
		m.MinimockTraceDone() &&
		m.MinimockTracefDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWarnfDone()
}
