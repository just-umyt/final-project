// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	mm_log "cart/internal/observability/log"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerStructuredMock implements mm_log.LoggerStructured
type LoggerStructuredMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebug          func(msg string, fields ...mm_log.Field)
	funcDebugOrigin    string
	inspectFuncDebug   func(msg string, fields ...mm_log.Field)
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mLoggerStructuredMockDebug

	funcError          func(msg string, fields ...mm_log.Field)
	funcErrorOrigin    string
	inspectFuncError   func(msg string, fields ...mm_log.Field)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mLoggerStructuredMockError

	funcFatal          func(msg string, fields ...mm_log.Field)
	funcFatalOrigin    string
	inspectFuncFatal   func(msg string, fields ...mm_log.Field)
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mLoggerStructuredMockFatal

	funcInfo          func(msg string, fields ...mm_log.Field)
	funcInfoOrigin    string
	inspectFuncInfo   func(msg string, fields ...mm_log.Field)
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mLoggerStructuredMockInfo

	funcTrace          func(msg string, fields ...mm_log.Field)
	funcTraceOrigin    string
	inspectFuncTrace   func(msg string, fields ...mm_log.Field)
	afterTraceCounter  uint64
	beforeTraceCounter uint64
	TraceMock          mLoggerStructuredMockTrace

	funcWarn          func(msg string, fields ...mm_log.Field)
	funcWarnOrigin    string
	inspectFuncWarn   func(msg string, fields ...mm_log.Field)
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mLoggerStructuredMockWarn
}

// NewLoggerStructuredMock returns a mock for mm_log.LoggerStructured
func NewLoggerStructuredMock(t minimock.Tester) *LoggerStructuredMock {
	m := &LoggerStructuredMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mLoggerStructuredMockDebug{mock: m}
	m.DebugMock.callArgs = []*LoggerStructuredMockDebugParams{}

	m.ErrorMock = mLoggerStructuredMockError{mock: m}
	m.ErrorMock.callArgs = []*LoggerStructuredMockErrorParams{}

	m.FatalMock = mLoggerStructuredMockFatal{mock: m}
	m.FatalMock.callArgs = []*LoggerStructuredMockFatalParams{}

	m.InfoMock = mLoggerStructuredMockInfo{mock: m}
	m.InfoMock.callArgs = []*LoggerStructuredMockInfoParams{}

	m.TraceMock = mLoggerStructuredMockTrace{mock: m}
	m.TraceMock.callArgs = []*LoggerStructuredMockTraceParams{}

	m.WarnMock = mLoggerStructuredMockWarn{mock: m}
	m.WarnMock.callArgs = []*LoggerStructuredMockWarnParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerStructuredMockDebug struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockDebugExpectation
	expectations       []*LoggerStructuredMockDebugExpectation

	callArgs []*LoggerStructuredMockDebugParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockDebugExpectation specifies expectation struct of the LoggerStructured.Debug
type LoggerStructuredMockDebugExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockDebugParams
	paramPtrs          *LoggerStructuredMockDebugParamPtrs
	expectationOrigins LoggerStructuredMockDebugExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockDebugParams contains parameters of the LoggerStructured.Debug
type LoggerStructuredMockDebugParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockDebugParamPtrs contains pointers to parameters of the LoggerStructured.Debug
type LoggerStructuredMockDebugParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockDebugOrigins contains origins of expectations of the LoggerStructured.Debug
type LoggerStructuredMockDebugExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebug *mLoggerStructuredMockDebug) Optional() *mLoggerStructuredMockDebug {
	mmDebug.optional = true
	return mmDebug
}

// Expect sets up expected params for LoggerStructured.Debug
func (mmDebug *mLoggerStructuredMockDebug) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerStructuredMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.paramPtrs != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by ExpectParams functions")
	}

	mmDebug.defaultExpectation.params = &LoggerStructuredMockDebugParams{msg, fields}
	mmDebug.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Debug
func (mmDebug *mLoggerStructuredMockDebug) ExpectMsgParam1(msg string) *mLoggerStructuredMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerStructuredMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerStructuredMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.msg = &msg
	mmDebug.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmDebug
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Debug
func (mmDebug *mLoggerStructuredMockDebug) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerStructuredMockDebugExpectation{}
	}

	if mmDebug.defaultExpectation.params != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Expect")
	}

	if mmDebug.defaultExpectation.paramPtrs == nil {
		mmDebug.defaultExpectation.paramPtrs = &LoggerStructuredMockDebugParamPtrs{}
	}
	mmDebug.defaultExpectation.paramPtrs.fields = &fields
	mmDebug.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Debug
func (mmDebug *mLoggerStructuredMockDebug) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by LoggerStructured.Debug
func (mmDebug *mLoggerStructuredMockDebug) Return() *LoggerStructuredMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &LoggerStructuredMockDebugExpectation{mock: mmDebug.mock}
	}

	mmDebug.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// Set uses given function f to mock the LoggerStructured.Debug method
func (mmDebug *mLoggerStructuredMockDebug) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Debug method")
	}

	mmDebug.mock.funcDebug = f
	mmDebug.mock.funcDebugOrigin = minimock.CallerInfo(1)
	return mmDebug.mock
}

// When sets expectation for the LoggerStructured.Debug which will trigger the result defined by the following
// Then helper
func (mmDebug *mLoggerStructuredMockDebug) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockDebugExpectation {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("LoggerStructuredMock.Debug mock is already set by Set")
	}

	expectation := &LoggerStructuredMockDebugExpectation{
		mock:               mmDebug.mock,
		params:             &LoggerStructuredMockDebugParams{msg, fields},
		expectationOrigins: LoggerStructuredMockDebugExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebug.expectations = append(mmDebug.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Debug return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockDebugExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Debug should be invoked
func (mmDebug *mLoggerStructuredMockDebug) Times(n uint64) *mLoggerStructuredMockDebug {
	if n == 0 {
		mmDebug.mock.t.Fatalf("Times of LoggerStructuredMock.Debug mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebug.expectedInvocations, n)
	mmDebug.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebug
}

func (mmDebug *mLoggerStructuredMockDebug) invocationsDone() bool {
	if len(mmDebug.expectations) == 0 && mmDebug.defaultExpectation == nil && mmDebug.mock.funcDebug == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebug.mock.afterDebugCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebug.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debug implements mm_log.LoggerStructured
func (mmDebug *LoggerStructuredMock) Debug(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	mmDebug.t.Helper()

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(msg, fields...)
	}

	mm_params := LoggerStructuredMockDebugParams{msg, fields}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, &mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_want_ptrs := mmDebug.DebugMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockDebugParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmDebug.t.Errorf("LoggerStructuredMock.Debug got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmDebug.t.Errorf("LoggerStructuredMock.Debug got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebug.DebugMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("LoggerStructuredMock.Debug got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebug.DebugMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(msg, fields...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to LoggerStructuredMock.Debug. %v %v", msg, fields)

}

// DebugAfterCounter returns a count of finished LoggerStructuredMock.Debug invocations
func (mmDebug *LoggerStructuredMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of LoggerStructuredMock.Debug invocations
func (mmDebug *LoggerStructuredMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mLoggerStructuredMockDebug) Calls() []*LoggerStructuredMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockDebugDone() bool {
	if m.DebugMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugMock.invocationsDone()
}

// MinimockDebugInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Debug at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugCounter := mm_atomic.LoadUint64(&m.afterDebugCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && afterDebugCounter < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Debug at\n%s", m.DebugMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Debug at\n%s with params: %#v", m.DebugMock.defaultExpectation.expectationOrigins.origin, *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && afterDebugCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Debug at\n%s", m.funcDebugOrigin)
	}

	if !m.DebugMock.invocationsDone() && afterDebugCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Debug at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugMock.expectedInvocations), m.DebugMock.expectedInvocationsOrigin, afterDebugCounter)
	}
}

type mLoggerStructuredMockError struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockErrorExpectation
	expectations       []*LoggerStructuredMockErrorExpectation

	callArgs []*LoggerStructuredMockErrorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockErrorExpectation specifies expectation struct of the LoggerStructured.Error
type LoggerStructuredMockErrorExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockErrorParams
	paramPtrs          *LoggerStructuredMockErrorParamPtrs
	expectationOrigins LoggerStructuredMockErrorExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockErrorParams contains parameters of the LoggerStructured.Error
type LoggerStructuredMockErrorParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockErrorParamPtrs contains pointers to parameters of the LoggerStructured.Error
type LoggerStructuredMockErrorParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockErrorOrigins contains origins of expectations of the LoggerStructured.Error
type LoggerStructuredMockErrorExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmError *mLoggerStructuredMockError) Optional() *mLoggerStructuredMockError {
	mmError.optional = true
	return mmError
}

// Expect sets up expected params for LoggerStructured.Error
func (mmError *mLoggerStructuredMockError) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerStructuredMockErrorExpectation{}
	}

	if mmError.defaultExpectation.paramPtrs != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by ExpectParams functions")
	}

	mmError.defaultExpectation.params = &LoggerStructuredMockErrorParams{msg, fields}
	mmError.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Error
func (mmError *mLoggerStructuredMockError) ExpectMsgParam1(msg string) *mLoggerStructuredMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerStructuredMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerStructuredMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.msg = &msg
	mmError.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmError
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Error
func (mmError *mLoggerStructuredMockError) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerStructuredMockErrorExpectation{}
	}

	if mmError.defaultExpectation.params != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Expect")
	}

	if mmError.defaultExpectation.paramPtrs == nil {
		mmError.defaultExpectation.paramPtrs = &LoggerStructuredMockErrorParamPtrs{}
	}
	mmError.defaultExpectation.paramPtrs.fields = &fields
	mmError.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Error
func (mmError *mLoggerStructuredMockError) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by LoggerStructured.Error
func (mmError *mLoggerStructuredMockError) Return() *LoggerStructuredMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &LoggerStructuredMockErrorExpectation{mock: mmError.mock}
	}

	mmError.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// Set uses given function f to mock the LoggerStructured.Error method
func (mmError *mLoggerStructuredMockError) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Error method")
	}

	mmError.mock.funcError = f
	mmError.mock.funcErrorOrigin = minimock.CallerInfo(1)
	return mmError.mock
}

// When sets expectation for the LoggerStructured.Error which will trigger the result defined by the following
// Then helper
func (mmError *mLoggerStructuredMockError) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockErrorExpectation {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("LoggerStructuredMock.Error mock is already set by Set")
	}

	expectation := &LoggerStructuredMockErrorExpectation{
		mock:               mmError.mock,
		params:             &LoggerStructuredMockErrorParams{msg, fields},
		expectationOrigins: LoggerStructuredMockErrorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmError.expectations = append(mmError.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Error return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockErrorExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Error should be invoked
func (mmError *mLoggerStructuredMockError) Times(n uint64) *mLoggerStructuredMockError {
	if n == 0 {
		mmError.mock.t.Fatalf("Times of LoggerStructuredMock.Error mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmError.expectedInvocations, n)
	mmError.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmError
}

func (mmError *mLoggerStructuredMockError) invocationsDone() bool {
	if len(mmError.expectations) == 0 && mmError.defaultExpectation == nil && mmError.mock.funcError == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmError.mock.afterErrorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmError.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Error implements mm_log.LoggerStructured
func (mmError *LoggerStructuredMock) Error(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	mmError.t.Helper()

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(msg, fields...)
	}

	mm_params := LoggerStructuredMockErrorParams{msg, fields}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, &mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_want_ptrs := mmError.ErrorMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockErrorParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmError.t.Errorf("LoggerStructuredMock.Error got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmError.t.Errorf("LoggerStructuredMock.Error got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmError.ErrorMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("LoggerStructuredMock.Error got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmError.ErrorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(msg, fields...)
		return
	}
	mmError.t.Fatalf("Unexpected call to LoggerStructuredMock.Error. %v %v", msg, fields)

}

// ErrorAfterCounter returns a count of finished LoggerStructuredMock.Error invocations
func (mmError *LoggerStructuredMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of LoggerStructuredMock.Error invocations
func (mmError *LoggerStructuredMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mLoggerStructuredMockError) Calls() []*LoggerStructuredMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockErrorDone() bool {
	if m.ErrorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorMock.invocationsDone()
}

// MinimockErrorInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Error at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorCounter := mm_atomic.LoadUint64(&m.afterErrorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && afterErrorCounter < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Error at\n%s", m.ErrorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Error at\n%s with params: %#v", m.ErrorMock.defaultExpectation.expectationOrigins.origin, *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && afterErrorCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Error at\n%s", m.funcErrorOrigin)
	}

	if !m.ErrorMock.invocationsDone() && afterErrorCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Error at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorMock.expectedInvocations), m.ErrorMock.expectedInvocationsOrigin, afterErrorCounter)
	}
}

type mLoggerStructuredMockFatal struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockFatalExpectation
	expectations       []*LoggerStructuredMockFatalExpectation

	callArgs []*LoggerStructuredMockFatalParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockFatalExpectation specifies expectation struct of the LoggerStructured.Fatal
type LoggerStructuredMockFatalExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockFatalParams
	paramPtrs          *LoggerStructuredMockFatalParamPtrs
	expectationOrigins LoggerStructuredMockFatalExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockFatalParams contains parameters of the LoggerStructured.Fatal
type LoggerStructuredMockFatalParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockFatalParamPtrs contains pointers to parameters of the LoggerStructured.Fatal
type LoggerStructuredMockFatalParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockFatalOrigins contains origins of expectations of the LoggerStructured.Fatal
type LoggerStructuredMockFatalExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatal *mLoggerStructuredMockFatal) Optional() *mLoggerStructuredMockFatal {
	mmFatal.optional = true
	return mmFatal
}

// Expect sets up expected params for LoggerStructured.Fatal
func (mmFatal *mLoggerStructuredMockFatal) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerStructuredMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.paramPtrs != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by ExpectParams functions")
	}

	mmFatal.defaultExpectation.params = &LoggerStructuredMockFatalParams{msg, fields}
	mmFatal.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Fatal
func (mmFatal *mLoggerStructuredMockFatal) ExpectMsgParam1(msg string) *mLoggerStructuredMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerStructuredMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerStructuredMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.msg = &msg
	mmFatal.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmFatal
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Fatal
func (mmFatal *mLoggerStructuredMockFatal) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerStructuredMockFatalExpectation{}
	}

	if mmFatal.defaultExpectation.params != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Expect")
	}

	if mmFatal.defaultExpectation.paramPtrs == nil {
		mmFatal.defaultExpectation.paramPtrs = &LoggerStructuredMockFatalParamPtrs{}
	}
	mmFatal.defaultExpectation.paramPtrs.fields = &fields
	mmFatal.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Fatal
func (mmFatal *mLoggerStructuredMockFatal) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by LoggerStructured.Fatal
func (mmFatal *mLoggerStructuredMockFatal) Return() *LoggerStructuredMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &LoggerStructuredMockFatalExpectation{mock: mmFatal.mock}
	}

	mmFatal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// Set uses given function f to mock the LoggerStructured.Fatal method
func (mmFatal *mLoggerStructuredMockFatal) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	mmFatal.mock.funcFatalOrigin = minimock.CallerInfo(1)
	return mmFatal.mock
}

// When sets expectation for the LoggerStructured.Fatal which will trigger the result defined by the following
// Then helper
func (mmFatal *mLoggerStructuredMockFatal) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockFatalExpectation {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("LoggerStructuredMock.Fatal mock is already set by Set")
	}

	expectation := &LoggerStructuredMockFatalExpectation{
		mock:               mmFatal.mock,
		params:             &LoggerStructuredMockFatalParams{msg, fields},
		expectationOrigins: LoggerStructuredMockFatalExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFatal.expectations = append(mmFatal.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Fatal return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockFatalExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Fatal should be invoked
func (mmFatal *mLoggerStructuredMockFatal) Times(n uint64) *mLoggerStructuredMockFatal {
	if n == 0 {
		mmFatal.mock.t.Fatalf("Times of LoggerStructuredMock.Fatal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatal.expectedInvocations, n)
	mmFatal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFatal
}

func (mmFatal *mLoggerStructuredMockFatal) invocationsDone() bool {
	if len(mmFatal.expectations) == 0 && mmFatal.defaultExpectation == nil && mmFatal.mock.funcFatal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatal.mock.afterFatalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatal implements mm_log.LoggerStructured
func (mmFatal *LoggerStructuredMock) Fatal(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	mmFatal.t.Helper()

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(msg, fields...)
	}

	mm_params := LoggerStructuredMockFatalParams{msg, fields}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, &mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_want_ptrs := mmFatal.FatalMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockFatalParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmFatal.t.Errorf("LoggerStructuredMock.Fatal got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmFatal.t.Errorf("LoggerStructuredMock.Fatal got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatal.FatalMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("LoggerStructuredMock.Fatal got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFatal.FatalMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(msg, fields...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to LoggerStructuredMock.Fatal. %v %v", msg, fields)

}

// FatalAfterCounter returns a count of finished LoggerStructuredMock.Fatal invocations
func (mmFatal *LoggerStructuredMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of LoggerStructuredMock.Fatal invocations
func (mmFatal *LoggerStructuredMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mLoggerStructuredMockFatal) Calls() []*LoggerStructuredMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockFatalDone() bool {
	if m.FatalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalMock.invocationsDone()
}

// MinimockFatalInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Fatal at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFatalCounter := mm_atomic.LoadUint64(&m.afterFatalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && afterFatalCounter < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Fatal at\n%s", m.FatalMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Fatal at\n%s with params: %#v", m.FatalMock.defaultExpectation.expectationOrigins.origin, *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && afterFatalCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Fatal at\n%s", m.funcFatalOrigin)
	}

	if !m.FatalMock.invocationsDone() && afterFatalCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Fatal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FatalMock.expectedInvocations), m.FatalMock.expectedInvocationsOrigin, afterFatalCounter)
	}
}

type mLoggerStructuredMockInfo struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockInfoExpectation
	expectations       []*LoggerStructuredMockInfoExpectation

	callArgs []*LoggerStructuredMockInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockInfoExpectation specifies expectation struct of the LoggerStructured.Info
type LoggerStructuredMockInfoExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockInfoParams
	paramPtrs          *LoggerStructuredMockInfoParamPtrs
	expectationOrigins LoggerStructuredMockInfoExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockInfoParams contains parameters of the LoggerStructured.Info
type LoggerStructuredMockInfoParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockInfoParamPtrs contains pointers to parameters of the LoggerStructured.Info
type LoggerStructuredMockInfoParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockInfoOrigins contains origins of expectations of the LoggerStructured.Info
type LoggerStructuredMockInfoExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfo *mLoggerStructuredMockInfo) Optional() *mLoggerStructuredMockInfo {
	mmInfo.optional = true
	return mmInfo
}

// Expect sets up expected params for LoggerStructured.Info
func (mmInfo *mLoggerStructuredMockInfo) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerStructuredMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.paramPtrs != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by ExpectParams functions")
	}

	mmInfo.defaultExpectation.params = &LoggerStructuredMockInfoParams{msg, fields}
	mmInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Info
func (mmInfo *mLoggerStructuredMockInfo) ExpectMsgParam1(msg string) *mLoggerStructuredMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerStructuredMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerStructuredMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.msg = &msg
	mmInfo.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmInfo
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Info
func (mmInfo *mLoggerStructuredMockInfo) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerStructuredMockInfoExpectation{}
	}

	if mmInfo.defaultExpectation.params != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Expect")
	}

	if mmInfo.defaultExpectation.paramPtrs == nil {
		mmInfo.defaultExpectation.paramPtrs = &LoggerStructuredMockInfoParamPtrs{}
	}
	mmInfo.defaultExpectation.paramPtrs.fields = &fields
	mmInfo.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Info
func (mmInfo *mLoggerStructuredMockInfo) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by LoggerStructured.Info
func (mmInfo *mLoggerStructuredMockInfo) Return() *LoggerStructuredMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &LoggerStructuredMockInfoExpectation{mock: mmInfo.mock}
	}

	mmInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// Set uses given function f to mock the LoggerStructured.Info method
func (mmInfo *mLoggerStructuredMockInfo) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Info method")
	}

	mmInfo.mock.funcInfo = f
	mmInfo.mock.funcInfoOrigin = minimock.CallerInfo(1)
	return mmInfo.mock
}

// When sets expectation for the LoggerStructured.Info which will trigger the result defined by the following
// Then helper
func (mmInfo *mLoggerStructuredMockInfo) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockInfoExpectation {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("LoggerStructuredMock.Info mock is already set by Set")
	}

	expectation := &LoggerStructuredMockInfoExpectation{
		mock:               mmInfo.mock,
		params:             &LoggerStructuredMockInfoParams{msg, fields},
		expectationOrigins: LoggerStructuredMockInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfo.expectations = append(mmInfo.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Info return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockInfoExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Info should be invoked
func (mmInfo *mLoggerStructuredMockInfo) Times(n uint64) *mLoggerStructuredMockInfo {
	if n == 0 {
		mmInfo.mock.t.Fatalf("Times of LoggerStructuredMock.Info mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfo.expectedInvocations, n)
	mmInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfo
}

func (mmInfo *mLoggerStructuredMockInfo) invocationsDone() bool {
	if len(mmInfo.expectations) == 0 && mmInfo.defaultExpectation == nil && mmInfo.mock.funcInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfo.mock.afterInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Info implements mm_log.LoggerStructured
func (mmInfo *LoggerStructuredMock) Info(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	mmInfo.t.Helper()

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(msg, fields...)
	}

	mm_params := LoggerStructuredMockInfoParams{msg, fields}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, &mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_want_ptrs := mmInfo.InfoMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockInfoParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmInfo.t.Errorf("LoggerStructuredMock.Info got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmInfo.t.Errorf("LoggerStructuredMock.Info got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfo.InfoMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("LoggerStructuredMock.Info got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfo.InfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(msg, fields...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to LoggerStructuredMock.Info. %v %v", msg, fields)

}

// InfoAfterCounter returns a count of finished LoggerStructuredMock.Info invocations
func (mmInfo *LoggerStructuredMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of LoggerStructuredMock.Info invocations
func (mmInfo *LoggerStructuredMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mLoggerStructuredMockInfo) Calls() []*LoggerStructuredMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockInfoDone() bool {
	if m.InfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfoMock.invocationsDone()
}

// MinimockInfoInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Info at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfoCounter := mm_atomic.LoadUint64(&m.afterInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && afterInfoCounter < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Info at\n%s", m.InfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Info at\n%s with params: %#v", m.InfoMock.defaultExpectation.expectationOrigins.origin, *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && afterInfoCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Info at\n%s", m.funcInfoOrigin)
	}

	if !m.InfoMock.invocationsDone() && afterInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Info at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfoMock.expectedInvocations), m.InfoMock.expectedInvocationsOrigin, afterInfoCounter)
	}
}

type mLoggerStructuredMockTrace struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockTraceExpectation
	expectations       []*LoggerStructuredMockTraceExpectation

	callArgs []*LoggerStructuredMockTraceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockTraceExpectation specifies expectation struct of the LoggerStructured.Trace
type LoggerStructuredMockTraceExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockTraceParams
	paramPtrs          *LoggerStructuredMockTraceParamPtrs
	expectationOrigins LoggerStructuredMockTraceExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockTraceParams contains parameters of the LoggerStructured.Trace
type LoggerStructuredMockTraceParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockTraceParamPtrs contains pointers to parameters of the LoggerStructured.Trace
type LoggerStructuredMockTraceParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockTraceOrigins contains origins of expectations of the LoggerStructured.Trace
type LoggerStructuredMockTraceExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTrace *mLoggerStructuredMockTrace) Optional() *mLoggerStructuredMockTrace {
	mmTrace.optional = true
	return mmTrace
}

// Expect sets up expected params for LoggerStructured.Trace
func (mmTrace *mLoggerStructuredMockTrace) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerStructuredMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.paramPtrs != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by ExpectParams functions")
	}

	mmTrace.defaultExpectation.params = &LoggerStructuredMockTraceParams{msg, fields}
	mmTrace.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTrace.expectations {
		if minimock.Equal(e.params, mmTrace.defaultExpectation.params) {
			mmTrace.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTrace.defaultExpectation.params)
		}
	}

	return mmTrace
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Trace
func (mmTrace *mLoggerStructuredMockTrace) ExpectMsgParam1(msg string) *mLoggerStructuredMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerStructuredMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.params != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Expect")
	}

	if mmTrace.defaultExpectation.paramPtrs == nil {
		mmTrace.defaultExpectation.paramPtrs = &LoggerStructuredMockTraceParamPtrs{}
	}
	mmTrace.defaultExpectation.paramPtrs.msg = &msg
	mmTrace.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmTrace
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Trace
func (mmTrace *mLoggerStructuredMockTrace) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockTrace {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerStructuredMockTraceExpectation{}
	}

	if mmTrace.defaultExpectation.params != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Expect")
	}

	if mmTrace.defaultExpectation.paramPtrs == nil {
		mmTrace.defaultExpectation.paramPtrs = &LoggerStructuredMockTraceParamPtrs{}
	}
	mmTrace.defaultExpectation.paramPtrs.fields = &fields
	mmTrace.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmTrace
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Trace
func (mmTrace *mLoggerStructuredMockTrace) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockTrace {
	if mmTrace.mock.inspectFuncTrace != nil {
		mmTrace.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Trace")
	}

	mmTrace.mock.inspectFuncTrace = f

	return mmTrace
}

// Return sets up results that will be returned by LoggerStructured.Trace
func (mmTrace *mLoggerStructuredMockTrace) Return() *LoggerStructuredMock {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Set")
	}

	if mmTrace.defaultExpectation == nil {
		mmTrace.defaultExpectation = &LoggerStructuredMockTraceExpectation{mock: mmTrace.mock}
	}

	mmTrace.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTrace.mock
}

// Set uses given function f to mock the LoggerStructured.Trace method
func (mmTrace *mLoggerStructuredMockTrace) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmTrace.defaultExpectation != nil {
		mmTrace.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Trace method")
	}

	if len(mmTrace.expectations) > 0 {
		mmTrace.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Trace method")
	}

	mmTrace.mock.funcTrace = f
	mmTrace.mock.funcTraceOrigin = minimock.CallerInfo(1)
	return mmTrace.mock
}

// When sets expectation for the LoggerStructured.Trace which will trigger the result defined by the following
// Then helper
func (mmTrace *mLoggerStructuredMockTrace) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockTraceExpectation {
	if mmTrace.mock.funcTrace != nil {
		mmTrace.mock.t.Fatalf("LoggerStructuredMock.Trace mock is already set by Set")
	}

	expectation := &LoggerStructuredMockTraceExpectation{
		mock:               mmTrace.mock,
		params:             &LoggerStructuredMockTraceParams{msg, fields},
		expectationOrigins: LoggerStructuredMockTraceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTrace.expectations = append(mmTrace.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Trace return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockTraceExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Trace should be invoked
func (mmTrace *mLoggerStructuredMockTrace) Times(n uint64) *mLoggerStructuredMockTrace {
	if n == 0 {
		mmTrace.mock.t.Fatalf("Times of LoggerStructuredMock.Trace mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTrace.expectedInvocations, n)
	mmTrace.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTrace
}

func (mmTrace *mLoggerStructuredMockTrace) invocationsDone() bool {
	if len(mmTrace.expectations) == 0 && mmTrace.defaultExpectation == nil && mmTrace.mock.funcTrace == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTrace.mock.afterTraceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTrace.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Trace implements mm_log.LoggerStructured
func (mmTrace *LoggerStructuredMock) Trace(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmTrace.beforeTraceCounter, 1)
	defer mm_atomic.AddUint64(&mmTrace.afterTraceCounter, 1)

	mmTrace.t.Helper()

	if mmTrace.inspectFuncTrace != nil {
		mmTrace.inspectFuncTrace(msg, fields...)
	}

	mm_params := LoggerStructuredMockTraceParams{msg, fields}

	// Record call args
	mmTrace.TraceMock.mutex.Lock()
	mmTrace.TraceMock.callArgs = append(mmTrace.TraceMock.callArgs, &mm_params)
	mmTrace.TraceMock.mutex.Unlock()

	for _, e := range mmTrace.TraceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTrace.TraceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTrace.TraceMock.defaultExpectation.Counter, 1)
		mm_want := mmTrace.TraceMock.defaultExpectation.params
		mm_want_ptrs := mmTrace.TraceMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockTraceParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmTrace.t.Errorf("LoggerStructuredMock.Trace got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTrace.TraceMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmTrace.t.Errorf("LoggerStructuredMock.Trace got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTrace.TraceMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTrace.t.Errorf("LoggerStructuredMock.Trace got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTrace.TraceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTrace.funcTrace != nil {
		mmTrace.funcTrace(msg, fields...)
		return
	}
	mmTrace.t.Fatalf("Unexpected call to LoggerStructuredMock.Trace. %v %v", msg, fields)

}

// TraceAfterCounter returns a count of finished LoggerStructuredMock.Trace invocations
func (mmTrace *LoggerStructuredMock) TraceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrace.afterTraceCounter)
}

// TraceBeforeCounter returns a count of LoggerStructuredMock.Trace invocations
func (mmTrace *LoggerStructuredMock) TraceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrace.beforeTraceCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Trace.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTrace *mLoggerStructuredMockTrace) Calls() []*LoggerStructuredMockTraceParams {
	mmTrace.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockTraceParams, len(mmTrace.callArgs))
	copy(argCopy, mmTrace.callArgs)

	mmTrace.mutex.RUnlock()

	return argCopy
}

// MinimockTraceDone returns true if the count of the Trace invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockTraceDone() bool {
	if m.TraceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TraceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TraceMock.invocationsDone()
}

// MinimockTraceInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockTraceInspect() {
	for _, e := range m.TraceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Trace at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTraceCounter := mm_atomic.LoadUint64(&m.afterTraceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TraceMock.defaultExpectation != nil && afterTraceCounter < 1 {
		if m.TraceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Trace at\n%s", m.TraceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Trace at\n%s with params: %#v", m.TraceMock.defaultExpectation.expectationOrigins.origin, *m.TraceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrace != nil && afterTraceCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Trace at\n%s", m.funcTraceOrigin)
	}

	if !m.TraceMock.invocationsDone() && afterTraceCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Trace at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TraceMock.expectedInvocations), m.TraceMock.expectedInvocationsOrigin, afterTraceCounter)
	}
}

type mLoggerStructuredMockWarn struct {
	optional           bool
	mock               *LoggerStructuredMock
	defaultExpectation *LoggerStructuredMockWarnExpectation
	expectations       []*LoggerStructuredMockWarnExpectation

	callArgs []*LoggerStructuredMockWarnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerStructuredMockWarnExpectation specifies expectation struct of the LoggerStructured.Warn
type LoggerStructuredMockWarnExpectation struct {
	mock               *LoggerStructuredMock
	params             *LoggerStructuredMockWarnParams
	paramPtrs          *LoggerStructuredMockWarnParamPtrs
	expectationOrigins LoggerStructuredMockWarnExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerStructuredMockWarnParams contains parameters of the LoggerStructured.Warn
type LoggerStructuredMockWarnParams struct {
	msg    string
	fields []mm_log.Field
}

// LoggerStructuredMockWarnParamPtrs contains pointers to parameters of the LoggerStructured.Warn
type LoggerStructuredMockWarnParamPtrs struct {
	msg    *string
	fields *[]mm_log.Field
}

// LoggerStructuredMockWarnOrigins contains origins of expectations of the LoggerStructured.Warn
type LoggerStructuredMockWarnExpectationOrigins struct {
	origin       string
	originMsg    string
	originFields string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarn *mLoggerStructuredMockWarn) Optional() *mLoggerStructuredMockWarn {
	mmWarn.optional = true
	return mmWarn
}

// Expect sets up expected params for LoggerStructured.Warn
func (mmWarn *mLoggerStructuredMockWarn) Expect(msg string, fields ...mm_log.Field) *mLoggerStructuredMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerStructuredMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.paramPtrs != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by ExpectParams functions")
	}

	mmWarn.defaultExpectation.params = &LoggerStructuredMockWarnParams{msg, fields}
	mmWarn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// ExpectMsgParam1 sets up expected param msg for LoggerStructured.Warn
func (mmWarn *mLoggerStructuredMockWarn) ExpectMsgParam1(msg string) *mLoggerStructuredMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerStructuredMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerStructuredMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.msg = &msg
	mmWarn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmWarn
}

// ExpectFieldsParam2 sets up expected param fields for LoggerStructured.Warn
func (mmWarn *mLoggerStructuredMockWarn) ExpectFieldsParam2(fields ...mm_log.Field) *mLoggerStructuredMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerStructuredMockWarnExpectation{}
	}

	if mmWarn.defaultExpectation.params != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Expect")
	}

	if mmWarn.defaultExpectation.paramPtrs == nil {
		mmWarn.defaultExpectation.paramPtrs = &LoggerStructuredMockWarnParamPtrs{}
	}
	mmWarn.defaultExpectation.paramPtrs.fields = &fields
	mmWarn.defaultExpectation.expectationOrigins.originFields = minimock.CallerInfo(1)

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the LoggerStructured.Warn
func (mmWarn *mLoggerStructuredMockWarn) Inspect(f func(msg string, fields ...mm_log.Field)) *mLoggerStructuredMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for LoggerStructuredMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by LoggerStructured.Warn
func (mmWarn *mLoggerStructuredMockWarn) Return() *LoggerStructuredMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &LoggerStructuredMockWarnExpectation{mock: mmWarn.mock}
	}

	mmWarn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// Set uses given function f to mock the LoggerStructured.Warn method
func (mmWarn *mLoggerStructuredMockWarn) Set(f func(msg string, fields ...mm_log.Field)) *LoggerStructuredMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the LoggerStructured.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the LoggerStructured.Warn method")
	}

	mmWarn.mock.funcWarn = f
	mmWarn.mock.funcWarnOrigin = minimock.CallerInfo(1)
	return mmWarn.mock
}

// When sets expectation for the LoggerStructured.Warn which will trigger the result defined by the following
// Then helper
func (mmWarn *mLoggerStructuredMockWarn) When(msg string, fields ...mm_log.Field) *LoggerStructuredMockWarnExpectation {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("LoggerStructuredMock.Warn mock is already set by Set")
	}

	expectation := &LoggerStructuredMockWarnExpectation{
		mock:               mmWarn.mock,
		params:             &LoggerStructuredMockWarnParams{msg, fields},
		expectationOrigins: LoggerStructuredMockWarnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarn.expectations = append(mmWarn.expectations, expectation)
	return expectation
}

// Then sets up LoggerStructured.Warn return parameters for the expectation previously defined by the When method

func (e *LoggerStructuredMockWarnExpectation) Then() *LoggerStructuredMock {
	return e.mock
}

// Times sets number of times LoggerStructured.Warn should be invoked
func (mmWarn *mLoggerStructuredMockWarn) Times(n uint64) *mLoggerStructuredMockWarn {
	if n == 0 {
		mmWarn.mock.t.Fatalf("Times of LoggerStructuredMock.Warn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarn.expectedInvocations, n)
	mmWarn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarn
}

func (mmWarn *mLoggerStructuredMockWarn) invocationsDone() bool {
	if len(mmWarn.expectations) == 0 && mmWarn.defaultExpectation == nil && mmWarn.mock.funcWarn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarn.mock.afterWarnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warn implements mm_log.LoggerStructured
func (mmWarn *LoggerStructuredMock) Warn(msg string, fields ...mm_log.Field) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	mmWarn.t.Helper()

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(msg, fields...)
	}

	mm_params := LoggerStructuredMockWarnParams{msg, fields}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, &mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_want_ptrs := mmWarn.WarnMock.defaultExpectation.paramPtrs

		mm_got := LoggerStructuredMockWarnParams{msg, fields}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmWarn.t.Errorf("LoggerStructuredMock.Warn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.fields != nil && !minimock.Equal(*mm_want_ptrs.fields, mm_got.fields) {
				mmWarn.t.Errorf("LoggerStructuredMock.Warn got unexpected parameter fields, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarn.WarnMock.defaultExpectation.expectationOrigins.originFields, *mm_want_ptrs.fields, mm_got.fields, minimock.Diff(*mm_want_ptrs.fields, mm_got.fields))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("LoggerStructuredMock.Warn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarn.WarnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(msg, fields...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to LoggerStructuredMock.Warn. %v %v", msg, fields)

}

// WarnAfterCounter returns a count of finished LoggerStructuredMock.Warn invocations
func (mmWarn *LoggerStructuredMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of LoggerStructuredMock.Warn invocations
func (mmWarn *LoggerStructuredMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to LoggerStructuredMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mLoggerStructuredMockWarn) Calls() []*LoggerStructuredMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*LoggerStructuredMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *LoggerStructuredMock) MinimockWarnDone() bool {
	if m.WarnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnMock.invocationsDone()
}

// MinimockWarnInspect logs each unmet expectation
func (m *LoggerStructuredMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerStructuredMock.Warn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnCounter := mm_atomic.LoadUint64(&m.afterWarnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && afterWarnCounter < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerStructuredMock.Warn at\n%s", m.WarnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerStructuredMock.Warn at\n%s with params: %#v", m.WarnMock.defaultExpectation.expectationOrigins.origin, *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && afterWarnCounter < 1 {
		m.t.Errorf("Expected call to LoggerStructuredMock.Warn at\n%s", m.funcWarnOrigin)
	}

	if !m.WarnMock.invocationsDone() && afterWarnCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerStructuredMock.Warn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnMock.expectedInvocations), m.WarnMock.expectedInvocationsOrigin, afterWarnCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerStructuredMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugInspect()

			m.MinimockErrorInspect()

			m.MinimockFatalInspect()

			m.MinimockInfoInspect()

			m.MinimockTraceInspect()

			m.MinimockWarnInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerStructuredMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerStructuredMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockErrorDone() &&
		m.MinimockFatalDone() &&
		m.MinimockInfoDone() &&
		m.MinimockTraceDone() &&
		m.MinimockWarnDone()
}
