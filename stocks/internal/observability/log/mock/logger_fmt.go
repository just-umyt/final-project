// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoggerFmtMock implements mm_log.LoggerFmt
type LoggerFmtMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDebugf          func(format string, args ...interface{})
	funcDebugfOrigin    string
	inspectFuncDebugf   func(format string, args ...interface{})
	afterDebugfCounter  uint64
	beforeDebugfCounter uint64
	DebugfMock          mLoggerFmtMockDebugf

	funcErrorf          func(format string, args ...interface{})
	funcErrorfOrigin    string
	inspectFuncErrorf   func(format string, args ...interface{})
	afterErrorfCounter  uint64
	beforeErrorfCounter uint64
	ErrorfMock          mLoggerFmtMockErrorf

	funcFatalf          func(format string, args ...interface{})
	funcFatalfOrigin    string
	inspectFuncFatalf   func(format string, args ...interface{})
	afterFatalfCounter  uint64
	beforeFatalfCounter uint64
	FatalfMock          mLoggerFmtMockFatalf

	funcInfof          func(format string, args ...interface{})
	funcInfofOrigin    string
	inspectFuncInfof   func(format string, args ...interface{})
	afterInfofCounter  uint64
	beforeInfofCounter uint64
	InfofMock          mLoggerFmtMockInfof

	funcTracef          func(format string, args ...interface{})
	funcTracefOrigin    string
	inspectFuncTracef   func(format string, args ...interface{})
	afterTracefCounter  uint64
	beforeTracefCounter uint64
	TracefMock          mLoggerFmtMockTracef

	funcWarnf          func(format string, args ...interface{})
	funcWarnfOrigin    string
	inspectFuncWarnf   func(format string, args ...interface{})
	afterWarnfCounter  uint64
	beforeWarnfCounter uint64
	WarnfMock          mLoggerFmtMockWarnf
}

// NewLoggerFmtMock returns a mock for mm_log.LoggerFmt
func NewLoggerFmtMock(t minimock.Tester) *LoggerFmtMock {
	m := &LoggerFmtMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugfMock = mLoggerFmtMockDebugf{mock: m}
	m.DebugfMock.callArgs = []*LoggerFmtMockDebugfParams{}

	m.ErrorfMock = mLoggerFmtMockErrorf{mock: m}
	m.ErrorfMock.callArgs = []*LoggerFmtMockErrorfParams{}

	m.FatalfMock = mLoggerFmtMockFatalf{mock: m}
	m.FatalfMock.callArgs = []*LoggerFmtMockFatalfParams{}

	m.InfofMock = mLoggerFmtMockInfof{mock: m}
	m.InfofMock.callArgs = []*LoggerFmtMockInfofParams{}

	m.TracefMock = mLoggerFmtMockTracef{mock: m}
	m.TracefMock.callArgs = []*LoggerFmtMockTracefParams{}

	m.WarnfMock = mLoggerFmtMockWarnf{mock: m}
	m.WarnfMock.callArgs = []*LoggerFmtMockWarnfParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoggerFmtMockDebugf struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockDebugfExpectation
	expectations       []*LoggerFmtMockDebugfExpectation

	callArgs []*LoggerFmtMockDebugfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockDebugfExpectation specifies expectation struct of the LoggerFmt.Debugf
type LoggerFmtMockDebugfExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockDebugfParams
	paramPtrs          *LoggerFmtMockDebugfParamPtrs
	expectationOrigins LoggerFmtMockDebugfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockDebugfParams contains parameters of the LoggerFmt.Debugf
type LoggerFmtMockDebugfParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockDebugfParamPtrs contains pointers to parameters of the LoggerFmt.Debugf
type LoggerFmtMockDebugfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockDebugfOrigins contains origins of expectations of the LoggerFmt.Debugf
type LoggerFmtMockDebugfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDebugf *mLoggerFmtMockDebugf) Optional() *mLoggerFmtMockDebugf {
	mmDebugf.optional = true
	return mmDebugf
}

// Expect sets up expected params for LoggerFmt.Debugf
func (mmDebugf *mLoggerFmtMockDebugf) Expect(format string, args ...interface{}) *mLoggerFmtMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerFmtMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.paramPtrs != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by ExpectParams functions")
	}

	mmDebugf.defaultExpectation.params = &LoggerFmtMockDebugfParams{format, args}
	mmDebugf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDebugf.expectations {
		if minimock.Equal(e.params, mmDebugf.defaultExpectation.params) {
			mmDebugf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebugf.defaultExpectation.params)
		}
	}

	return mmDebugf
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Debugf
func (mmDebugf *mLoggerFmtMockDebugf) ExpectFormatParam1(format string) *mLoggerFmtMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerFmtMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerFmtMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.format = &format
	mmDebugf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmDebugf
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Debugf
func (mmDebugf *mLoggerFmtMockDebugf) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockDebugf {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerFmtMockDebugfExpectation{}
	}

	if mmDebugf.defaultExpectation.params != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Expect")
	}

	if mmDebugf.defaultExpectation.paramPtrs == nil {
		mmDebugf.defaultExpectation.paramPtrs = &LoggerFmtMockDebugfParamPtrs{}
	}
	mmDebugf.defaultExpectation.paramPtrs.args = &args
	mmDebugf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmDebugf
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Debugf
func (mmDebugf *mLoggerFmtMockDebugf) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockDebugf {
	if mmDebugf.mock.inspectFuncDebugf != nil {
		mmDebugf.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Debugf")
	}

	mmDebugf.mock.inspectFuncDebugf = f

	return mmDebugf
}

// Return sets up results that will be returned by LoggerFmt.Debugf
func (mmDebugf *mLoggerFmtMockDebugf) Return() *LoggerFmtMock {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Set")
	}

	if mmDebugf.defaultExpectation == nil {
		mmDebugf.defaultExpectation = &LoggerFmtMockDebugfExpectation{mock: mmDebugf.mock}
	}

	mmDebugf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// Set uses given function f to mock the LoggerFmt.Debugf method
func (mmDebugf *mLoggerFmtMockDebugf) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmDebugf.defaultExpectation != nil {
		mmDebugf.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Debugf method")
	}

	if len(mmDebugf.expectations) > 0 {
		mmDebugf.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Debugf method")
	}

	mmDebugf.mock.funcDebugf = f
	mmDebugf.mock.funcDebugfOrigin = minimock.CallerInfo(1)
	return mmDebugf.mock
}

// When sets expectation for the LoggerFmt.Debugf which will trigger the result defined by the following
// Then helper
func (mmDebugf *mLoggerFmtMockDebugf) When(format string, args ...interface{}) *LoggerFmtMockDebugfExpectation {
	if mmDebugf.mock.funcDebugf != nil {
		mmDebugf.mock.t.Fatalf("LoggerFmtMock.Debugf mock is already set by Set")
	}

	expectation := &LoggerFmtMockDebugfExpectation{
		mock:               mmDebugf.mock,
		params:             &LoggerFmtMockDebugfParams{format, args},
		expectationOrigins: LoggerFmtMockDebugfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDebugf.expectations = append(mmDebugf.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Debugf return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockDebugfExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Debugf should be invoked
func (mmDebugf *mLoggerFmtMockDebugf) Times(n uint64) *mLoggerFmtMockDebugf {
	if n == 0 {
		mmDebugf.mock.t.Fatalf("Times of LoggerFmtMock.Debugf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDebugf.expectedInvocations, n)
	mmDebugf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDebugf
}

func (mmDebugf *mLoggerFmtMockDebugf) invocationsDone() bool {
	if len(mmDebugf.expectations) == 0 && mmDebugf.defaultExpectation == nil && mmDebugf.mock.funcDebugf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDebugf.mock.afterDebugfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDebugf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Debugf implements mm_log.LoggerFmt
func (mmDebugf *LoggerFmtMock) Debugf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmDebugf.beforeDebugfCounter, 1)
	defer mm_atomic.AddUint64(&mmDebugf.afterDebugfCounter, 1)

	mmDebugf.t.Helper()

	if mmDebugf.inspectFuncDebugf != nil {
		mmDebugf.inspectFuncDebugf(format, args...)
	}

	mm_params := LoggerFmtMockDebugfParams{format, args}

	// Record call args
	mmDebugf.DebugfMock.mutex.Lock()
	mmDebugf.DebugfMock.callArgs = append(mmDebugf.DebugfMock.callArgs, &mm_params)
	mmDebugf.DebugfMock.mutex.Unlock()

	for _, e := range mmDebugf.DebugfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebugf.DebugfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebugf.DebugfMock.defaultExpectation.Counter, 1)
		mm_want := mmDebugf.DebugfMock.defaultExpectation.params
		mm_want_ptrs := mmDebugf.DebugfMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockDebugfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmDebugf.t.Errorf("LoggerFmtMock.Debugf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmDebugf.t.Errorf("LoggerFmtMock.Debugf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebugf.t.Errorf("LoggerFmtMock.Debugf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDebugf.DebugfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebugf.funcDebugf != nil {
		mmDebugf.funcDebugf(format, args...)
		return
	}
	mmDebugf.t.Fatalf("Unexpected call to LoggerFmtMock.Debugf. %v %v", format, args)

}

// DebugfAfterCounter returns a count of finished LoggerFmtMock.Debugf invocations
func (mmDebugf *LoggerFmtMock) DebugfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.afterDebugfCounter)
}

// DebugfBeforeCounter returns a count of LoggerFmtMock.Debugf invocations
func (mmDebugf *LoggerFmtMock) DebugfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebugf.beforeDebugfCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Debugf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebugf *mLoggerFmtMockDebugf) Calls() []*LoggerFmtMockDebugfParams {
	mmDebugf.mutex.RLock()

	argCopy := make([]*LoggerFmtMockDebugfParams, len(mmDebugf.callArgs))
	copy(argCopy, mmDebugf.callArgs)

	mmDebugf.mutex.RUnlock()

	return argCopy
}

// MinimockDebugfDone returns true if the count of the Debugf invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockDebugfDone() bool {
	if m.DebugfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DebugfMock.invocationsDone()
}

// MinimockDebugfInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockDebugfInspect() {
	for _, e := range m.DebugfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Debugf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDebugfCounter := mm_atomic.LoadUint64(&m.afterDebugfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DebugfMock.defaultExpectation != nil && afterDebugfCounter < 1 {
		if m.DebugfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Debugf at\n%s", m.DebugfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Debugf at\n%s with params: %#v", m.DebugfMock.defaultExpectation.expectationOrigins.origin, *m.DebugfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebugf != nil && afterDebugfCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Debugf at\n%s", m.funcDebugfOrigin)
	}

	if !m.DebugfMock.invocationsDone() && afterDebugfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Debugf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DebugfMock.expectedInvocations), m.DebugfMock.expectedInvocationsOrigin, afterDebugfCounter)
	}
}

type mLoggerFmtMockErrorf struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockErrorfExpectation
	expectations       []*LoggerFmtMockErrorfExpectation

	callArgs []*LoggerFmtMockErrorfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockErrorfExpectation specifies expectation struct of the LoggerFmt.Errorf
type LoggerFmtMockErrorfExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockErrorfParams
	paramPtrs          *LoggerFmtMockErrorfParamPtrs
	expectationOrigins LoggerFmtMockErrorfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockErrorfParams contains parameters of the LoggerFmt.Errorf
type LoggerFmtMockErrorfParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockErrorfParamPtrs contains pointers to parameters of the LoggerFmt.Errorf
type LoggerFmtMockErrorfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockErrorfOrigins contains origins of expectations of the LoggerFmt.Errorf
type LoggerFmtMockErrorfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrorf *mLoggerFmtMockErrorf) Optional() *mLoggerFmtMockErrorf {
	mmErrorf.optional = true
	return mmErrorf
}

// Expect sets up expected params for LoggerFmt.Errorf
func (mmErrorf *mLoggerFmtMockErrorf) Expect(format string, args ...interface{}) *mLoggerFmtMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerFmtMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.paramPtrs != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by ExpectParams functions")
	}

	mmErrorf.defaultExpectation.params = &LoggerFmtMockErrorfParams{format, args}
	mmErrorf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmErrorf.expectations {
		if minimock.Equal(e.params, mmErrorf.defaultExpectation.params) {
			mmErrorf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmErrorf.defaultExpectation.params)
		}
	}

	return mmErrorf
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Errorf
func (mmErrorf *mLoggerFmtMockErrorf) ExpectFormatParam1(format string) *mLoggerFmtMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerFmtMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerFmtMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.format = &format
	mmErrorf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmErrorf
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Errorf
func (mmErrorf *mLoggerFmtMockErrorf) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockErrorf {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerFmtMockErrorfExpectation{}
	}

	if mmErrorf.defaultExpectation.params != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Expect")
	}

	if mmErrorf.defaultExpectation.paramPtrs == nil {
		mmErrorf.defaultExpectation.paramPtrs = &LoggerFmtMockErrorfParamPtrs{}
	}
	mmErrorf.defaultExpectation.paramPtrs.args = &args
	mmErrorf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmErrorf
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Errorf
func (mmErrorf *mLoggerFmtMockErrorf) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockErrorf {
	if mmErrorf.mock.inspectFuncErrorf != nil {
		mmErrorf.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Errorf")
	}

	mmErrorf.mock.inspectFuncErrorf = f

	return mmErrorf
}

// Return sets up results that will be returned by LoggerFmt.Errorf
func (mmErrorf *mLoggerFmtMockErrorf) Return() *LoggerFmtMock {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Set")
	}

	if mmErrorf.defaultExpectation == nil {
		mmErrorf.defaultExpectation = &LoggerFmtMockErrorfExpectation{mock: mmErrorf.mock}
	}

	mmErrorf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// Set uses given function f to mock the LoggerFmt.Errorf method
func (mmErrorf *mLoggerFmtMockErrorf) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmErrorf.defaultExpectation != nil {
		mmErrorf.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Errorf method")
	}

	if len(mmErrorf.expectations) > 0 {
		mmErrorf.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Errorf method")
	}

	mmErrorf.mock.funcErrorf = f
	mmErrorf.mock.funcErrorfOrigin = minimock.CallerInfo(1)
	return mmErrorf.mock
}

// When sets expectation for the LoggerFmt.Errorf which will trigger the result defined by the following
// Then helper
func (mmErrorf *mLoggerFmtMockErrorf) When(format string, args ...interface{}) *LoggerFmtMockErrorfExpectation {
	if mmErrorf.mock.funcErrorf != nil {
		mmErrorf.mock.t.Fatalf("LoggerFmtMock.Errorf mock is already set by Set")
	}

	expectation := &LoggerFmtMockErrorfExpectation{
		mock:               mmErrorf.mock,
		params:             &LoggerFmtMockErrorfParams{format, args},
		expectationOrigins: LoggerFmtMockErrorfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmErrorf.expectations = append(mmErrorf.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Errorf return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockErrorfExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Errorf should be invoked
func (mmErrorf *mLoggerFmtMockErrorf) Times(n uint64) *mLoggerFmtMockErrorf {
	if n == 0 {
		mmErrorf.mock.t.Fatalf("Times of LoggerFmtMock.Errorf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrorf.expectedInvocations, n)
	mmErrorf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErrorf
}

func (mmErrorf *mLoggerFmtMockErrorf) invocationsDone() bool {
	if len(mmErrorf.expectations) == 0 && mmErrorf.defaultExpectation == nil && mmErrorf.mock.funcErrorf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrorf.mock.afterErrorfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrorf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errorf implements mm_log.LoggerFmt
func (mmErrorf *LoggerFmtMock) Errorf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmErrorf.beforeErrorfCounter, 1)
	defer mm_atomic.AddUint64(&mmErrorf.afterErrorfCounter, 1)

	mmErrorf.t.Helper()

	if mmErrorf.inspectFuncErrorf != nil {
		mmErrorf.inspectFuncErrorf(format, args...)
	}

	mm_params := LoggerFmtMockErrorfParams{format, args}

	// Record call args
	mmErrorf.ErrorfMock.mutex.Lock()
	mmErrorf.ErrorfMock.callArgs = append(mmErrorf.ErrorfMock.callArgs, &mm_params)
	mmErrorf.ErrorfMock.mutex.Unlock()

	for _, e := range mmErrorf.ErrorfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmErrorf.ErrorfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrorf.ErrorfMock.defaultExpectation.Counter, 1)
		mm_want := mmErrorf.ErrorfMock.defaultExpectation.params
		mm_want_ptrs := mmErrorf.ErrorfMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockErrorfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmErrorf.t.Errorf("LoggerFmtMock.Errorf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmErrorf.t.Errorf("LoggerFmtMock.Errorf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmErrorf.t.Errorf("LoggerFmtMock.Errorf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmErrorf.ErrorfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmErrorf.funcErrorf != nil {
		mmErrorf.funcErrorf(format, args...)
		return
	}
	mmErrorf.t.Fatalf("Unexpected call to LoggerFmtMock.Errorf. %v %v", format, args)

}

// ErrorfAfterCounter returns a count of finished LoggerFmtMock.Errorf invocations
func (mmErrorf *LoggerFmtMock) ErrorfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.afterErrorfCounter)
}

// ErrorfBeforeCounter returns a count of LoggerFmtMock.Errorf invocations
func (mmErrorf *LoggerFmtMock) ErrorfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrorf.beforeErrorfCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Errorf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmErrorf *mLoggerFmtMockErrorf) Calls() []*LoggerFmtMockErrorfParams {
	mmErrorf.mutex.RLock()

	argCopy := make([]*LoggerFmtMockErrorfParams, len(mmErrorf.callArgs))
	copy(argCopy, mmErrorf.callArgs)

	mmErrorf.mutex.RUnlock()

	return argCopy
}

// MinimockErrorfDone returns true if the count of the Errorf invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockErrorfDone() bool {
	if m.ErrorfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorfMock.invocationsDone()
}

// MinimockErrorfInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockErrorfInspect() {
	for _, e := range m.ErrorfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Errorf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterErrorfCounter := mm_atomic.LoadUint64(&m.afterErrorfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorfMock.defaultExpectation != nil && afterErrorfCounter < 1 {
		if m.ErrorfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Errorf at\n%s", m.ErrorfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Errorf at\n%s with params: %#v", m.ErrorfMock.defaultExpectation.expectationOrigins.origin, *m.ErrorfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrorf != nil && afterErrorfCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Errorf at\n%s", m.funcErrorfOrigin)
	}

	if !m.ErrorfMock.invocationsDone() && afterErrorfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Errorf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorfMock.expectedInvocations), m.ErrorfMock.expectedInvocationsOrigin, afterErrorfCounter)
	}
}

type mLoggerFmtMockFatalf struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockFatalfExpectation
	expectations       []*LoggerFmtMockFatalfExpectation

	callArgs []*LoggerFmtMockFatalfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockFatalfExpectation specifies expectation struct of the LoggerFmt.Fatalf
type LoggerFmtMockFatalfExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockFatalfParams
	paramPtrs          *LoggerFmtMockFatalfParamPtrs
	expectationOrigins LoggerFmtMockFatalfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockFatalfParams contains parameters of the LoggerFmt.Fatalf
type LoggerFmtMockFatalfParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockFatalfParamPtrs contains pointers to parameters of the LoggerFmt.Fatalf
type LoggerFmtMockFatalfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockFatalfOrigins contains origins of expectations of the LoggerFmt.Fatalf
type LoggerFmtMockFatalfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFatalf *mLoggerFmtMockFatalf) Optional() *mLoggerFmtMockFatalf {
	mmFatalf.optional = true
	return mmFatalf
}

// Expect sets up expected params for LoggerFmt.Fatalf
func (mmFatalf *mLoggerFmtMockFatalf) Expect(format string, args ...interface{}) *mLoggerFmtMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerFmtMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.paramPtrs != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by ExpectParams functions")
	}

	mmFatalf.defaultExpectation.params = &LoggerFmtMockFatalfParams{format, args}
	mmFatalf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFatalf.expectations {
		if minimock.Equal(e.params, mmFatalf.defaultExpectation.params) {
			mmFatalf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatalf.defaultExpectation.params)
		}
	}

	return mmFatalf
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Fatalf
func (mmFatalf *mLoggerFmtMockFatalf) ExpectFormatParam1(format string) *mLoggerFmtMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerFmtMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerFmtMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.format = &format
	mmFatalf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmFatalf
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Fatalf
func (mmFatalf *mLoggerFmtMockFatalf) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockFatalf {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerFmtMockFatalfExpectation{}
	}

	if mmFatalf.defaultExpectation.params != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Expect")
	}

	if mmFatalf.defaultExpectation.paramPtrs == nil {
		mmFatalf.defaultExpectation.paramPtrs = &LoggerFmtMockFatalfParamPtrs{}
	}
	mmFatalf.defaultExpectation.paramPtrs.args = &args
	mmFatalf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmFatalf
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Fatalf
func (mmFatalf *mLoggerFmtMockFatalf) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockFatalf {
	if mmFatalf.mock.inspectFuncFatalf != nil {
		mmFatalf.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Fatalf")
	}

	mmFatalf.mock.inspectFuncFatalf = f

	return mmFatalf
}

// Return sets up results that will be returned by LoggerFmt.Fatalf
func (mmFatalf *mLoggerFmtMockFatalf) Return() *LoggerFmtMock {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Set")
	}

	if mmFatalf.defaultExpectation == nil {
		mmFatalf.defaultExpectation = &LoggerFmtMockFatalfExpectation{mock: mmFatalf.mock}
	}

	mmFatalf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFatalf.mock
}

// Set uses given function f to mock the LoggerFmt.Fatalf method
func (mmFatalf *mLoggerFmtMockFatalf) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmFatalf.defaultExpectation != nil {
		mmFatalf.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Fatalf method")
	}

	if len(mmFatalf.expectations) > 0 {
		mmFatalf.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Fatalf method")
	}

	mmFatalf.mock.funcFatalf = f
	mmFatalf.mock.funcFatalfOrigin = minimock.CallerInfo(1)
	return mmFatalf.mock
}

// When sets expectation for the LoggerFmt.Fatalf which will trigger the result defined by the following
// Then helper
func (mmFatalf *mLoggerFmtMockFatalf) When(format string, args ...interface{}) *LoggerFmtMockFatalfExpectation {
	if mmFatalf.mock.funcFatalf != nil {
		mmFatalf.mock.t.Fatalf("LoggerFmtMock.Fatalf mock is already set by Set")
	}

	expectation := &LoggerFmtMockFatalfExpectation{
		mock:               mmFatalf.mock,
		params:             &LoggerFmtMockFatalfParams{format, args},
		expectationOrigins: LoggerFmtMockFatalfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFatalf.expectations = append(mmFatalf.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Fatalf return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockFatalfExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Fatalf should be invoked
func (mmFatalf *mLoggerFmtMockFatalf) Times(n uint64) *mLoggerFmtMockFatalf {
	if n == 0 {
		mmFatalf.mock.t.Fatalf("Times of LoggerFmtMock.Fatalf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFatalf.expectedInvocations, n)
	mmFatalf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFatalf
}

func (mmFatalf *mLoggerFmtMockFatalf) invocationsDone() bool {
	if len(mmFatalf.expectations) == 0 && mmFatalf.defaultExpectation == nil && mmFatalf.mock.funcFatalf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFatalf.mock.afterFatalfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFatalf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fatalf implements mm_log.LoggerFmt
func (mmFatalf *LoggerFmtMock) Fatalf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmFatalf.beforeFatalfCounter, 1)
	defer mm_atomic.AddUint64(&mmFatalf.afterFatalfCounter, 1)

	mmFatalf.t.Helper()

	if mmFatalf.inspectFuncFatalf != nil {
		mmFatalf.inspectFuncFatalf(format, args...)
	}

	mm_params := LoggerFmtMockFatalfParams{format, args}

	// Record call args
	mmFatalf.FatalfMock.mutex.Lock()
	mmFatalf.FatalfMock.callArgs = append(mmFatalf.FatalfMock.callArgs, &mm_params)
	mmFatalf.FatalfMock.mutex.Unlock()

	for _, e := range mmFatalf.FatalfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatalf.FatalfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatalf.FatalfMock.defaultExpectation.Counter, 1)
		mm_want := mmFatalf.FatalfMock.defaultExpectation.params
		mm_want_ptrs := mmFatalf.FatalfMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockFatalfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmFatalf.t.Errorf("LoggerFmtMock.Fatalf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmFatalf.t.Errorf("LoggerFmtMock.Fatalf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatalf.t.Errorf("LoggerFmtMock.Fatalf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFatalf.FatalfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatalf.funcFatalf != nil {
		mmFatalf.funcFatalf(format, args...)
		return
	}
	mmFatalf.t.Fatalf("Unexpected call to LoggerFmtMock.Fatalf. %v %v", format, args)

}

// FatalfAfterCounter returns a count of finished LoggerFmtMock.Fatalf invocations
func (mmFatalf *LoggerFmtMock) FatalfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.afterFatalfCounter)
}

// FatalfBeforeCounter returns a count of LoggerFmtMock.Fatalf invocations
func (mmFatalf *LoggerFmtMock) FatalfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatalf.beforeFatalfCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Fatalf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatalf *mLoggerFmtMockFatalf) Calls() []*LoggerFmtMockFatalfParams {
	mmFatalf.mutex.RLock()

	argCopy := make([]*LoggerFmtMockFatalfParams, len(mmFatalf.callArgs))
	copy(argCopy, mmFatalf.callArgs)

	mmFatalf.mutex.RUnlock()

	return argCopy
}

// MinimockFatalfDone returns true if the count of the Fatalf invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockFatalfDone() bool {
	if m.FatalfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FatalfMock.invocationsDone()
}

// MinimockFatalfInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockFatalfInspect() {
	for _, e := range m.FatalfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Fatalf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFatalfCounter := mm_atomic.LoadUint64(&m.afterFatalfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FatalfMock.defaultExpectation != nil && afterFatalfCounter < 1 {
		if m.FatalfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Fatalf at\n%s", m.FatalfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Fatalf at\n%s with params: %#v", m.FatalfMock.defaultExpectation.expectationOrigins.origin, *m.FatalfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatalf != nil && afterFatalfCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Fatalf at\n%s", m.funcFatalfOrigin)
	}

	if !m.FatalfMock.invocationsDone() && afterFatalfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Fatalf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FatalfMock.expectedInvocations), m.FatalfMock.expectedInvocationsOrigin, afterFatalfCounter)
	}
}

type mLoggerFmtMockInfof struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockInfofExpectation
	expectations       []*LoggerFmtMockInfofExpectation

	callArgs []*LoggerFmtMockInfofParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockInfofExpectation specifies expectation struct of the LoggerFmt.Infof
type LoggerFmtMockInfofExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockInfofParams
	paramPtrs          *LoggerFmtMockInfofParamPtrs
	expectationOrigins LoggerFmtMockInfofExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockInfofParams contains parameters of the LoggerFmt.Infof
type LoggerFmtMockInfofParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockInfofParamPtrs contains pointers to parameters of the LoggerFmt.Infof
type LoggerFmtMockInfofParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockInfofOrigins contains origins of expectations of the LoggerFmt.Infof
type LoggerFmtMockInfofExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInfof *mLoggerFmtMockInfof) Optional() *mLoggerFmtMockInfof {
	mmInfof.optional = true
	return mmInfof
}

// Expect sets up expected params for LoggerFmt.Infof
func (mmInfof *mLoggerFmtMockInfof) Expect(format string, args ...interface{}) *mLoggerFmtMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerFmtMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.paramPtrs != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by ExpectParams functions")
	}

	mmInfof.defaultExpectation.params = &LoggerFmtMockInfofParams{format, args}
	mmInfof.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInfof.expectations {
		if minimock.Equal(e.params, mmInfof.defaultExpectation.params) {
			mmInfof.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfof.defaultExpectation.params)
		}
	}

	return mmInfof
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Infof
func (mmInfof *mLoggerFmtMockInfof) ExpectFormatParam1(format string) *mLoggerFmtMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerFmtMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerFmtMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.format = &format
	mmInfof.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmInfof
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Infof
func (mmInfof *mLoggerFmtMockInfof) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockInfof {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerFmtMockInfofExpectation{}
	}

	if mmInfof.defaultExpectation.params != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Expect")
	}

	if mmInfof.defaultExpectation.paramPtrs == nil {
		mmInfof.defaultExpectation.paramPtrs = &LoggerFmtMockInfofParamPtrs{}
	}
	mmInfof.defaultExpectation.paramPtrs.args = &args
	mmInfof.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmInfof
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Infof
func (mmInfof *mLoggerFmtMockInfof) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockInfof {
	if mmInfof.mock.inspectFuncInfof != nil {
		mmInfof.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Infof")
	}

	mmInfof.mock.inspectFuncInfof = f

	return mmInfof
}

// Return sets up results that will be returned by LoggerFmt.Infof
func (mmInfof *mLoggerFmtMockInfof) Return() *LoggerFmtMock {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Set")
	}

	if mmInfof.defaultExpectation == nil {
		mmInfof.defaultExpectation = &LoggerFmtMockInfofExpectation{mock: mmInfof.mock}
	}

	mmInfof.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// Set uses given function f to mock the LoggerFmt.Infof method
func (mmInfof *mLoggerFmtMockInfof) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmInfof.defaultExpectation != nil {
		mmInfof.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Infof method")
	}

	if len(mmInfof.expectations) > 0 {
		mmInfof.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Infof method")
	}

	mmInfof.mock.funcInfof = f
	mmInfof.mock.funcInfofOrigin = minimock.CallerInfo(1)
	return mmInfof.mock
}

// When sets expectation for the LoggerFmt.Infof which will trigger the result defined by the following
// Then helper
func (mmInfof *mLoggerFmtMockInfof) When(format string, args ...interface{}) *LoggerFmtMockInfofExpectation {
	if mmInfof.mock.funcInfof != nil {
		mmInfof.mock.t.Fatalf("LoggerFmtMock.Infof mock is already set by Set")
	}

	expectation := &LoggerFmtMockInfofExpectation{
		mock:               mmInfof.mock,
		params:             &LoggerFmtMockInfofParams{format, args},
		expectationOrigins: LoggerFmtMockInfofExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInfof.expectations = append(mmInfof.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Infof return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockInfofExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Infof should be invoked
func (mmInfof *mLoggerFmtMockInfof) Times(n uint64) *mLoggerFmtMockInfof {
	if n == 0 {
		mmInfof.mock.t.Fatalf("Times of LoggerFmtMock.Infof mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInfof.expectedInvocations, n)
	mmInfof.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInfof
}

func (mmInfof *mLoggerFmtMockInfof) invocationsDone() bool {
	if len(mmInfof.expectations) == 0 && mmInfof.defaultExpectation == nil && mmInfof.mock.funcInfof == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInfof.mock.afterInfofCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInfof.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Infof implements mm_log.LoggerFmt
func (mmInfof *LoggerFmtMock) Infof(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmInfof.beforeInfofCounter, 1)
	defer mm_atomic.AddUint64(&mmInfof.afterInfofCounter, 1)

	mmInfof.t.Helper()

	if mmInfof.inspectFuncInfof != nil {
		mmInfof.inspectFuncInfof(format, args...)
	}

	mm_params := LoggerFmtMockInfofParams{format, args}

	// Record call args
	mmInfof.InfofMock.mutex.Lock()
	mmInfof.InfofMock.callArgs = append(mmInfof.InfofMock.callArgs, &mm_params)
	mmInfof.InfofMock.mutex.Unlock()

	for _, e := range mmInfof.InfofMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfof.InfofMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfof.InfofMock.defaultExpectation.Counter, 1)
		mm_want := mmInfof.InfofMock.defaultExpectation.params
		mm_want_ptrs := mmInfof.InfofMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockInfofParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmInfof.t.Errorf("LoggerFmtMock.Infof got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmInfof.t.Errorf("LoggerFmtMock.Infof got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInfof.InfofMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfof.t.Errorf("LoggerFmtMock.Infof got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInfof.InfofMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfof.funcInfof != nil {
		mmInfof.funcInfof(format, args...)
		return
	}
	mmInfof.t.Fatalf("Unexpected call to LoggerFmtMock.Infof. %v %v", format, args)

}

// InfofAfterCounter returns a count of finished LoggerFmtMock.Infof invocations
func (mmInfof *LoggerFmtMock) InfofAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.afterInfofCounter)
}

// InfofBeforeCounter returns a count of LoggerFmtMock.Infof invocations
func (mmInfof *LoggerFmtMock) InfofBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfof.beforeInfofCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Infof.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfof *mLoggerFmtMockInfof) Calls() []*LoggerFmtMockInfofParams {
	mmInfof.mutex.RLock()

	argCopy := make([]*LoggerFmtMockInfofParams, len(mmInfof.callArgs))
	copy(argCopy, mmInfof.callArgs)

	mmInfof.mutex.RUnlock()

	return argCopy
}

// MinimockInfofDone returns true if the count of the Infof invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockInfofDone() bool {
	if m.InfofMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InfofMock.invocationsDone()
}

// MinimockInfofInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockInfofInspect() {
	for _, e := range m.InfofMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Infof at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInfofCounter := mm_atomic.LoadUint64(&m.afterInfofCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InfofMock.defaultExpectation != nil && afterInfofCounter < 1 {
		if m.InfofMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Infof at\n%s", m.InfofMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Infof at\n%s with params: %#v", m.InfofMock.defaultExpectation.expectationOrigins.origin, *m.InfofMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfof != nil && afterInfofCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Infof at\n%s", m.funcInfofOrigin)
	}

	if !m.InfofMock.invocationsDone() && afterInfofCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Infof at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InfofMock.expectedInvocations), m.InfofMock.expectedInvocationsOrigin, afterInfofCounter)
	}
}

type mLoggerFmtMockTracef struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockTracefExpectation
	expectations       []*LoggerFmtMockTracefExpectation

	callArgs []*LoggerFmtMockTracefParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockTracefExpectation specifies expectation struct of the LoggerFmt.Tracef
type LoggerFmtMockTracefExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockTracefParams
	paramPtrs          *LoggerFmtMockTracefParamPtrs
	expectationOrigins LoggerFmtMockTracefExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockTracefParams contains parameters of the LoggerFmt.Tracef
type LoggerFmtMockTracefParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockTracefParamPtrs contains pointers to parameters of the LoggerFmt.Tracef
type LoggerFmtMockTracefParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockTracefOrigins contains origins of expectations of the LoggerFmt.Tracef
type LoggerFmtMockTracefExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTracef *mLoggerFmtMockTracef) Optional() *mLoggerFmtMockTracef {
	mmTracef.optional = true
	return mmTracef
}

// Expect sets up expected params for LoggerFmt.Tracef
func (mmTracef *mLoggerFmtMockTracef) Expect(format string, args ...interface{}) *mLoggerFmtMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerFmtMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.paramPtrs != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by ExpectParams functions")
	}

	mmTracef.defaultExpectation.params = &LoggerFmtMockTracefParams{format, args}
	mmTracef.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTracef.expectations {
		if minimock.Equal(e.params, mmTracef.defaultExpectation.params) {
			mmTracef.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTracef.defaultExpectation.params)
		}
	}

	return mmTracef
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Tracef
func (mmTracef *mLoggerFmtMockTracef) ExpectFormatParam1(format string) *mLoggerFmtMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerFmtMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.params != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Expect")
	}

	if mmTracef.defaultExpectation.paramPtrs == nil {
		mmTracef.defaultExpectation.paramPtrs = &LoggerFmtMockTracefParamPtrs{}
	}
	mmTracef.defaultExpectation.paramPtrs.format = &format
	mmTracef.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmTracef
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Tracef
func (mmTracef *mLoggerFmtMockTracef) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockTracef {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerFmtMockTracefExpectation{}
	}

	if mmTracef.defaultExpectation.params != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Expect")
	}

	if mmTracef.defaultExpectation.paramPtrs == nil {
		mmTracef.defaultExpectation.paramPtrs = &LoggerFmtMockTracefParamPtrs{}
	}
	mmTracef.defaultExpectation.paramPtrs.args = &args
	mmTracef.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmTracef
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Tracef
func (mmTracef *mLoggerFmtMockTracef) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockTracef {
	if mmTracef.mock.inspectFuncTracef != nil {
		mmTracef.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Tracef")
	}

	mmTracef.mock.inspectFuncTracef = f

	return mmTracef
}

// Return sets up results that will be returned by LoggerFmt.Tracef
func (mmTracef *mLoggerFmtMockTracef) Return() *LoggerFmtMock {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Set")
	}

	if mmTracef.defaultExpectation == nil {
		mmTracef.defaultExpectation = &LoggerFmtMockTracefExpectation{mock: mmTracef.mock}
	}

	mmTracef.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTracef.mock
}

// Set uses given function f to mock the LoggerFmt.Tracef method
func (mmTracef *mLoggerFmtMockTracef) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmTracef.defaultExpectation != nil {
		mmTracef.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Tracef method")
	}

	if len(mmTracef.expectations) > 0 {
		mmTracef.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Tracef method")
	}

	mmTracef.mock.funcTracef = f
	mmTracef.mock.funcTracefOrigin = minimock.CallerInfo(1)
	return mmTracef.mock
}

// When sets expectation for the LoggerFmt.Tracef which will trigger the result defined by the following
// Then helper
func (mmTracef *mLoggerFmtMockTracef) When(format string, args ...interface{}) *LoggerFmtMockTracefExpectation {
	if mmTracef.mock.funcTracef != nil {
		mmTracef.mock.t.Fatalf("LoggerFmtMock.Tracef mock is already set by Set")
	}

	expectation := &LoggerFmtMockTracefExpectation{
		mock:               mmTracef.mock,
		params:             &LoggerFmtMockTracefParams{format, args},
		expectationOrigins: LoggerFmtMockTracefExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTracef.expectations = append(mmTracef.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Tracef return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockTracefExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Tracef should be invoked
func (mmTracef *mLoggerFmtMockTracef) Times(n uint64) *mLoggerFmtMockTracef {
	if n == 0 {
		mmTracef.mock.t.Fatalf("Times of LoggerFmtMock.Tracef mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTracef.expectedInvocations, n)
	mmTracef.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTracef
}

func (mmTracef *mLoggerFmtMockTracef) invocationsDone() bool {
	if len(mmTracef.expectations) == 0 && mmTracef.defaultExpectation == nil && mmTracef.mock.funcTracef == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTracef.mock.afterTracefCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTracef.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Tracef implements mm_log.LoggerFmt
func (mmTracef *LoggerFmtMock) Tracef(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmTracef.beforeTracefCounter, 1)
	defer mm_atomic.AddUint64(&mmTracef.afterTracefCounter, 1)

	mmTracef.t.Helper()

	if mmTracef.inspectFuncTracef != nil {
		mmTracef.inspectFuncTracef(format, args...)
	}

	mm_params := LoggerFmtMockTracefParams{format, args}

	// Record call args
	mmTracef.TracefMock.mutex.Lock()
	mmTracef.TracefMock.callArgs = append(mmTracef.TracefMock.callArgs, &mm_params)
	mmTracef.TracefMock.mutex.Unlock()

	for _, e := range mmTracef.TracefMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmTracef.TracefMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTracef.TracefMock.defaultExpectation.Counter, 1)
		mm_want := mmTracef.TracefMock.defaultExpectation.params
		mm_want_ptrs := mmTracef.TracefMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockTracefParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmTracef.t.Errorf("LoggerFmtMock.Tracef got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTracef.TracefMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmTracef.t.Errorf("LoggerFmtMock.Tracef got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTracef.TracefMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTracef.t.Errorf("LoggerFmtMock.Tracef got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTracef.TracefMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmTracef.funcTracef != nil {
		mmTracef.funcTracef(format, args...)
		return
	}
	mmTracef.t.Fatalf("Unexpected call to LoggerFmtMock.Tracef. %v %v", format, args)

}

// TracefAfterCounter returns a count of finished LoggerFmtMock.Tracef invocations
func (mmTracef *LoggerFmtMock) TracefAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracef.afterTracefCounter)
}

// TracefBeforeCounter returns a count of LoggerFmtMock.Tracef invocations
func (mmTracef *LoggerFmtMock) TracefBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTracef.beforeTracefCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Tracef.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTracef *mLoggerFmtMockTracef) Calls() []*LoggerFmtMockTracefParams {
	mmTracef.mutex.RLock()

	argCopy := make([]*LoggerFmtMockTracefParams, len(mmTracef.callArgs))
	copy(argCopy, mmTracef.callArgs)

	mmTracef.mutex.RUnlock()

	return argCopy
}

// MinimockTracefDone returns true if the count of the Tracef invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockTracefDone() bool {
	if m.TracefMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TracefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TracefMock.invocationsDone()
}

// MinimockTracefInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockTracefInspect() {
	for _, e := range m.TracefMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Tracef at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTracefCounter := mm_atomic.LoadUint64(&m.afterTracefCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TracefMock.defaultExpectation != nil && afterTracefCounter < 1 {
		if m.TracefMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Tracef at\n%s", m.TracefMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Tracef at\n%s with params: %#v", m.TracefMock.defaultExpectation.expectationOrigins.origin, *m.TracefMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTracef != nil && afterTracefCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Tracef at\n%s", m.funcTracefOrigin)
	}

	if !m.TracefMock.invocationsDone() && afterTracefCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Tracef at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TracefMock.expectedInvocations), m.TracefMock.expectedInvocationsOrigin, afterTracefCounter)
	}
}

type mLoggerFmtMockWarnf struct {
	optional           bool
	mock               *LoggerFmtMock
	defaultExpectation *LoggerFmtMockWarnfExpectation
	expectations       []*LoggerFmtMockWarnfExpectation

	callArgs []*LoggerFmtMockWarnfParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LoggerFmtMockWarnfExpectation specifies expectation struct of the LoggerFmt.Warnf
type LoggerFmtMockWarnfExpectation struct {
	mock               *LoggerFmtMock
	params             *LoggerFmtMockWarnfParams
	paramPtrs          *LoggerFmtMockWarnfParamPtrs
	expectationOrigins LoggerFmtMockWarnfExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// LoggerFmtMockWarnfParams contains parameters of the LoggerFmt.Warnf
type LoggerFmtMockWarnfParams struct {
	format string
	args   []interface{}
}

// LoggerFmtMockWarnfParamPtrs contains pointers to parameters of the LoggerFmt.Warnf
type LoggerFmtMockWarnfParamPtrs struct {
	format *string
	args   *[]interface{}
}

// LoggerFmtMockWarnfOrigins contains origins of expectations of the LoggerFmt.Warnf
type LoggerFmtMockWarnfExpectationOrigins struct {
	origin       string
	originFormat string
	originArgs   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWarnf *mLoggerFmtMockWarnf) Optional() *mLoggerFmtMockWarnf {
	mmWarnf.optional = true
	return mmWarnf
}

// Expect sets up expected params for LoggerFmt.Warnf
func (mmWarnf *mLoggerFmtMockWarnf) Expect(format string, args ...interface{}) *mLoggerFmtMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerFmtMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.paramPtrs != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by ExpectParams functions")
	}

	mmWarnf.defaultExpectation.params = &LoggerFmtMockWarnfParams{format, args}
	mmWarnf.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWarnf.expectations {
		if minimock.Equal(e.params, mmWarnf.defaultExpectation.params) {
			mmWarnf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarnf.defaultExpectation.params)
		}
	}

	return mmWarnf
}

// ExpectFormatParam1 sets up expected param format for LoggerFmt.Warnf
func (mmWarnf *mLoggerFmtMockWarnf) ExpectFormatParam1(format string) *mLoggerFmtMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerFmtMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerFmtMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.format = &format
	mmWarnf.defaultExpectation.expectationOrigins.originFormat = minimock.CallerInfo(1)

	return mmWarnf
}

// ExpectArgsParam2 sets up expected param args for LoggerFmt.Warnf
func (mmWarnf *mLoggerFmtMockWarnf) ExpectArgsParam2(args ...interface{}) *mLoggerFmtMockWarnf {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerFmtMockWarnfExpectation{}
	}

	if mmWarnf.defaultExpectation.params != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Expect")
	}

	if mmWarnf.defaultExpectation.paramPtrs == nil {
		mmWarnf.defaultExpectation.paramPtrs = &LoggerFmtMockWarnfParamPtrs{}
	}
	mmWarnf.defaultExpectation.paramPtrs.args = &args
	mmWarnf.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmWarnf
}

// Inspect accepts an inspector function that has same arguments as the LoggerFmt.Warnf
func (mmWarnf *mLoggerFmtMockWarnf) Inspect(f func(format string, args ...interface{})) *mLoggerFmtMockWarnf {
	if mmWarnf.mock.inspectFuncWarnf != nil {
		mmWarnf.mock.t.Fatalf("Inspect function is already set for LoggerFmtMock.Warnf")
	}

	mmWarnf.mock.inspectFuncWarnf = f

	return mmWarnf
}

// Return sets up results that will be returned by LoggerFmt.Warnf
func (mmWarnf *mLoggerFmtMockWarnf) Return() *LoggerFmtMock {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Set")
	}

	if mmWarnf.defaultExpectation == nil {
		mmWarnf.defaultExpectation = &LoggerFmtMockWarnfExpectation{mock: mmWarnf.mock}
	}

	mmWarnf.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// Set uses given function f to mock the LoggerFmt.Warnf method
func (mmWarnf *mLoggerFmtMockWarnf) Set(f func(format string, args ...interface{})) *LoggerFmtMock {
	if mmWarnf.defaultExpectation != nil {
		mmWarnf.mock.t.Fatalf("Default expectation is already set for the LoggerFmt.Warnf method")
	}

	if len(mmWarnf.expectations) > 0 {
		mmWarnf.mock.t.Fatalf("Some expectations are already set for the LoggerFmt.Warnf method")
	}

	mmWarnf.mock.funcWarnf = f
	mmWarnf.mock.funcWarnfOrigin = minimock.CallerInfo(1)
	return mmWarnf.mock
}

// When sets expectation for the LoggerFmt.Warnf which will trigger the result defined by the following
// Then helper
func (mmWarnf *mLoggerFmtMockWarnf) When(format string, args ...interface{}) *LoggerFmtMockWarnfExpectation {
	if mmWarnf.mock.funcWarnf != nil {
		mmWarnf.mock.t.Fatalf("LoggerFmtMock.Warnf mock is already set by Set")
	}

	expectation := &LoggerFmtMockWarnfExpectation{
		mock:               mmWarnf.mock,
		params:             &LoggerFmtMockWarnfParams{format, args},
		expectationOrigins: LoggerFmtMockWarnfExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWarnf.expectations = append(mmWarnf.expectations, expectation)
	return expectation
}

// Then sets up LoggerFmt.Warnf return parameters for the expectation previously defined by the When method

func (e *LoggerFmtMockWarnfExpectation) Then() *LoggerFmtMock {
	return e.mock
}

// Times sets number of times LoggerFmt.Warnf should be invoked
func (mmWarnf *mLoggerFmtMockWarnf) Times(n uint64) *mLoggerFmtMockWarnf {
	if n == 0 {
		mmWarnf.mock.t.Fatalf("Times of LoggerFmtMock.Warnf mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWarnf.expectedInvocations, n)
	mmWarnf.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWarnf
}

func (mmWarnf *mLoggerFmtMockWarnf) invocationsDone() bool {
	if len(mmWarnf.expectations) == 0 && mmWarnf.defaultExpectation == nil && mmWarnf.mock.funcWarnf == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWarnf.mock.afterWarnfCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWarnf.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Warnf implements mm_log.LoggerFmt
func (mmWarnf *LoggerFmtMock) Warnf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmWarnf.beforeWarnfCounter, 1)
	defer mm_atomic.AddUint64(&mmWarnf.afterWarnfCounter, 1)

	mmWarnf.t.Helper()

	if mmWarnf.inspectFuncWarnf != nil {
		mmWarnf.inspectFuncWarnf(format, args...)
	}

	mm_params := LoggerFmtMockWarnfParams{format, args}

	// Record call args
	mmWarnf.WarnfMock.mutex.Lock()
	mmWarnf.WarnfMock.callArgs = append(mmWarnf.WarnfMock.callArgs, &mm_params)
	mmWarnf.WarnfMock.mutex.Unlock()

	for _, e := range mmWarnf.WarnfMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarnf.WarnfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarnf.WarnfMock.defaultExpectation.Counter, 1)
		mm_want := mmWarnf.WarnfMock.defaultExpectation.params
		mm_want_ptrs := mmWarnf.WarnfMock.defaultExpectation.paramPtrs

		mm_got := LoggerFmtMockWarnfParams{format, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.format != nil && !minimock.Equal(*mm_want_ptrs.format, mm_got.format) {
				mmWarnf.t.Errorf("LoggerFmtMock.Warnf got unexpected parameter format, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originFormat, *mm_want_ptrs.format, mm_got.format, minimock.Diff(*mm_want_ptrs.format, mm_got.format))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmWarnf.t.Errorf("LoggerFmtMock.Warnf got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarnf.t.Errorf("LoggerFmtMock.Warnf got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWarnf.WarnfMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarnf.funcWarnf != nil {
		mmWarnf.funcWarnf(format, args...)
		return
	}
	mmWarnf.t.Fatalf("Unexpected call to LoggerFmtMock.Warnf. %v %v", format, args)

}

// WarnfAfterCounter returns a count of finished LoggerFmtMock.Warnf invocations
func (mmWarnf *LoggerFmtMock) WarnfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.afterWarnfCounter)
}

// WarnfBeforeCounter returns a count of LoggerFmtMock.Warnf invocations
func (mmWarnf *LoggerFmtMock) WarnfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarnf.beforeWarnfCounter)
}

// Calls returns a list of arguments used in each call to LoggerFmtMock.Warnf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarnf *mLoggerFmtMockWarnf) Calls() []*LoggerFmtMockWarnfParams {
	mmWarnf.mutex.RLock()

	argCopy := make([]*LoggerFmtMockWarnfParams, len(mmWarnf.callArgs))
	copy(argCopy, mmWarnf.callArgs)

	mmWarnf.mutex.RUnlock()

	return argCopy
}

// MinimockWarnfDone returns true if the count of the Warnf invocations corresponds
// the number of defined expectations
func (m *LoggerFmtMock) MinimockWarnfDone() bool {
	if m.WarnfMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WarnfMock.invocationsDone()
}

// MinimockWarnfInspect logs each unmet expectation
func (m *LoggerFmtMock) MinimockWarnfInspect() {
	for _, e := range m.WarnfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoggerFmtMock.Warnf at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWarnfCounter := mm_atomic.LoadUint64(&m.afterWarnfCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WarnfMock.defaultExpectation != nil && afterWarnfCounter < 1 {
		if m.WarnfMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LoggerFmtMock.Warnf at\n%s", m.WarnfMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LoggerFmtMock.Warnf at\n%s with params: %#v", m.WarnfMock.defaultExpectation.expectationOrigins.origin, *m.WarnfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarnf != nil && afterWarnfCounter < 1 {
		m.t.Errorf("Expected call to LoggerFmtMock.Warnf at\n%s", m.funcWarnfOrigin)
	}

	if !m.WarnfMock.invocationsDone() && afterWarnfCounter > 0 {
		m.t.Errorf("Expected %d calls to LoggerFmtMock.Warnf at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WarnfMock.expectedInvocations), m.WarnfMock.expectedInvocationsOrigin, afterWarnfCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoggerFmtMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDebugfInspect()

			m.MinimockErrorfInspect()

			m.MinimockFatalfInspect()

			m.MinimockInfofInspect()

			m.MinimockTracefInspect()

			m.MinimockWarnfInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoggerFmtMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoggerFmtMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugfDone() &&
		m.MinimockErrorfDone() &&
		m.MinimockFatalfDone() &&
		m.MinimockInfofDone() &&
		m.MinimockTracefDone() &&
		m.MinimockWarnfDone()
}
