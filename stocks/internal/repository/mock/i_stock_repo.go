// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i stocks/internal/repository.IStockRepo -o i_stock_repo.go -n IStockRepoMock -p mock

import (
	"context"
	"stocks/internal/models"
	mm_repository "stocks/internal/repository"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IStockRepoMock implements mm_repository.IStockRepo
type IStockRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddStock          func(ctx context.Context, stock models.Stock) (err error)
	funcAddStockOrigin    string
	inspectFuncAddStock   func(ctx context.Context, stock models.Stock)
	afterAddStockCounter  uint64
	beforeAddStockCounter uint64
	AddStockMock          mIStockRepoMockAddStock

	funcDeleteStock          func(ctx context.Context, skuID models.SKUID, userID models.UserID) (err error)
	funcDeleteStockOrigin    string
	inspectFuncDeleteStock   func(ctx context.Context, skuID models.SKUID, userID models.UserID)
	afterDeleteStockCounter  uint64
	beforeDeleteStockCounter uint64
	DeleteStockMock          mIStockRepoMockDeleteStock

	funcGetItemBySKU          func(ctx context.Context, skuID models.SKUID) (i1 models.Item, err error)
	funcGetItemBySKUOrigin    string
	inspectFuncGetItemBySKU   func(ctx context.Context, skuID models.SKUID)
	afterGetItemBySKUCounter  uint64
	beforeGetItemBySKUCounter uint64
	GetItemBySKUMock          mIStockRepoMockGetItemBySKU

	funcGetItemsByLocation          func(ctx context.Context, param mm_repository.GetStockByLocation) (ia1 []models.Item, err error)
	funcGetItemsByLocationOrigin    string
	inspectFuncGetItemsByLocation   func(ctx context.Context, param mm_repository.GetStockByLocation)
	afterGetItemsByLocationCounter  uint64
	beforeGetItemsByLocationCounter uint64
	GetItemsByLocationMock          mIStockRepoMockGetItemsByLocation

	funcUpdateStock          func(ctx context.Context, stock models.Stock) (err error)
	funcUpdateStockOrigin    string
	inspectFuncUpdateStock   func(ctx context.Context, stock models.Stock)
	afterUpdateStockCounter  uint64
	beforeUpdateStockCounter uint64
	UpdateStockMock          mIStockRepoMockUpdateStock
}

// NewIStockRepoMock returns a mock for mm_repository.IStockRepo
func NewIStockRepoMock(t minimock.Tester) *IStockRepoMock {
	m := &IStockRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddStockMock = mIStockRepoMockAddStock{mock: m}
	m.AddStockMock.callArgs = []*IStockRepoMockAddStockParams{}

	m.DeleteStockMock = mIStockRepoMockDeleteStock{mock: m}
	m.DeleteStockMock.callArgs = []*IStockRepoMockDeleteStockParams{}

	m.GetItemBySKUMock = mIStockRepoMockGetItemBySKU{mock: m}
	m.GetItemBySKUMock.callArgs = []*IStockRepoMockGetItemBySKUParams{}

	m.GetItemsByLocationMock = mIStockRepoMockGetItemsByLocation{mock: m}
	m.GetItemsByLocationMock.callArgs = []*IStockRepoMockGetItemsByLocationParams{}

	m.UpdateStockMock = mIStockRepoMockUpdateStock{mock: m}
	m.UpdateStockMock.callArgs = []*IStockRepoMockUpdateStockParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStockRepoMockAddStock struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockAddStockExpectation
	expectations       []*IStockRepoMockAddStockExpectation

	callArgs []*IStockRepoMockAddStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockAddStockExpectation specifies expectation struct of the IStockRepo.AddStock
type IStockRepoMockAddStockExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockAddStockParams
	paramPtrs          *IStockRepoMockAddStockParamPtrs
	expectationOrigins IStockRepoMockAddStockExpectationOrigins
	results            *IStockRepoMockAddStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockAddStockParams contains parameters of the IStockRepo.AddStock
type IStockRepoMockAddStockParams struct {
	ctx   context.Context
	stock models.Stock
}

// IStockRepoMockAddStockParamPtrs contains pointers to parameters of the IStockRepo.AddStock
type IStockRepoMockAddStockParamPtrs struct {
	ctx   *context.Context
	stock *models.Stock
}

// IStockRepoMockAddStockResults contains results of the IStockRepo.AddStock
type IStockRepoMockAddStockResults struct {
	err error
}

// IStockRepoMockAddStockOrigins contains origins of expectations of the IStockRepo.AddStock
type IStockRepoMockAddStockExpectationOrigins struct {
	origin      string
	originCtx   string
	originStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddStock *mIStockRepoMockAddStock) Optional() *mIStockRepoMockAddStock {
	mmAddStock.optional = true
	return mmAddStock
}

// Expect sets up expected params for IStockRepo.AddStock
func (mmAddStock *mIStockRepoMockAddStock) Expect(ctx context.Context, stock models.Stock) *mIStockRepoMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockRepoMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.paramPtrs != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by ExpectParams functions")
	}

	mmAddStock.defaultExpectation.params = &IStockRepoMockAddStockParams{ctx, stock}
	mmAddStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddStock.expectations {
		if minimock.Equal(e.params, mmAddStock.defaultExpectation.params) {
			mmAddStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddStock.defaultExpectation.params)
		}
	}

	return mmAddStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.AddStock
func (mmAddStock *mIStockRepoMockAddStock) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockRepoMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.params != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Expect")
	}

	if mmAddStock.defaultExpectation.paramPtrs == nil {
		mmAddStock.defaultExpectation.paramPtrs = &IStockRepoMockAddStockParamPtrs{}
	}
	mmAddStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddStock
}

// ExpectStockParam2 sets up expected param stock for IStockRepo.AddStock
func (mmAddStock *mIStockRepoMockAddStock) ExpectStockParam2(stock models.Stock) *mIStockRepoMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockRepoMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.params != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Expect")
	}

	if mmAddStock.defaultExpectation.paramPtrs == nil {
		mmAddStock.defaultExpectation.paramPtrs = &IStockRepoMockAddStockParamPtrs{}
	}
	mmAddStock.defaultExpectation.paramPtrs.stock = &stock
	mmAddStock.defaultExpectation.expectationOrigins.originStock = minimock.CallerInfo(1)

	return mmAddStock
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.AddStock
func (mmAddStock *mIStockRepoMockAddStock) Inspect(f func(ctx context.Context, stock models.Stock)) *mIStockRepoMockAddStock {
	if mmAddStock.mock.inspectFuncAddStock != nil {
		mmAddStock.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.AddStock")
	}

	mmAddStock.mock.inspectFuncAddStock = f

	return mmAddStock
}

// Return sets up results that will be returned by IStockRepo.AddStock
func (mmAddStock *mIStockRepoMockAddStock) Return(err error) *IStockRepoMock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockRepoMockAddStockExpectation{mock: mmAddStock.mock}
	}
	mmAddStock.defaultExpectation.results = &IStockRepoMockAddStockResults{err}
	mmAddStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddStock.mock
}

// Set uses given function f to mock the IStockRepo.AddStock method
func (mmAddStock *mIStockRepoMockAddStock) Set(f func(ctx context.Context, stock models.Stock) (err error)) *IStockRepoMock {
	if mmAddStock.defaultExpectation != nil {
		mmAddStock.mock.t.Fatalf("Default expectation is already set for the IStockRepo.AddStock method")
	}

	if len(mmAddStock.expectations) > 0 {
		mmAddStock.mock.t.Fatalf("Some expectations are already set for the IStockRepo.AddStock method")
	}

	mmAddStock.mock.funcAddStock = f
	mmAddStock.mock.funcAddStockOrigin = minimock.CallerInfo(1)
	return mmAddStock.mock
}

// When sets expectation for the IStockRepo.AddStock which will trigger the result defined by the following
// Then helper
func (mmAddStock *mIStockRepoMockAddStock) When(ctx context.Context, stock models.Stock) *IStockRepoMockAddStockExpectation {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockRepoMock.AddStock mock is already set by Set")
	}

	expectation := &IStockRepoMockAddStockExpectation{
		mock:               mmAddStock.mock,
		params:             &IStockRepoMockAddStockParams{ctx, stock},
		expectationOrigins: IStockRepoMockAddStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddStock.expectations = append(mmAddStock.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.AddStock return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockAddStockExpectation) Then(err error) *IStockRepoMock {
	e.results = &IStockRepoMockAddStockResults{err}
	return e.mock
}

// Times sets number of times IStockRepo.AddStock should be invoked
func (mmAddStock *mIStockRepoMockAddStock) Times(n uint64) *mIStockRepoMockAddStock {
	if n == 0 {
		mmAddStock.mock.t.Fatalf("Times of IStockRepoMock.AddStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddStock.expectedInvocations, n)
	mmAddStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddStock
}

func (mmAddStock *mIStockRepoMockAddStock) invocationsDone() bool {
	if len(mmAddStock.expectations) == 0 && mmAddStock.defaultExpectation == nil && mmAddStock.mock.funcAddStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddStock.mock.afterAddStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddStock implements mm_repository.IStockRepo
func (mmAddStock *IStockRepoMock) AddStock(ctx context.Context, stock models.Stock) (err error) {
	mm_atomic.AddUint64(&mmAddStock.beforeAddStockCounter, 1)
	defer mm_atomic.AddUint64(&mmAddStock.afterAddStockCounter, 1)

	mmAddStock.t.Helper()

	if mmAddStock.inspectFuncAddStock != nil {
		mmAddStock.inspectFuncAddStock(ctx, stock)
	}

	mm_params := IStockRepoMockAddStockParams{ctx, stock}

	// Record call args
	mmAddStock.AddStockMock.mutex.Lock()
	mmAddStock.AddStockMock.callArgs = append(mmAddStock.AddStockMock.callArgs, &mm_params)
	mmAddStock.AddStockMock.mutex.Unlock()

	for _, e := range mmAddStock.AddStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddStock.AddStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddStock.AddStockMock.defaultExpectation.Counter, 1)
		mm_want := mmAddStock.AddStockMock.defaultExpectation.params
		mm_want_ptrs := mmAddStock.AddStockMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockAddStockParams{ctx, stock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddStock.t.Errorf("IStockRepoMock.AddStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stock != nil && !minimock.Equal(*mm_want_ptrs.stock, mm_got.stock) {
				mmAddStock.t.Errorf("IStockRepoMock.AddStock got unexpected parameter stock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.originStock, *mm_want_ptrs.stock, mm_got.stock, minimock.Diff(*mm_want_ptrs.stock, mm_got.stock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddStock.t.Errorf("IStockRepoMock.AddStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddStock.AddStockMock.defaultExpectation.results
		if mm_results == nil {
			mmAddStock.t.Fatal("No results are set for the IStockRepoMock.AddStock")
		}
		return (*mm_results).err
	}
	if mmAddStock.funcAddStock != nil {
		return mmAddStock.funcAddStock(ctx, stock)
	}
	mmAddStock.t.Fatalf("Unexpected call to IStockRepoMock.AddStock. %v %v", ctx, stock)
	return
}

// AddStockAfterCounter returns a count of finished IStockRepoMock.AddStock invocations
func (mmAddStock *IStockRepoMock) AddStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStock.afterAddStockCounter)
}

// AddStockBeforeCounter returns a count of IStockRepoMock.AddStock invocations
func (mmAddStock *IStockRepoMock) AddStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStock.beforeAddStockCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.AddStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddStock *mIStockRepoMockAddStock) Calls() []*IStockRepoMockAddStockParams {
	mmAddStock.mutex.RLock()

	argCopy := make([]*IStockRepoMockAddStockParams, len(mmAddStock.callArgs))
	copy(argCopy, mmAddStock.callArgs)

	mmAddStock.mutex.RUnlock()

	return argCopy
}

// MinimockAddStockDone returns true if the count of the AddStock invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockAddStockDone() bool {
	if m.AddStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddStockMock.invocationsDone()
}

// MinimockAddStockInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockAddStockInspect() {
	for _, e := range m.AddStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.AddStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddStockCounter := mm_atomic.LoadUint64(&m.afterAddStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddStockMock.defaultExpectation != nil && afterAddStockCounter < 1 {
		if m.AddStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.AddStock at\n%s", m.AddStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.AddStock at\n%s with params: %#v", m.AddStockMock.defaultExpectation.expectationOrigins.origin, *m.AddStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStock != nil && afterAddStockCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.AddStock at\n%s", m.funcAddStockOrigin)
	}

	if !m.AddStockMock.invocationsDone() && afterAddStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.AddStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddStockMock.expectedInvocations), m.AddStockMock.expectedInvocationsOrigin, afterAddStockCounter)
	}
}

type mIStockRepoMockDeleteStock struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockDeleteStockExpectation
	expectations       []*IStockRepoMockDeleteStockExpectation

	callArgs []*IStockRepoMockDeleteStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockDeleteStockExpectation specifies expectation struct of the IStockRepo.DeleteStock
type IStockRepoMockDeleteStockExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockDeleteStockParams
	paramPtrs          *IStockRepoMockDeleteStockParamPtrs
	expectationOrigins IStockRepoMockDeleteStockExpectationOrigins
	results            *IStockRepoMockDeleteStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockDeleteStockParams contains parameters of the IStockRepo.DeleteStock
type IStockRepoMockDeleteStockParams struct {
	ctx    context.Context
	skuID  models.SKUID
	userID models.UserID
}

// IStockRepoMockDeleteStockParamPtrs contains pointers to parameters of the IStockRepo.DeleteStock
type IStockRepoMockDeleteStockParamPtrs struct {
	ctx    *context.Context
	skuID  *models.SKUID
	userID *models.UserID
}

// IStockRepoMockDeleteStockResults contains results of the IStockRepo.DeleteStock
type IStockRepoMockDeleteStockResults struct {
	err error
}

// IStockRepoMockDeleteStockOrigins contains origins of expectations of the IStockRepo.DeleteStock
type IStockRepoMockDeleteStockExpectationOrigins struct {
	origin       string
	originCtx    string
	originSkuID  string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteStock *mIStockRepoMockDeleteStock) Optional() *mIStockRepoMockDeleteStock {
	mmDeleteStock.optional = true
	return mmDeleteStock
}

// Expect sets up expected params for IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) Expect(ctx context.Context, skuID models.SKUID, userID models.UserID) *mIStockRepoMockDeleteStock {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	if mmDeleteStock.defaultExpectation == nil {
		mmDeleteStock.defaultExpectation = &IStockRepoMockDeleteStockExpectation{}
	}

	if mmDeleteStock.defaultExpectation.paramPtrs != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by ExpectParams functions")
	}

	mmDeleteStock.defaultExpectation.params = &IStockRepoMockDeleteStockParams{ctx, skuID, userID}
	mmDeleteStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteStock.expectations {
		if minimock.Equal(e.params, mmDeleteStock.defaultExpectation.params) {
			mmDeleteStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStock.defaultExpectation.params)
		}
	}

	return mmDeleteStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockDeleteStock {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	if mmDeleteStock.defaultExpectation == nil {
		mmDeleteStock.defaultExpectation = &IStockRepoMockDeleteStockExpectation{}
	}

	if mmDeleteStock.defaultExpectation.params != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Expect")
	}

	if mmDeleteStock.defaultExpectation.paramPtrs == nil {
		mmDeleteStock.defaultExpectation.paramPtrs = &IStockRepoMockDeleteStockParamPtrs{}
	}
	mmDeleteStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteStock
}

// ExpectSkuIDParam2 sets up expected param skuID for IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) ExpectSkuIDParam2(skuID models.SKUID) *mIStockRepoMockDeleteStock {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	if mmDeleteStock.defaultExpectation == nil {
		mmDeleteStock.defaultExpectation = &IStockRepoMockDeleteStockExpectation{}
	}

	if mmDeleteStock.defaultExpectation.params != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Expect")
	}

	if mmDeleteStock.defaultExpectation.paramPtrs == nil {
		mmDeleteStock.defaultExpectation.paramPtrs = &IStockRepoMockDeleteStockParamPtrs{}
	}
	mmDeleteStock.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteStock.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteStock
}

// ExpectUserIDParam3 sets up expected param userID for IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) ExpectUserIDParam3(userID models.UserID) *mIStockRepoMockDeleteStock {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	if mmDeleteStock.defaultExpectation == nil {
		mmDeleteStock.defaultExpectation = &IStockRepoMockDeleteStockExpectation{}
	}

	if mmDeleteStock.defaultExpectation.params != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Expect")
	}

	if mmDeleteStock.defaultExpectation.paramPtrs == nil {
		mmDeleteStock.defaultExpectation.paramPtrs = &IStockRepoMockDeleteStockParamPtrs{}
	}
	mmDeleteStock.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteStock.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteStock
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) Inspect(f func(ctx context.Context, skuID models.SKUID, userID models.UserID)) *mIStockRepoMockDeleteStock {
	if mmDeleteStock.mock.inspectFuncDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.DeleteStock")
	}

	mmDeleteStock.mock.inspectFuncDeleteStock = f

	return mmDeleteStock
}

// Return sets up results that will be returned by IStockRepo.DeleteStock
func (mmDeleteStock *mIStockRepoMockDeleteStock) Return(err error) *IStockRepoMock {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	if mmDeleteStock.defaultExpectation == nil {
		mmDeleteStock.defaultExpectation = &IStockRepoMockDeleteStockExpectation{mock: mmDeleteStock.mock}
	}
	mmDeleteStock.defaultExpectation.results = &IStockRepoMockDeleteStockResults{err}
	mmDeleteStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteStock.mock
}

// Set uses given function f to mock the IStockRepo.DeleteStock method
func (mmDeleteStock *mIStockRepoMockDeleteStock) Set(f func(ctx context.Context, skuID models.SKUID, userID models.UserID) (err error)) *IStockRepoMock {
	if mmDeleteStock.defaultExpectation != nil {
		mmDeleteStock.mock.t.Fatalf("Default expectation is already set for the IStockRepo.DeleteStock method")
	}

	if len(mmDeleteStock.expectations) > 0 {
		mmDeleteStock.mock.t.Fatalf("Some expectations are already set for the IStockRepo.DeleteStock method")
	}

	mmDeleteStock.mock.funcDeleteStock = f
	mmDeleteStock.mock.funcDeleteStockOrigin = minimock.CallerInfo(1)
	return mmDeleteStock.mock
}

// When sets expectation for the IStockRepo.DeleteStock which will trigger the result defined by the following
// Then helper
func (mmDeleteStock *mIStockRepoMockDeleteStock) When(ctx context.Context, skuID models.SKUID, userID models.UserID) *IStockRepoMockDeleteStockExpectation {
	if mmDeleteStock.mock.funcDeleteStock != nil {
		mmDeleteStock.mock.t.Fatalf("IStockRepoMock.DeleteStock mock is already set by Set")
	}

	expectation := &IStockRepoMockDeleteStockExpectation{
		mock:               mmDeleteStock.mock,
		params:             &IStockRepoMockDeleteStockParams{ctx, skuID, userID},
		expectationOrigins: IStockRepoMockDeleteStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteStock.expectations = append(mmDeleteStock.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.DeleteStock return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockDeleteStockExpectation) Then(err error) *IStockRepoMock {
	e.results = &IStockRepoMockDeleteStockResults{err}
	return e.mock
}

// Times sets number of times IStockRepo.DeleteStock should be invoked
func (mmDeleteStock *mIStockRepoMockDeleteStock) Times(n uint64) *mIStockRepoMockDeleteStock {
	if n == 0 {
		mmDeleteStock.mock.t.Fatalf("Times of IStockRepoMock.DeleteStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteStock.expectedInvocations, n)
	mmDeleteStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteStock
}

func (mmDeleteStock *mIStockRepoMockDeleteStock) invocationsDone() bool {
	if len(mmDeleteStock.expectations) == 0 && mmDeleteStock.defaultExpectation == nil && mmDeleteStock.mock.funcDeleteStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteStock.mock.afterDeleteStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteStock implements mm_repository.IStockRepo
func (mmDeleteStock *IStockRepoMock) DeleteStock(ctx context.Context, skuID models.SKUID, userID models.UserID) (err error) {
	mm_atomic.AddUint64(&mmDeleteStock.beforeDeleteStockCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStock.afterDeleteStockCounter, 1)

	mmDeleteStock.t.Helper()

	if mmDeleteStock.inspectFuncDeleteStock != nil {
		mmDeleteStock.inspectFuncDeleteStock(ctx, skuID, userID)
	}

	mm_params := IStockRepoMockDeleteStockParams{ctx, skuID, userID}

	// Record call args
	mmDeleteStock.DeleteStockMock.mutex.Lock()
	mmDeleteStock.DeleteStockMock.callArgs = append(mmDeleteStock.DeleteStockMock.callArgs, &mm_params)
	mmDeleteStock.DeleteStockMock.mutex.Unlock()

	for _, e := range mmDeleteStock.DeleteStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteStock.DeleteStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStock.DeleteStockMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStock.DeleteStockMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteStock.DeleteStockMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockDeleteStockParams{ctx, skuID, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteStock.t.Errorf("IStockRepoMock.DeleteStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStock.DeleteStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteStock.t.Errorf("IStockRepoMock.DeleteStock got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStock.DeleteStockMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteStock.t.Errorf("IStockRepoMock.DeleteStock got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStock.DeleteStockMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStock.t.Errorf("IStockRepoMock.DeleteStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteStock.DeleteStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteStock.DeleteStockMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteStock.t.Fatal("No results are set for the IStockRepoMock.DeleteStock")
		}
		return (*mm_results).err
	}
	if mmDeleteStock.funcDeleteStock != nil {
		return mmDeleteStock.funcDeleteStock(ctx, skuID, userID)
	}
	mmDeleteStock.t.Fatalf("Unexpected call to IStockRepoMock.DeleteStock. %v %v %v", ctx, skuID, userID)
	return
}

// DeleteStockAfterCounter returns a count of finished IStockRepoMock.DeleteStock invocations
func (mmDeleteStock *IStockRepoMock) DeleteStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStock.afterDeleteStockCounter)
}

// DeleteStockBeforeCounter returns a count of IStockRepoMock.DeleteStock invocations
func (mmDeleteStock *IStockRepoMock) DeleteStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStock.beforeDeleteStockCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.DeleteStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStock *mIStockRepoMockDeleteStock) Calls() []*IStockRepoMockDeleteStockParams {
	mmDeleteStock.mutex.RLock()

	argCopy := make([]*IStockRepoMockDeleteStockParams, len(mmDeleteStock.callArgs))
	copy(argCopy, mmDeleteStock.callArgs)

	mmDeleteStock.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStockDone returns true if the count of the DeleteStock invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockDeleteStockDone() bool {
	if m.DeleteStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteStockMock.invocationsDone()
}

// MinimockDeleteStockInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockDeleteStockInspect() {
	for _, e := range m.DeleteStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.DeleteStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteStockCounter := mm_atomic.LoadUint64(&m.afterDeleteStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStockMock.defaultExpectation != nil && afterDeleteStockCounter < 1 {
		if m.DeleteStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.DeleteStock at\n%s", m.DeleteStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.DeleteStock at\n%s with params: %#v", m.DeleteStockMock.defaultExpectation.expectationOrigins.origin, *m.DeleteStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStock != nil && afterDeleteStockCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.DeleteStock at\n%s", m.funcDeleteStockOrigin)
	}

	if !m.DeleteStockMock.invocationsDone() && afterDeleteStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.DeleteStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteStockMock.expectedInvocations), m.DeleteStockMock.expectedInvocationsOrigin, afterDeleteStockCounter)
	}
}

type mIStockRepoMockGetItemBySKU struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockGetItemBySKUExpectation
	expectations       []*IStockRepoMockGetItemBySKUExpectation

	callArgs []*IStockRepoMockGetItemBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockGetItemBySKUExpectation specifies expectation struct of the IStockRepo.GetItemBySKU
type IStockRepoMockGetItemBySKUExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockGetItemBySKUParams
	paramPtrs          *IStockRepoMockGetItemBySKUParamPtrs
	expectationOrigins IStockRepoMockGetItemBySKUExpectationOrigins
	results            *IStockRepoMockGetItemBySKUResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockGetItemBySKUParams contains parameters of the IStockRepo.GetItemBySKU
type IStockRepoMockGetItemBySKUParams struct {
	ctx   context.Context
	skuID models.SKUID
}

// IStockRepoMockGetItemBySKUParamPtrs contains pointers to parameters of the IStockRepo.GetItemBySKU
type IStockRepoMockGetItemBySKUParamPtrs struct {
	ctx   *context.Context
	skuID *models.SKUID
}

// IStockRepoMockGetItemBySKUResults contains results of the IStockRepo.GetItemBySKU
type IStockRepoMockGetItemBySKUResults struct {
	i1  models.Item
	err error
}

// IStockRepoMockGetItemBySKUOrigins contains origins of expectations of the IStockRepo.GetItemBySKU
type IStockRepoMockGetItemBySKUExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Optional() *mIStockRepoMockGetItemBySKU {
	mmGetItemBySKU.optional = true
	return mmGetItemBySKU
}

// Expect sets up expected params for IStockRepo.GetItemBySKU
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Expect(ctx context.Context, skuID models.SKUID) *mIStockRepoMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockRepoMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by ExpectParams functions")
	}

	mmGetItemBySKU.defaultExpectation.params = &IStockRepoMockGetItemBySKUParams{ctx, skuID}
	mmGetItemBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemBySKU.expectations {
		if minimock.Equal(e.params, mmGetItemBySKU.defaultExpectation.params) {
			mmGetItemBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemBySKU.defaultExpectation.params)
		}
	}

	return mmGetItemBySKU
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.GetItemBySKU
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockRepoMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.params != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Expect")
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetItemBySKU.defaultExpectation.paramPtrs = &IStockRepoMockGetItemBySKUParamPtrs{}
	}
	mmGetItemBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemBySKU
}

// ExpectSkuIDParam2 sets up expected param skuID for IStockRepo.GetItemBySKU
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) ExpectSkuIDParam2(skuID models.SKUID) *mIStockRepoMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockRepoMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.params != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Expect")
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetItemBySKU.defaultExpectation.paramPtrs = &IStockRepoMockGetItemBySKUParamPtrs{}
	}
	mmGetItemBySKU.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetItemBySKU.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetItemBySKU
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.GetItemBySKU
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Inspect(f func(ctx context.Context, skuID models.SKUID)) *mIStockRepoMockGetItemBySKU {
	if mmGetItemBySKU.mock.inspectFuncGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.GetItemBySKU")
	}

	mmGetItemBySKU.mock.inspectFuncGetItemBySKU = f

	return mmGetItemBySKU
}

// Return sets up results that will be returned by IStockRepo.GetItemBySKU
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Return(i1 models.Item, err error) *IStockRepoMock {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockRepoMockGetItemBySKUExpectation{mock: mmGetItemBySKU.mock}
	}
	mmGetItemBySKU.defaultExpectation.results = &IStockRepoMockGetItemBySKUResults{i1, err}
	mmGetItemBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU.mock
}

// Set uses given function f to mock the IStockRepo.GetItemBySKU method
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Set(f func(ctx context.Context, skuID models.SKUID) (i1 models.Item, err error)) *IStockRepoMock {
	if mmGetItemBySKU.defaultExpectation != nil {
		mmGetItemBySKU.mock.t.Fatalf("Default expectation is already set for the IStockRepo.GetItemBySKU method")
	}

	if len(mmGetItemBySKU.expectations) > 0 {
		mmGetItemBySKU.mock.t.Fatalf("Some expectations are already set for the IStockRepo.GetItemBySKU method")
	}

	mmGetItemBySKU.mock.funcGetItemBySKU = f
	mmGetItemBySKU.mock.funcGetItemBySKUOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU.mock
}

// When sets expectation for the IStockRepo.GetItemBySKU which will trigger the result defined by the following
// Then helper
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) When(ctx context.Context, skuID models.SKUID) *IStockRepoMockGetItemBySKUExpectation {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockRepoMock.GetItemBySKU mock is already set by Set")
	}

	expectation := &IStockRepoMockGetItemBySKUExpectation{
		mock:               mmGetItemBySKU.mock,
		params:             &IStockRepoMockGetItemBySKUParams{ctx, skuID},
		expectationOrigins: IStockRepoMockGetItemBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemBySKU.expectations = append(mmGetItemBySKU.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.GetItemBySKU return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockGetItemBySKUExpectation) Then(i1 models.Item, err error) *IStockRepoMock {
	e.results = &IStockRepoMockGetItemBySKUResults{i1, err}
	return e.mock
}

// Times sets number of times IStockRepo.GetItemBySKU should be invoked
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Times(n uint64) *mIStockRepoMockGetItemBySKU {
	if n == 0 {
		mmGetItemBySKU.mock.t.Fatalf("Times of IStockRepoMock.GetItemBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemBySKU.expectedInvocations, n)
	mmGetItemBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU
}

func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) invocationsDone() bool {
	if len(mmGetItemBySKU.expectations) == 0 && mmGetItemBySKU.defaultExpectation == nil && mmGetItemBySKU.mock.funcGetItemBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemBySKU.mock.afterGetItemBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemBySKU implements mm_repository.IStockRepo
func (mmGetItemBySKU *IStockRepoMock) GetItemBySKU(ctx context.Context, skuID models.SKUID) (i1 models.Item, err error) {
	mm_atomic.AddUint64(&mmGetItemBySKU.beforeGetItemBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemBySKU.afterGetItemBySKUCounter, 1)

	mmGetItemBySKU.t.Helper()

	if mmGetItemBySKU.inspectFuncGetItemBySKU != nil {
		mmGetItemBySKU.inspectFuncGetItemBySKU(ctx, skuID)
	}

	mm_params := IStockRepoMockGetItemBySKUParams{ctx, skuID}

	// Record call args
	mmGetItemBySKU.GetItemBySKUMock.mutex.Lock()
	mmGetItemBySKU.GetItemBySKUMock.callArgs = append(mmGetItemBySKU.GetItemBySKUMock.callArgs, &mm_params)
	mmGetItemBySKU.GetItemBySKUMock.mutex.Unlock()

	for _, e := range mmGetItemBySKU.GetItemBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetItemBySKU.GetItemBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockGetItemBySKUParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemBySKU.t.Errorf("IStockRepoMock.GetItemBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetItemBySKU.t.Errorf("IStockRepoMock.GetItemBySKU got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemBySKU.t.Errorf("IStockRepoMock.GetItemBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemBySKU.t.Fatal("No results are set for the IStockRepoMock.GetItemBySKU")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetItemBySKU.funcGetItemBySKU != nil {
		return mmGetItemBySKU.funcGetItemBySKU(ctx, skuID)
	}
	mmGetItemBySKU.t.Fatalf("Unexpected call to IStockRepoMock.GetItemBySKU. %v %v", ctx, skuID)
	return
}

// GetItemBySKUAfterCounter returns a count of finished IStockRepoMock.GetItemBySKU invocations
func (mmGetItemBySKU *IStockRepoMock) GetItemBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemBySKU.afterGetItemBySKUCounter)
}

// GetItemBySKUBeforeCounter returns a count of IStockRepoMock.GetItemBySKU invocations
func (mmGetItemBySKU *IStockRepoMock) GetItemBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemBySKU.beforeGetItemBySKUCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.GetItemBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemBySKU *mIStockRepoMockGetItemBySKU) Calls() []*IStockRepoMockGetItemBySKUParams {
	mmGetItemBySKU.mutex.RLock()

	argCopy := make([]*IStockRepoMockGetItemBySKUParams, len(mmGetItemBySKU.callArgs))
	copy(argCopy, mmGetItemBySKU.callArgs)

	mmGetItemBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemBySKUDone returns true if the count of the GetItemBySKU invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockGetItemBySKUDone() bool {
	if m.GetItemBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemBySKUMock.invocationsDone()
}

// MinimockGetItemBySKUInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockGetItemBySKUInspect() {
	for _, e := range m.GetItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemBySKUCounter := mm_atomic.LoadUint64(&m.afterGetItemBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemBySKUMock.defaultExpectation != nil && afterGetItemBySKUCounter < 1 {
		if m.GetItemBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemBySKU at\n%s", m.GetItemBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemBySKU at\n%s with params: %#v", m.GetItemBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetItemBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemBySKU != nil && afterGetItemBySKUCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.GetItemBySKU at\n%s", m.funcGetItemBySKUOrigin)
	}

	if !m.GetItemBySKUMock.invocationsDone() && afterGetItemBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.GetItemBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemBySKUMock.expectedInvocations), m.GetItemBySKUMock.expectedInvocationsOrigin, afterGetItemBySKUCounter)
	}
}

type mIStockRepoMockGetItemsByLocation struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockGetItemsByLocationExpectation
	expectations       []*IStockRepoMockGetItemsByLocationExpectation

	callArgs []*IStockRepoMockGetItemsByLocationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockGetItemsByLocationExpectation specifies expectation struct of the IStockRepo.GetItemsByLocation
type IStockRepoMockGetItemsByLocationExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockGetItemsByLocationParams
	paramPtrs          *IStockRepoMockGetItemsByLocationParamPtrs
	expectationOrigins IStockRepoMockGetItemsByLocationExpectationOrigins
	results            *IStockRepoMockGetItemsByLocationResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockGetItemsByLocationParams contains parameters of the IStockRepo.GetItemsByLocation
type IStockRepoMockGetItemsByLocationParams struct {
	ctx   context.Context
	param mm_repository.GetStockByLocation
}

// IStockRepoMockGetItemsByLocationParamPtrs contains pointers to parameters of the IStockRepo.GetItemsByLocation
type IStockRepoMockGetItemsByLocationParamPtrs struct {
	ctx   *context.Context
	param *mm_repository.GetStockByLocation
}

// IStockRepoMockGetItemsByLocationResults contains results of the IStockRepo.GetItemsByLocation
type IStockRepoMockGetItemsByLocationResults struct {
	ia1 []models.Item
	err error
}

// IStockRepoMockGetItemsByLocationOrigins contains origins of expectations of the IStockRepo.GetItemsByLocation
type IStockRepoMockGetItemsByLocationExpectationOrigins struct {
	origin      string
	originCtx   string
	originParam string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Optional() *mIStockRepoMockGetItemsByLocation {
	mmGetItemsByLocation.optional = true
	return mmGetItemsByLocation
}

// Expect sets up expected params for IStockRepo.GetItemsByLocation
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Expect(ctx context.Context, param mm_repository.GetStockByLocation) *mIStockRepoMockGetItemsByLocation {
	if mmGetItemsByLocation.mock.funcGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Set")
	}

	if mmGetItemsByLocation.defaultExpectation == nil {
		mmGetItemsByLocation.defaultExpectation = &IStockRepoMockGetItemsByLocationExpectation{}
	}

	if mmGetItemsByLocation.defaultExpectation.paramPtrs != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by ExpectParams functions")
	}

	mmGetItemsByLocation.defaultExpectation.params = &IStockRepoMockGetItemsByLocationParams{ctx, param}
	mmGetItemsByLocation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByLocation.expectations {
		if minimock.Equal(e.params, mmGetItemsByLocation.defaultExpectation.params) {
			mmGetItemsByLocation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByLocation.defaultExpectation.params)
		}
	}

	return mmGetItemsByLocation
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.GetItemsByLocation
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockGetItemsByLocation {
	if mmGetItemsByLocation.mock.funcGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Set")
	}

	if mmGetItemsByLocation.defaultExpectation == nil {
		mmGetItemsByLocation.defaultExpectation = &IStockRepoMockGetItemsByLocationExpectation{}
	}

	if mmGetItemsByLocation.defaultExpectation.params != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Expect")
	}

	if mmGetItemsByLocation.defaultExpectation.paramPtrs == nil {
		mmGetItemsByLocation.defaultExpectation.paramPtrs = &IStockRepoMockGetItemsByLocationParamPtrs{}
	}
	mmGetItemsByLocation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsByLocation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsByLocation
}

// ExpectParamParam2 sets up expected param param for IStockRepo.GetItemsByLocation
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) ExpectParamParam2(param mm_repository.GetStockByLocation) *mIStockRepoMockGetItemsByLocation {
	if mmGetItemsByLocation.mock.funcGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Set")
	}

	if mmGetItemsByLocation.defaultExpectation == nil {
		mmGetItemsByLocation.defaultExpectation = &IStockRepoMockGetItemsByLocationExpectation{}
	}

	if mmGetItemsByLocation.defaultExpectation.params != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Expect")
	}

	if mmGetItemsByLocation.defaultExpectation.paramPtrs == nil {
		mmGetItemsByLocation.defaultExpectation.paramPtrs = &IStockRepoMockGetItemsByLocationParamPtrs{}
	}
	mmGetItemsByLocation.defaultExpectation.paramPtrs.param = &param
	mmGetItemsByLocation.defaultExpectation.expectationOrigins.originParam = minimock.CallerInfo(1)

	return mmGetItemsByLocation
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.GetItemsByLocation
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Inspect(f func(ctx context.Context, param mm_repository.GetStockByLocation)) *mIStockRepoMockGetItemsByLocation {
	if mmGetItemsByLocation.mock.inspectFuncGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.GetItemsByLocation")
	}

	mmGetItemsByLocation.mock.inspectFuncGetItemsByLocation = f

	return mmGetItemsByLocation
}

// Return sets up results that will be returned by IStockRepo.GetItemsByLocation
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Return(ia1 []models.Item, err error) *IStockRepoMock {
	if mmGetItemsByLocation.mock.funcGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Set")
	}

	if mmGetItemsByLocation.defaultExpectation == nil {
		mmGetItemsByLocation.defaultExpectation = &IStockRepoMockGetItemsByLocationExpectation{mock: mmGetItemsByLocation.mock}
	}
	mmGetItemsByLocation.defaultExpectation.results = &IStockRepoMockGetItemsByLocationResults{ia1, err}
	mmGetItemsByLocation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByLocation.mock
}

// Set uses given function f to mock the IStockRepo.GetItemsByLocation method
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Set(f func(ctx context.Context, param mm_repository.GetStockByLocation) (ia1 []models.Item, err error)) *IStockRepoMock {
	if mmGetItemsByLocation.defaultExpectation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("Default expectation is already set for the IStockRepo.GetItemsByLocation method")
	}

	if len(mmGetItemsByLocation.expectations) > 0 {
		mmGetItemsByLocation.mock.t.Fatalf("Some expectations are already set for the IStockRepo.GetItemsByLocation method")
	}

	mmGetItemsByLocation.mock.funcGetItemsByLocation = f
	mmGetItemsByLocation.mock.funcGetItemsByLocationOrigin = minimock.CallerInfo(1)
	return mmGetItemsByLocation.mock
}

// When sets expectation for the IStockRepo.GetItemsByLocation which will trigger the result defined by the following
// Then helper
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) When(ctx context.Context, param mm_repository.GetStockByLocation) *IStockRepoMockGetItemsByLocationExpectation {
	if mmGetItemsByLocation.mock.funcGetItemsByLocation != nil {
		mmGetItemsByLocation.mock.t.Fatalf("IStockRepoMock.GetItemsByLocation mock is already set by Set")
	}

	expectation := &IStockRepoMockGetItemsByLocationExpectation{
		mock:               mmGetItemsByLocation.mock,
		params:             &IStockRepoMockGetItemsByLocationParams{ctx, param},
		expectationOrigins: IStockRepoMockGetItemsByLocationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByLocation.expectations = append(mmGetItemsByLocation.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.GetItemsByLocation return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockGetItemsByLocationExpectation) Then(ia1 []models.Item, err error) *IStockRepoMock {
	e.results = &IStockRepoMockGetItemsByLocationResults{ia1, err}
	return e.mock
}

// Times sets number of times IStockRepo.GetItemsByLocation should be invoked
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Times(n uint64) *mIStockRepoMockGetItemsByLocation {
	if n == 0 {
		mmGetItemsByLocation.mock.t.Fatalf("Times of IStockRepoMock.GetItemsByLocation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByLocation.expectedInvocations, n)
	mmGetItemsByLocation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByLocation
}

func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) invocationsDone() bool {
	if len(mmGetItemsByLocation.expectations) == 0 && mmGetItemsByLocation.defaultExpectation == nil && mmGetItemsByLocation.mock.funcGetItemsByLocation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByLocation.mock.afterGetItemsByLocationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByLocation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByLocation implements mm_repository.IStockRepo
func (mmGetItemsByLocation *IStockRepoMock) GetItemsByLocation(ctx context.Context, param mm_repository.GetStockByLocation) (ia1 []models.Item, err error) {
	mm_atomic.AddUint64(&mmGetItemsByLocation.beforeGetItemsByLocationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByLocation.afterGetItemsByLocationCounter, 1)

	mmGetItemsByLocation.t.Helper()

	if mmGetItemsByLocation.inspectFuncGetItemsByLocation != nil {
		mmGetItemsByLocation.inspectFuncGetItemsByLocation(ctx, param)
	}

	mm_params := IStockRepoMockGetItemsByLocationParams{ctx, param}

	// Record call args
	mmGetItemsByLocation.GetItemsByLocationMock.mutex.Lock()
	mmGetItemsByLocation.GetItemsByLocationMock.callArgs = append(mmGetItemsByLocation.GetItemsByLocationMock.callArgs, &mm_params)
	mmGetItemsByLocation.GetItemsByLocationMock.mutex.Unlock()

	for _, e := range mmGetItemsByLocation.GetItemsByLocationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockGetItemsByLocationParams{ctx, param}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByLocation.t.Errorf("IStockRepoMock.GetItemsByLocation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.param != nil && !minimock.Equal(*mm_want_ptrs.param, mm_got.param) {
				mmGetItemsByLocation.t.Errorf("IStockRepoMock.GetItemsByLocation got unexpected parameter param, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.expectationOrigins.originParam, *mm_want_ptrs.param, mm_got.param, minimock.Diff(*mm_want_ptrs.param, mm_got.param))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByLocation.t.Errorf("IStockRepoMock.GetItemsByLocation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByLocation.GetItemsByLocationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByLocation.t.Fatal("No results are set for the IStockRepoMock.GetItemsByLocation")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetItemsByLocation.funcGetItemsByLocation != nil {
		return mmGetItemsByLocation.funcGetItemsByLocation(ctx, param)
	}
	mmGetItemsByLocation.t.Fatalf("Unexpected call to IStockRepoMock.GetItemsByLocation. %v %v", ctx, param)
	return
}

// GetItemsByLocationAfterCounter returns a count of finished IStockRepoMock.GetItemsByLocation invocations
func (mmGetItemsByLocation *IStockRepoMock) GetItemsByLocationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByLocation.afterGetItemsByLocationCounter)
}

// GetItemsByLocationBeforeCounter returns a count of IStockRepoMock.GetItemsByLocation invocations
func (mmGetItemsByLocation *IStockRepoMock) GetItemsByLocationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByLocation.beforeGetItemsByLocationCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.GetItemsByLocation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByLocation *mIStockRepoMockGetItemsByLocation) Calls() []*IStockRepoMockGetItemsByLocationParams {
	mmGetItemsByLocation.mutex.RLock()

	argCopy := make([]*IStockRepoMockGetItemsByLocationParams, len(mmGetItemsByLocation.callArgs))
	copy(argCopy, mmGetItemsByLocation.callArgs)

	mmGetItemsByLocation.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByLocationDone returns true if the count of the GetItemsByLocation invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockGetItemsByLocationDone() bool {
	if m.GetItemsByLocationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByLocationMock.invocationsDone()
}

// MinimockGetItemsByLocationInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockGetItemsByLocationInspect() {
	for _, e := range m.GetItemsByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemsByLocation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByLocationCounter := mm_atomic.LoadUint64(&m.afterGetItemsByLocationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByLocationMock.defaultExpectation != nil && afterGetItemsByLocationCounter < 1 {
		if m.GetItemsByLocationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemsByLocation at\n%s", m.GetItemsByLocationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.GetItemsByLocation at\n%s with params: %#v", m.GetItemsByLocationMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByLocationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByLocation != nil && afterGetItemsByLocationCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.GetItemsByLocation at\n%s", m.funcGetItemsByLocationOrigin)
	}

	if !m.GetItemsByLocationMock.invocationsDone() && afterGetItemsByLocationCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.GetItemsByLocation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByLocationMock.expectedInvocations), m.GetItemsByLocationMock.expectedInvocationsOrigin, afterGetItemsByLocationCounter)
	}
}

type mIStockRepoMockUpdateStock struct {
	optional           bool
	mock               *IStockRepoMock
	defaultExpectation *IStockRepoMockUpdateStockExpectation
	expectations       []*IStockRepoMockUpdateStockExpectation

	callArgs []*IStockRepoMockUpdateStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepoMockUpdateStockExpectation specifies expectation struct of the IStockRepo.UpdateStock
type IStockRepoMockUpdateStockExpectation struct {
	mock               *IStockRepoMock
	params             *IStockRepoMockUpdateStockParams
	paramPtrs          *IStockRepoMockUpdateStockParamPtrs
	expectationOrigins IStockRepoMockUpdateStockExpectationOrigins
	results            *IStockRepoMockUpdateStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepoMockUpdateStockParams contains parameters of the IStockRepo.UpdateStock
type IStockRepoMockUpdateStockParams struct {
	ctx   context.Context
	stock models.Stock
}

// IStockRepoMockUpdateStockParamPtrs contains pointers to parameters of the IStockRepo.UpdateStock
type IStockRepoMockUpdateStockParamPtrs struct {
	ctx   *context.Context
	stock *models.Stock
}

// IStockRepoMockUpdateStockResults contains results of the IStockRepo.UpdateStock
type IStockRepoMockUpdateStockResults struct {
	err error
}

// IStockRepoMockUpdateStockOrigins contains origins of expectations of the IStockRepo.UpdateStock
type IStockRepoMockUpdateStockExpectationOrigins struct {
	origin      string
	originCtx   string
	originStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStock *mIStockRepoMockUpdateStock) Optional() *mIStockRepoMockUpdateStock {
	mmUpdateStock.optional = true
	return mmUpdateStock
}

// Expect sets up expected params for IStockRepo.UpdateStock
func (mmUpdateStock *mIStockRepoMockUpdateStock) Expect(ctx context.Context, stock models.Stock) *mIStockRepoMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &IStockRepoMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.paramPtrs != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by ExpectParams functions")
	}

	mmUpdateStock.defaultExpectation.params = &IStockRepoMockUpdateStockParams{ctx, stock}
	mmUpdateStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStock.expectations {
		if minimock.Equal(e.params, mmUpdateStock.defaultExpectation.params) {
			mmUpdateStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStock.defaultExpectation.params)
		}
	}

	return mmUpdateStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepo.UpdateStock
func (mmUpdateStock *mIStockRepoMockUpdateStock) ExpectCtxParam1(ctx context.Context) *mIStockRepoMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &IStockRepoMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.params != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Expect")
	}

	if mmUpdateStock.defaultExpectation.paramPtrs == nil {
		mmUpdateStock.defaultExpectation.paramPtrs = &IStockRepoMockUpdateStockParamPtrs{}
	}
	mmUpdateStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStock
}

// ExpectStockParam2 sets up expected param stock for IStockRepo.UpdateStock
func (mmUpdateStock *mIStockRepoMockUpdateStock) ExpectStockParam2(stock models.Stock) *mIStockRepoMockUpdateStock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &IStockRepoMockUpdateStockExpectation{}
	}

	if mmUpdateStock.defaultExpectation.params != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Expect")
	}

	if mmUpdateStock.defaultExpectation.paramPtrs == nil {
		mmUpdateStock.defaultExpectation.paramPtrs = &IStockRepoMockUpdateStockParamPtrs{}
	}
	mmUpdateStock.defaultExpectation.paramPtrs.stock = &stock
	mmUpdateStock.defaultExpectation.expectationOrigins.originStock = minimock.CallerInfo(1)

	return mmUpdateStock
}

// Inspect accepts an inspector function that has same arguments as the IStockRepo.UpdateStock
func (mmUpdateStock *mIStockRepoMockUpdateStock) Inspect(f func(ctx context.Context, stock models.Stock)) *mIStockRepoMockUpdateStock {
	if mmUpdateStock.mock.inspectFuncUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("Inspect function is already set for IStockRepoMock.UpdateStock")
	}

	mmUpdateStock.mock.inspectFuncUpdateStock = f

	return mmUpdateStock
}

// Return sets up results that will be returned by IStockRepo.UpdateStock
func (mmUpdateStock *mIStockRepoMockUpdateStock) Return(err error) *IStockRepoMock {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Set")
	}

	if mmUpdateStock.defaultExpectation == nil {
		mmUpdateStock.defaultExpectation = &IStockRepoMockUpdateStockExpectation{mock: mmUpdateStock.mock}
	}
	mmUpdateStock.defaultExpectation.results = &IStockRepoMockUpdateStockResults{err}
	mmUpdateStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStock.mock
}

// Set uses given function f to mock the IStockRepo.UpdateStock method
func (mmUpdateStock *mIStockRepoMockUpdateStock) Set(f func(ctx context.Context, stock models.Stock) (err error)) *IStockRepoMock {
	if mmUpdateStock.defaultExpectation != nil {
		mmUpdateStock.mock.t.Fatalf("Default expectation is already set for the IStockRepo.UpdateStock method")
	}

	if len(mmUpdateStock.expectations) > 0 {
		mmUpdateStock.mock.t.Fatalf("Some expectations are already set for the IStockRepo.UpdateStock method")
	}

	mmUpdateStock.mock.funcUpdateStock = f
	mmUpdateStock.mock.funcUpdateStockOrigin = minimock.CallerInfo(1)
	return mmUpdateStock.mock
}

// When sets expectation for the IStockRepo.UpdateStock which will trigger the result defined by the following
// Then helper
func (mmUpdateStock *mIStockRepoMockUpdateStock) When(ctx context.Context, stock models.Stock) *IStockRepoMockUpdateStockExpectation {
	if mmUpdateStock.mock.funcUpdateStock != nil {
		mmUpdateStock.mock.t.Fatalf("IStockRepoMock.UpdateStock mock is already set by Set")
	}

	expectation := &IStockRepoMockUpdateStockExpectation{
		mock:               mmUpdateStock.mock,
		params:             &IStockRepoMockUpdateStockParams{ctx, stock},
		expectationOrigins: IStockRepoMockUpdateStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStock.expectations = append(mmUpdateStock.expectations, expectation)
	return expectation
}

// Then sets up IStockRepo.UpdateStock return parameters for the expectation previously defined by the When method
func (e *IStockRepoMockUpdateStockExpectation) Then(err error) *IStockRepoMock {
	e.results = &IStockRepoMockUpdateStockResults{err}
	return e.mock
}

// Times sets number of times IStockRepo.UpdateStock should be invoked
func (mmUpdateStock *mIStockRepoMockUpdateStock) Times(n uint64) *mIStockRepoMockUpdateStock {
	if n == 0 {
		mmUpdateStock.mock.t.Fatalf("Times of IStockRepoMock.UpdateStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStock.expectedInvocations, n)
	mmUpdateStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStock
}

func (mmUpdateStock *mIStockRepoMockUpdateStock) invocationsDone() bool {
	if len(mmUpdateStock.expectations) == 0 && mmUpdateStock.defaultExpectation == nil && mmUpdateStock.mock.funcUpdateStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStock.mock.afterUpdateStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStock implements mm_repository.IStockRepo
func (mmUpdateStock *IStockRepoMock) UpdateStock(ctx context.Context, stock models.Stock) (err error) {
	mm_atomic.AddUint64(&mmUpdateStock.beforeUpdateStockCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStock.afterUpdateStockCounter, 1)

	mmUpdateStock.t.Helper()

	if mmUpdateStock.inspectFuncUpdateStock != nil {
		mmUpdateStock.inspectFuncUpdateStock(ctx, stock)
	}

	mm_params := IStockRepoMockUpdateStockParams{ctx, stock}

	// Record call args
	mmUpdateStock.UpdateStockMock.mutex.Lock()
	mmUpdateStock.UpdateStockMock.callArgs = append(mmUpdateStock.UpdateStockMock.callArgs, &mm_params)
	mmUpdateStock.UpdateStockMock.mutex.Unlock()

	for _, e := range mmUpdateStock.UpdateStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStock.UpdateStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStock.UpdateStockMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStock.UpdateStockMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStock.UpdateStockMock.defaultExpectation.paramPtrs

		mm_got := IStockRepoMockUpdateStockParams{ctx, stock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStock.t.Errorf("IStockRepoMock.UpdateStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stock != nil && !minimock.Equal(*mm_want_ptrs.stock, mm_got.stock) {
				mmUpdateStock.t.Errorf("IStockRepoMock.UpdateStock got unexpected parameter stock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.originStock, *mm_want_ptrs.stock, mm_got.stock, minimock.Diff(*mm_want_ptrs.stock, mm_got.stock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStock.t.Errorf("IStockRepoMock.UpdateStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStock.UpdateStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStock.UpdateStockMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStock.t.Fatal("No results are set for the IStockRepoMock.UpdateStock")
		}
		return (*mm_results).err
	}
	if mmUpdateStock.funcUpdateStock != nil {
		return mmUpdateStock.funcUpdateStock(ctx, stock)
	}
	mmUpdateStock.t.Fatalf("Unexpected call to IStockRepoMock.UpdateStock. %v %v", ctx, stock)
	return
}

// UpdateStockAfterCounter returns a count of finished IStockRepoMock.UpdateStock invocations
func (mmUpdateStock *IStockRepoMock) UpdateStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStock.afterUpdateStockCounter)
}

// UpdateStockBeforeCounter returns a count of IStockRepoMock.UpdateStock invocations
func (mmUpdateStock *IStockRepoMock) UpdateStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStock.beforeUpdateStockCounter)
}

// Calls returns a list of arguments used in each call to IStockRepoMock.UpdateStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStock *mIStockRepoMockUpdateStock) Calls() []*IStockRepoMockUpdateStockParams {
	mmUpdateStock.mutex.RLock()

	argCopy := make([]*IStockRepoMockUpdateStockParams, len(mmUpdateStock.callArgs))
	copy(argCopy, mmUpdateStock.callArgs)

	mmUpdateStock.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStockDone returns true if the count of the UpdateStock invocations corresponds
// the number of defined expectations
func (m *IStockRepoMock) MinimockUpdateStockDone() bool {
	if m.UpdateStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStockMock.invocationsDone()
}

// MinimockUpdateStockInspect logs each unmet expectation
func (m *IStockRepoMock) MinimockUpdateStockInspect() {
	for _, e := range m.UpdateStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepoMock.UpdateStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStockCounter := mm_atomic.LoadUint64(&m.afterUpdateStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStockMock.defaultExpectation != nil && afterUpdateStockCounter < 1 {
		if m.UpdateStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepoMock.UpdateStock at\n%s", m.UpdateStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepoMock.UpdateStock at\n%s with params: %#v", m.UpdateStockMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStock != nil && afterUpdateStockCounter < 1 {
		m.t.Errorf("Expected call to IStockRepoMock.UpdateStock at\n%s", m.funcUpdateStockOrigin)
	}

	if !m.UpdateStockMock.invocationsDone() && afterUpdateStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepoMock.UpdateStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStockMock.expectedInvocations), m.UpdateStockMock.expectedInvocationsOrigin, afterUpdateStockCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStockRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddStockInspect()

			m.MinimockDeleteStockInspect()

			m.MinimockGetItemBySKUInspect()

			m.MinimockGetItemsByLocationInspect()

			m.MinimockUpdateStockInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStockRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStockRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddStockDone() &&
		m.MinimockDeleteStockDone() &&
		m.MinimockGetItemBySKUDone() &&
		m.MinimockGetItemsByLocationDone() &&
		m.MinimockUpdateStockDone()
}
