// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"stocks/internal/models"
	"stocks/internal/usecase"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IStockUsecaseMock implements mm_controller.IStockUsecase
type IStockUsecaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddStock          func(ctx context.Context, stock usecase.AddStockDTO) (err error)
	funcAddStockOrigin    string
	inspectFuncAddStock   func(ctx context.Context, stock usecase.AddStockDTO)
	afterAddStockCounter  uint64
	beforeAddStockCounter uint64
	AddStockMock          mIStockUsecaseMockAddStock

	funcDeleteStockBySKU          func(ctx context.Context, delStock usecase.DeleteStockDTO) (err error)
	funcDeleteStockBySKUOrigin    string
	inspectFuncDeleteStockBySKU   func(ctx context.Context, delStock usecase.DeleteStockDTO)
	afterDeleteStockBySKUCounter  uint64
	beforeDeleteStockBySKUCounter uint64
	DeleteStockBySKUMock          mIStockUsecaseMockDeleteStockBySKU

	funcGetItemBySKU          func(ctx context.Context, sku models.SKUID) (s1 usecase.StockDTO, err error)
	funcGetItemBySKUOrigin    string
	inspectFuncGetItemBySKU   func(ctx context.Context, sku models.SKUID)
	afterGetItemBySKUCounter  uint64
	beforeGetItemBySKUCounter uint64
	GetItemBySKUMock          mIStockUsecaseMockGetItemBySKU

	funcGetStocksByLocation          func(ctx context.Context, param usecase.GetItemByLocDTO) (i1 usecase.ItemsByLocDTO, err error)
	funcGetStocksByLocationOrigin    string
	inspectFuncGetStocksByLocation   func(ctx context.Context, param usecase.GetItemByLocDTO)
	afterGetStocksByLocationCounter  uint64
	beforeGetStocksByLocationCounter uint64
	GetStocksByLocationMock          mIStockUsecaseMockGetStocksByLocation
}

// NewIStockUsecaseMock returns a mock for mm_controller.IStockUsecase
func NewIStockUsecaseMock(t minimock.Tester) *IStockUsecaseMock {
	m := &IStockUsecaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddStockMock = mIStockUsecaseMockAddStock{mock: m}
	m.AddStockMock.callArgs = []*IStockUsecaseMockAddStockParams{}

	m.DeleteStockBySKUMock = mIStockUsecaseMockDeleteStockBySKU{mock: m}
	m.DeleteStockBySKUMock.callArgs = []*IStockUsecaseMockDeleteStockBySKUParams{}

	m.GetItemBySKUMock = mIStockUsecaseMockGetItemBySKU{mock: m}
	m.GetItemBySKUMock.callArgs = []*IStockUsecaseMockGetItemBySKUParams{}

	m.GetStocksByLocationMock = mIStockUsecaseMockGetStocksByLocation{mock: m}
	m.GetStocksByLocationMock.callArgs = []*IStockUsecaseMockGetStocksByLocationParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStockUsecaseMockAddStock struct {
	optional           bool
	mock               *IStockUsecaseMock
	defaultExpectation *IStockUsecaseMockAddStockExpectation
	expectations       []*IStockUsecaseMockAddStockExpectation

	callArgs []*IStockUsecaseMockAddStockParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockUsecaseMockAddStockExpectation specifies expectation struct of the IStockUsecase.AddStock
type IStockUsecaseMockAddStockExpectation struct {
	mock               *IStockUsecaseMock
	params             *IStockUsecaseMockAddStockParams
	paramPtrs          *IStockUsecaseMockAddStockParamPtrs
	expectationOrigins IStockUsecaseMockAddStockExpectationOrigins
	results            *IStockUsecaseMockAddStockResults
	returnOrigin       string
	Counter            uint64
}

// IStockUsecaseMockAddStockParams contains parameters of the IStockUsecase.AddStock
type IStockUsecaseMockAddStockParams struct {
	ctx   context.Context
	stock usecase.AddStockDTO
}

// IStockUsecaseMockAddStockParamPtrs contains pointers to parameters of the IStockUsecase.AddStock
type IStockUsecaseMockAddStockParamPtrs struct {
	ctx   *context.Context
	stock *usecase.AddStockDTO
}

// IStockUsecaseMockAddStockResults contains results of the IStockUsecase.AddStock
type IStockUsecaseMockAddStockResults struct {
	err error
}

// IStockUsecaseMockAddStockOrigins contains origins of expectations of the IStockUsecase.AddStock
type IStockUsecaseMockAddStockExpectationOrigins struct {
	origin      string
	originCtx   string
	originStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddStock *mIStockUsecaseMockAddStock) Optional() *mIStockUsecaseMockAddStock {
	mmAddStock.optional = true
	return mmAddStock
}

// Expect sets up expected params for IStockUsecase.AddStock
func (mmAddStock *mIStockUsecaseMockAddStock) Expect(ctx context.Context, stock usecase.AddStockDTO) *mIStockUsecaseMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockUsecaseMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.paramPtrs != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by ExpectParams functions")
	}

	mmAddStock.defaultExpectation.params = &IStockUsecaseMockAddStockParams{ctx, stock}
	mmAddStock.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddStock.expectations {
		if minimock.Equal(e.params, mmAddStock.defaultExpectation.params) {
			mmAddStock.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddStock.defaultExpectation.params)
		}
	}

	return mmAddStock
}

// ExpectCtxParam1 sets up expected param ctx for IStockUsecase.AddStock
func (mmAddStock *mIStockUsecaseMockAddStock) ExpectCtxParam1(ctx context.Context) *mIStockUsecaseMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockUsecaseMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.params != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Expect")
	}

	if mmAddStock.defaultExpectation.paramPtrs == nil {
		mmAddStock.defaultExpectation.paramPtrs = &IStockUsecaseMockAddStockParamPtrs{}
	}
	mmAddStock.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddStock.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddStock
}

// ExpectStockParam2 sets up expected param stock for IStockUsecase.AddStock
func (mmAddStock *mIStockUsecaseMockAddStock) ExpectStockParam2(stock usecase.AddStockDTO) *mIStockUsecaseMockAddStock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockUsecaseMockAddStockExpectation{}
	}

	if mmAddStock.defaultExpectation.params != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Expect")
	}

	if mmAddStock.defaultExpectation.paramPtrs == nil {
		mmAddStock.defaultExpectation.paramPtrs = &IStockUsecaseMockAddStockParamPtrs{}
	}
	mmAddStock.defaultExpectation.paramPtrs.stock = &stock
	mmAddStock.defaultExpectation.expectationOrigins.originStock = minimock.CallerInfo(1)

	return mmAddStock
}

// Inspect accepts an inspector function that has same arguments as the IStockUsecase.AddStock
func (mmAddStock *mIStockUsecaseMockAddStock) Inspect(f func(ctx context.Context, stock usecase.AddStockDTO)) *mIStockUsecaseMockAddStock {
	if mmAddStock.mock.inspectFuncAddStock != nil {
		mmAddStock.mock.t.Fatalf("Inspect function is already set for IStockUsecaseMock.AddStock")
	}

	mmAddStock.mock.inspectFuncAddStock = f

	return mmAddStock
}

// Return sets up results that will be returned by IStockUsecase.AddStock
func (mmAddStock *mIStockUsecaseMockAddStock) Return(err error) *IStockUsecaseMock {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Set")
	}

	if mmAddStock.defaultExpectation == nil {
		mmAddStock.defaultExpectation = &IStockUsecaseMockAddStockExpectation{mock: mmAddStock.mock}
	}
	mmAddStock.defaultExpectation.results = &IStockUsecaseMockAddStockResults{err}
	mmAddStock.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddStock.mock
}

// Set uses given function f to mock the IStockUsecase.AddStock method
func (mmAddStock *mIStockUsecaseMockAddStock) Set(f func(ctx context.Context, stock usecase.AddStockDTO) (err error)) *IStockUsecaseMock {
	if mmAddStock.defaultExpectation != nil {
		mmAddStock.mock.t.Fatalf("Default expectation is already set for the IStockUsecase.AddStock method")
	}

	if len(mmAddStock.expectations) > 0 {
		mmAddStock.mock.t.Fatalf("Some expectations are already set for the IStockUsecase.AddStock method")
	}

	mmAddStock.mock.funcAddStock = f
	mmAddStock.mock.funcAddStockOrigin = minimock.CallerInfo(1)
	return mmAddStock.mock
}

// When sets expectation for the IStockUsecase.AddStock which will trigger the result defined by the following
// Then helper
func (mmAddStock *mIStockUsecaseMockAddStock) When(ctx context.Context, stock usecase.AddStockDTO) *IStockUsecaseMockAddStockExpectation {
	if mmAddStock.mock.funcAddStock != nil {
		mmAddStock.mock.t.Fatalf("IStockUsecaseMock.AddStock mock is already set by Set")
	}

	expectation := &IStockUsecaseMockAddStockExpectation{
		mock:               mmAddStock.mock,
		params:             &IStockUsecaseMockAddStockParams{ctx, stock},
		expectationOrigins: IStockUsecaseMockAddStockExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddStock.expectations = append(mmAddStock.expectations, expectation)
	return expectation
}

// Then sets up IStockUsecase.AddStock return parameters for the expectation previously defined by the When method
func (e *IStockUsecaseMockAddStockExpectation) Then(err error) *IStockUsecaseMock {
	e.results = &IStockUsecaseMockAddStockResults{err}
	return e.mock
}

// Times sets number of times IStockUsecase.AddStock should be invoked
func (mmAddStock *mIStockUsecaseMockAddStock) Times(n uint64) *mIStockUsecaseMockAddStock {
	if n == 0 {
		mmAddStock.mock.t.Fatalf("Times of IStockUsecaseMock.AddStock mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddStock.expectedInvocations, n)
	mmAddStock.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddStock
}

func (mmAddStock *mIStockUsecaseMockAddStock) invocationsDone() bool {
	if len(mmAddStock.expectations) == 0 && mmAddStock.defaultExpectation == nil && mmAddStock.mock.funcAddStock == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddStock.mock.afterAddStockCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddStock.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddStock implements mm_controller.IStockUsecase
func (mmAddStock *IStockUsecaseMock) AddStock(ctx context.Context, stock usecase.AddStockDTO) (err error) {
	mm_atomic.AddUint64(&mmAddStock.beforeAddStockCounter, 1)
	defer mm_atomic.AddUint64(&mmAddStock.afterAddStockCounter, 1)

	mmAddStock.t.Helper()

	if mmAddStock.inspectFuncAddStock != nil {
		mmAddStock.inspectFuncAddStock(ctx, stock)
	}

	mm_params := IStockUsecaseMockAddStockParams{ctx, stock}

	// Record call args
	mmAddStock.AddStockMock.mutex.Lock()
	mmAddStock.AddStockMock.callArgs = append(mmAddStock.AddStockMock.callArgs, &mm_params)
	mmAddStock.AddStockMock.mutex.Unlock()

	for _, e := range mmAddStock.AddStockMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddStock.AddStockMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddStock.AddStockMock.defaultExpectation.Counter, 1)
		mm_want := mmAddStock.AddStockMock.defaultExpectation.params
		mm_want_ptrs := mmAddStock.AddStockMock.defaultExpectation.paramPtrs

		mm_got := IStockUsecaseMockAddStockParams{ctx, stock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddStock.t.Errorf("IStockUsecaseMock.AddStock got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stock != nil && !minimock.Equal(*mm_want_ptrs.stock, mm_got.stock) {
				mmAddStock.t.Errorf("IStockUsecaseMock.AddStock got unexpected parameter stock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.originStock, *mm_want_ptrs.stock, mm_got.stock, minimock.Diff(*mm_want_ptrs.stock, mm_got.stock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddStock.t.Errorf("IStockUsecaseMock.AddStock got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddStock.AddStockMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddStock.AddStockMock.defaultExpectation.results
		if mm_results == nil {
			mmAddStock.t.Fatal("No results are set for the IStockUsecaseMock.AddStock")
		}
		return (*mm_results).err
	}
	if mmAddStock.funcAddStock != nil {
		return mmAddStock.funcAddStock(ctx, stock)
	}
	mmAddStock.t.Fatalf("Unexpected call to IStockUsecaseMock.AddStock. %v %v", ctx, stock)
	return
}

// AddStockAfterCounter returns a count of finished IStockUsecaseMock.AddStock invocations
func (mmAddStock *IStockUsecaseMock) AddStockAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStock.afterAddStockCounter)
}

// AddStockBeforeCounter returns a count of IStockUsecaseMock.AddStock invocations
func (mmAddStock *IStockUsecaseMock) AddStockBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStock.beforeAddStockCounter)
}

// Calls returns a list of arguments used in each call to IStockUsecaseMock.AddStock.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddStock *mIStockUsecaseMockAddStock) Calls() []*IStockUsecaseMockAddStockParams {
	mmAddStock.mutex.RLock()

	argCopy := make([]*IStockUsecaseMockAddStockParams, len(mmAddStock.callArgs))
	copy(argCopy, mmAddStock.callArgs)

	mmAddStock.mutex.RUnlock()

	return argCopy
}

// MinimockAddStockDone returns true if the count of the AddStock invocations corresponds
// the number of defined expectations
func (m *IStockUsecaseMock) MinimockAddStockDone() bool {
	if m.AddStockMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddStockMock.invocationsDone()
}

// MinimockAddStockInspect logs each unmet expectation
func (m *IStockUsecaseMock) MinimockAddStockInspect() {
	for _, e := range m.AddStockMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockUsecaseMock.AddStock at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddStockCounter := mm_atomic.LoadUint64(&m.afterAddStockCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddStockMock.defaultExpectation != nil && afterAddStockCounter < 1 {
		if m.AddStockMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockUsecaseMock.AddStock at\n%s", m.AddStockMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockUsecaseMock.AddStock at\n%s with params: %#v", m.AddStockMock.defaultExpectation.expectationOrigins.origin, *m.AddStockMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStock != nil && afterAddStockCounter < 1 {
		m.t.Errorf("Expected call to IStockUsecaseMock.AddStock at\n%s", m.funcAddStockOrigin)
	}

	if !m.AddStockMock.invocationsDone() && afterAddStockCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockUsecaseMock.AddStock at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddStockMock.expectedInvocations), m.AddStockMock.expectedInvocationsOrigin, afterAddStockCounter)
	}
}

type mIStockUsecaseMockDeleteStockBySKU struct {
	optional           bool
	mock               *IStockUsecaseMock
	defaultExpectation *IStockUsecaseMockDeleteStockBySKUExpectation
	expectations       []*IStockUsecaseMockDeleteStockBySKUExpectation

	callArgs []*IStockUsecaseMockDeleteStockBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockUsecaseMockDeleteStockBySKUExpectation specifies expectation struct of the IStockUsecase.DeleteStockBySKU
type IStockUsecaseMockDeleteStockBySKUExpectation struct {
	mock               *IStockUsecaseMock
	params             *IStockUsecaseMockDeleteStockBySKUParams
	paramPtrs          *IStockUsecaseMockDeleteStockBySKUParamPtrs
	expectationOrigins IStockUsecaseMockDeleteStockBySKUExpectationOrigins
	results            *IStockUsecaseMockDeleteStockBySKUResults
	returnOrigin       string
	Counter            uint64
}

// IStockUsecaseMockDeleteStockBySKUParams contains parameters of the IStockUsecase.DeleteStockBySKU
type IStockUsecaseMockDeleteStockBySKUParams struct {
	ctx      context.Context
	delStock usecase.DeleteStockDTO
}

// IStockUsecaseMockDeleteStockBySKUParamPtrs contains pointers to parameters of the IStockUsecase.DeleteStockBySKU
type IStockUsecaseMockDeleteStockBySKUParamPtrs struct {
	ctx      *context.Context
	delStock *usecase.DeleteStockDTO
}

// IStockUsecaseMockDeleteStockBySKUResults contains results of the IStockUsecase.DeleteStockBySKU
type IStockUsecaseMockDeleteStockBySKUResults struct {
	err error
}

// IStockUsecaseMockDeleteStockBySKUOrigins contains origins of expectations of the IStockUsecase.DeleteStockBySKU
type IStockUsecaseMockDeleteStockBySKUExpectationOrigins struct {
	origin         string
	originCtx      string
	originDelStock string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Optional() *mIStockUsecaseMockDeleteStockBySKU {
	mmDeleteStockBySKU.optional = true
	return mmDeleteStockBySKU
}

// Expect sets up expected params for IStockUsecase.DeleteStockBySKU
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Expect(ctx context.Context, delStock usecase.DeleteStockDTO) *mIStockUsecaseMockDeleteStockBySKU {
	if mmDeleteStockBySKU.mock.funcDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Set")
	}

	if mmDeleteStockBySKU.defaultExpectation == nil {
		mmDeleteStockBySKU.defaultExpectation = &IStockUsecaseMockDeleteStockBySKUExpectation{}
	}

	if mmDeleteStockBySKU.defaultExpectation.paramPtrs != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by ExpectParams functions")
	}

	mmDeleteStockBySKU.defaultExpectation.params = &IStockUsecaseMockDeleteStockBySKUParams{ctx, delStock}
	mmDeleteStockBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteStockBySKU.expectations {
		if minimock.Equal(e.params, mmDeleteStockBySKU.defaultExpectation.params) {
			mmDeleteStockBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStockBySKU.defaultExpectation.params)
		}
	}

	return mmDeleteStockBySKU
}

// ExpectCtxParam1 sets up expected param ctx for IStockUsecase.DeleteStockBySKU
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) ExpectCtxParam1(ctx context.Context) *mIStockUsecaseMockDeleteStockBySKU {
	if mmDeleteStockBySKU.mock.funcDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Set")
	}

	if mmDeleteStockBySKU.defaultExpectation == nil {
		mmDeleteStockBySKU.defaultExpectation = &IStockUsecaseMockDeleteStockBySKUExpectation{}
	}

	if mmDeleteStockBySKU.defaultExpectation.params != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Expect")
	}

	if mmDeleteStockBySKU.defaultExpectation.paramPtrs == nil {
		mmDeleteStockBySKU.defaultExpectation.paramPtrs = &IStockUsecaseMockDeleteStockBySKUParamPtrs{}
	}
	mmDeleteStockBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteStockBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteStockBySKU
}

// ExpectDelStockParam2 sets up expected param delStock for IStockUsecase.DeleteStockBySKU
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) ExpectDelStockParam2(delStock usecase.DeleteStockDTO) *mIStockUsecaseMockDeleteStockBySKU {
	if mmDeleteStockBySKU.mock.funcDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Set")
	}

	if mmDeleteStockBySKU.defaultExpectation == nil {
		mmDeleteStockBySKU.defaultExpectation = &IStockUsecaseMockDeleteStockBySKUExpectation{}
	}

	if mmDeleteStockBySKU.defaultExpectation.params != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Expect")
	}

	if mmDeleteStockBySKU.defaultExpectation.paramPtrs == nil {
		mmDeleteStockBySKU.defaultExpectation.paramPtrs = &IStockUsecaseMockDeleteStockBySKUParamPtrs{}
	}
	mmDeleteStockBySKU.defaultExpectation.paramPtrs.delStock = &delStock
	mmDeleteStockBySKU.defaultExpectation.expectationOrigins.originDelStock = minimock.CallerInfo(1)

	return mmDeleteStockBySKU
}

// Inspect accepts an inspector function that has same arguments as the IStockUsecase.DeleteStockBySKU
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Inspect(f func(ctx context.Context, delStock usecase.DeleteStockDTO)) *mIStockUsecaseMockDeleteStockBySKU {
	if mmDeleteStockBySKU.mock.inspectFuncDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("Inspect function is already set for IStockUsecaseMock.DeleteStockBySKU")
	}

	mmDeleteStockBySKU.mock.inspectFuncDeleteStockBySKU = f

	return mmDeleteStockBySKU
}

// Return sets up results that will be returned by IStockUsecase.DeleteStockBySKU
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Return(err error) *IStockUsecaseMock {
	if mmDeleteStockBySKU.mock.funcDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Set")
	}

	if mmDeleteStockBySKU.defaultExpectation == nil {
		mmDeleteStockBySKU.defaultExpectation = &IStockUsecaseMockDeleteStockBySKUExpectation{mock: mmDeleteStockBySKU.mock}
	}
	mmDeleteStockBySKU.defaultExpectation.results = &IStockUsecaseMockDeleteStockBySKUResults{err}
	mmDeleteStockBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteStockBySKU.mock
}

// Set uses given function f to mock the IStockUsecase.DeleteStockBySKU method
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Set(f func(ctx context.Context, delStock usecase.DeleteStockDTO) (err error)) *IStockUsecaseMock {
	if mmDeleteStockBySKU.defaultExpectation != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("Default expectation is already set for the IStockUsecase.DeleteStockBySKU method")
	}

	if len(mmDeleteStockBySKU.expectations) > 0 {
		mmDeleteStockBySKU.mock.t.Fatalf("Some expectations are already set for the IStockUsecase.DeleteStockBySKU method")
	}

	mmDeleteStockBySKU.mock.funcDeleteStockBySKU = f
	mmDeleteStockBySKU.mock.funcDeleteStockBySKUOrigin = minimock.CallerInfo(1)
	return mmDeleteStockBySKU.mock
}

// When sets expectation for the IStockUsecase.DeleteStockBySKU which will trigger the result defined by the following
// Then helper
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) When(ctx context.Context, delStock usecase.DeleteStockDTO) *IStockUsecaseMockDeleteStockBySKUExpectation {
	if mmDeleteStockBySKU.mock.funcDeleteStockBySKU != nil {
		mmDeleteStockBySKU.mock.t.Fatalf("IStockUsecaseMock.DeleteStockBySKU mock is already set by Set")
	}

	expectation := &IStockUsecaseMockDeleteStockBySKUExpectation{
		mock:               mmDeleteStockBySKU.mock,
		params:             &IStockUsecaseMockDeleteStockBySKUParams{ctx, delStock},
		expectationOrigins: IStockUsecaseMockDeleteStockBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteStockBySKU.expectations = append(mmDeleteStockBySKU.expectations, expectation)
	return expectation
}

// Then sets up IStockUsecase.DeleteStockBySKU return parameters for the expectation previously defined by the When method
func (e *IStockUsecaseMockDeleteStockBySKUExpectation) Then(err error) *IStockUsecaseMock {
	e.results = &IStockUsecaseMockDeleteStockBySKUResults{err}
	return e.mock
}

// Times sets number of times IStockUsecase.DeleteStockBySKU should be invoked
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Times(n uint64) *mIStockUsecaseMockDeleteStockBySKU {
	if n == 0 {
		mmDeleteStockBySKU.mock.t.Fatalf("Times of IStockUsecaseMock.DeleteStockBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteStockBySKU.expectedInvocations, n)
	mmDeleteStockBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteStockBySKU
}

func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) invocationsDone() bool {
	if len(mmDeleteStockBySKU.expectations) == 0 && mmDeleteStockBySKU.defaultExpectation == nil && mmDeleteStockBySKU.mock.funcDeleteStockBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteStockBySKU.mock.afterDeleteStockBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteStockBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteStockBySKU implements mm_controller.IStockUsecase
func (mmDeleteStockBySKU *IStockUsecaseMock) DeleteStockBySKU(ctx context.Context, delStock usecase.DeleteStockDTO) (err error) {
	mm_atomic.AddUint64(&mmDeleteStockBySKU.beforeDeleteStockBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStockBySKU.afterDeleteStockBySKUCounter, 1)

	mmDeleteStockBySKU.t.Helper()

	if mmDeleteStockBySKU.inspectFuncDeleteStockBySKU != nil {
		mmDeleteStockBySKU.inspectFuncDeleteStockBySKU(ctx, delStock)
	}

	mm_params := IStockUsecaseMockDeleteStockBySKUParams{ctx, delStock}

	// Record call args
	mmDeleteStockBySKU.DeleteStockBySKUMock.mutex.Lock()
	mmDeleteStockBySKU.DeleteStockBySKUMock.callArgs = append(mmDeleteStockBySKU.DeleteStockBySKUMock.callArgs, &mm_params)
	mmDeleteStockBySKU.DeleteStockBySKUMock.mutex.Unlock()

	for _, e := range mmDeleteStockBySKU.DeleteStockBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.paramPtrs

		mm_got := IStockUsecaseMockDeleteStockBySKUParams{ctx, delStock}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteStockBySKU.t.Errorf("IStockUsecaseMock.DeleteStockBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.delStock != nil && !minimock.Equal(*mm_want_ptrs.delStock, mm_got.delStock) {
				mmDeleteStockBySKU.t.Errorf("IStockUsecaseMock.DeleteStockBySKU got unexpected parameter delStock, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.expectationOrigins.originDelStock, *mm_want_ptrs.delStock, mm_got.delStock, minimock.Diff(*mm_want_ptrs.delStock, mm_got.delStock))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStockBySKU.t.Errorf("IStockUsecaseMock.DeleteStockBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteStockBySKU.DeleteStockBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteStockBySKU.t.Fatal("No results are set for the IStockUsecaseMock.DeleteStockBySKU")
		}
		return (*mm_results).err
	}
	if mmDeleteStockBySKU.funcDeleteStockBySKU != nil {
		return mmDeleteStockBySKU.funcDeleteStockBySKU(ctx, delStock)
	}
	mmDeleteStockBySKU.t.Fatalf("Unexpected call to IStockUsecaseMock.DeleteStockBySKU. %v %v", ctx, delStock)
	return
}

// DeleteStockBySKUAfterCounter returns a count of finished IStockUsecaseMock.DeleteStockBySKU invocations
func (mmDeleteStockBySKU *IStockUsecaseMock) DeleteStockBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockBySKU.afterDeleteStockBySKUCounter)
}

// DeleteStockBySKUBeforeCounter returns a count of IStockUsecaseMock.DeleteStockBySKU invocations
func (mmDeleteStockBySKU *IStockUsecaseMock) DeleteStockBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockBySKU.beforeDeleteStockBySKUCounter)
}

// Calls returns a list of arguments used in each call to IStockUsecaseMock.DeleteStockBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStockBySKU *mIStockUsecaseMockDeleteStockBySKU) Calls() []*IStockUsecaseMockDeleteStockBySKUParams {
	mmDeleteStockBySKU.mutex.RLock()

	argCopy := make([]*IStockUsecaseMockDeleteStockBySKUParams, len(mmDeleteStockBySKU.callArgs))
	copy(argCopy, mmDeleteStockBySKU.callArgs)

	mmDeleteStockBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStockBySKUDone returns true if the count of the DeleteStockBySKU invocations corresponds
// the number of defined expectations
func (m *IStockUsecaseMock) MinimockDeleteStockBySKUDone() bool {
	if m.DeleteStockBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteStockBySKUMock.invocationsDone()
}

// MinimockDeleteStockBySKUInspect logs each unmet expectation
func (m *IStockUsecaseMock) MinimockDeleteStockBySKUInspect() {
	for _, e := range m.DeleteStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockUsecaseMock.DeleteStockBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteStockBySKUCounter := mm_atomic.LoadUint64(&m.afterDeleteStockBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStockBySKUMock.defaultExpectation != nil && afterDeleteStockBySKUCounter < 1 {
		if m.DeleteStockBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockUsecaseMock.DeleteStockBySKU at\n%s", m.DeleteStockBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockUsecaseMock.DeleteStockBySKU at\n%s with params: %#v", m.DeleteStockBySKUMock.defaultExpectation.expectationOrigins.origin, *m.DeleteStockBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStockBySKU != nil && afterDeleteStockBySKUCounter < 1 {
		m.t.Errorf("Expected call to IStockUsecaseMock.DeleteStockBySKU at\n%s", m.funcDeleteStockBySKUOrigin)
	}

	if !m.DeleteStockBySKUMock.invocationsDone() && afterDeleteStockBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockUsecaseMock.DeleteStockBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteStockBySKUMock.expectedInvocations), m.DeleteStockBySKUMock.expectedInvocationsOrigin, afterDeleteStockBySKUCounter)
	}
}

type mIStockUsecaseMockGetItemBySKU struct {
	optional           bool
	mock               *IStockUsecaseMock
	defaultExpectation *IStockUsecaseMockGetItemBySKUExpectation
	expectations       []*IStockUsecaseMockGetItemBySKUExpectation

	callArgs []*IStockUsecaseMockGetItemBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockUsecaseMockGetItemBySKUExpectation specifies expectation struct of the IStockUsecase.GetItemBySKU
type IStockUsecaseMockGetItemBySKUExpectation struct {
	mock               *IStockUsecaseMock
	params             *IStockUsecaseMockGetItemBySKUParams
	paramPtrs          *IStockUsecaseMockGetItemBySKUParamPtrs
	expectationOrigins IStockUsecaseMockGetItemBySKUExpectationOrigins
	results            *IStockUsecaseMockGetItemBySKUResults
	returnOrigin       string
	Counter            uint64
}

// IStockUsecaseMockGetItemBySKUParams contains parameters of the IStockUsecase.GetItemBySKU
type IStockUsecaseMockGetItemBySKUParams struct {
	ctx context.Context
	sku models.SKUID
}

// IStockUsecaseMockGetItemBySKUParamPtrs contains pointers to parameters of the IStockUsecase.GetItemBySKU
type IStockUsecaseMockGetItemBySKUParamPtrs struct {
	ctx *context.Context
	sku *models.SKUID
}

// IStockUsecaseMockGetItemBySKUResults contains results of the IStockUsecase.GetItemBySKU
type IStockUsecaseMockGetItemBySKUResults struct {
	s1  usecase.StockDTO
	err error
}

// IStockUsecaseMockGetItemBySKUOrigins contains origins of expectations of the IStockUsecase.GetItemBySKU
type IStockUsecaseMockGetItemBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Optional() *mIStockUsecaseMockGetItemBySKU {
	mmGetItemBySKU.optional = true
	return mmGetItemBySKU
}

// Expect sets up expected params for IStockUsecase.GetItemBySKU
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Expect(ctx context.Context, sku models.SKUID) *mIStockUsecaseMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockUsecaseMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by ExpectParams functions")
	}

	mmGetItemBySKU.defaultExpectation.params = &IStockUsecaseMockGetItemBySKUParams{ctx, sku}
	mmGetItemBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemBySKU.expectations {
		if minimock.Equal(e.params, mmGetItemBySKU.defaultExpectation.params) {
			mmGetItemBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemBySKU.defaultExpectation.params)
		}
	}

	return mmGetItemBySKU
}

// ExpectCtxParam1 sets up expected param ctx for IStockUsecase.GetItemBySKU
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) ExpectCtxParam1(ctx context.Context) *mIStockUsecaseMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockUsecaseMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.params != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Expect")
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetItemBySKU.defaultExpectation.paramPtrs = &IStockUsecaseMockGetItemBySKUParamPtrs{}
	}
	mmGetItemBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemBySKU
}

// ExpectSkuParam2 sets up expected param sku for IStockUsecase.GetItemBySKU
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) ExpectSkuParam2(sku models.SKUID) *mIStockUsecaseMockGetItemBySKU {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockUsecaseMockGetItemBySKUExpectation{}
	}

	if mmGetItemBySKU.defaultExpectation.params != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Expect")
	}

	if mmGetItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetItemBySKU.defaultExpectation.paramPtrs = &IStockUsecaseMockGetItemBySKUParamPtrs{}
	}
	mmGetItemBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetItemBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetItemBySKU
}

// Inspect accepts an inspector function that has same arguments as the IStockUsecase.GetItemBySKU
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Inspect(f func(ctx context.Context, sku models.SKUID)) *mIStockUsecaseMockGetItemBySKU {
	if mmGetItemBySKU.mock.inspectFuncGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("Inspect function is already set for IStockUsecaseMock.GetItemBySKU")
	}

	mmGetItemBySKU.mock.inspectFuncGetItemBySKU = f

	return mmGetItemBySKU
}

// Return sets up results that will be returned by IStockUsecase.GetItemBySKU
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Return(s1 usecase.StockDTO, err error) *IStockUsecaseMock {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Set")
	}

	if mmGetItemBySKU.defaultExpectation == nil {
		mmGetItemBySKU.defaultExpectation = &IStockUsecaseMockGetItemBySKUExpectation{mock: mmGetItemBySKU.mock}
	}
	mmGetItemBySKU.defaultExpectation.results = &IStockUsecaseMockGetItemBySKUResults{s1, err}
	mmGetItemBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU.mock
}

// Set uses given function f to mock the IStockUsecase.GetItemBySKU method
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Set(f func(ctx context.Context, sku models.SKUID) (s1 usecase.StockDTO, err error)) *IStockUsecaseMock {
	if mmGetItemBySKU.defaultExpectation != nil {
		mmGetItemBySKU.mock.t.Fatalf("Default expectation is already set for the IStockUsecase.GetItemBySKU method")
	}

	if len(mmGetItemBySKU.expectations) > 0 {
		mmGetItemBySKU.mock.t.Fatalf("Some expectations are already set for the IStockUsecase.GetItemBySKU method")
	}

	mmGetItemBySKU.mock.funcGetItemBySKU = f
	mmGetItemBySKU.mock.funcGetItemBySKUOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU.mock
}

// When sets expectation for the IStockUsecase.GetItemBySKU which will trigger the result defined by the following
// Then helper
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) When(ctx context.Context, sku models.SKUID) *IStockUsecaseMockGetItemBySKUExpectation {
	if mmGetItemBySKU.mock.funcGetItemBySKU != nil {
		mmGetItemBySKU.mock.t.Fatalf("IStockUsecaseMock.GetItemBySKU mock is already set by Set")
	}

	expectation := &IStockUsecaseMockGetItemBySKUExpectation{
		mock:               mmGetItemBySKU.mock,
		params:             &IStockUsecaseMockGetItemBySKUParams{ctx, sku},
		expectationOrigins: IStockUsecaseMockGetItemBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemBySKU.expectations = append(mmGetItemBySKU.expectations, expectation)
	return expectation
}

// Then sets up IStockUsecase.GetItemBySKU return parameters for the expectation previously defined by the When method
func (e *IStockUsecaseMockGetItemBySKUExpectation) Then(s1 usecase.StockDTO, err error) *IStockUsecaseMock {
	e.results = &IStockUsecaseMockGetItemBySKUResults{s1, err}
	return e.mock
}

// Times sets number of times IStockUsecase.GetItemBySKU should be invoked
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Times(n uint64) *mIStockUsecaseMockGetItemBySKU {
	if n == 0 {
		mmGetItemBySKU.mock.t.Fatalf("Times of IStockUsecaseMock.GetItemBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemBySKU.expectedInvocations, n)
	mmGetItemBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemBySKU
}

func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) invocationsDone() bool {
	if len(mmGetItemBySKU.expectations) == 0 && mmGetItemBySKU.defaultExpectation == nil && mmGetItemBySKU.mock.funcGetItemBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemBySKU.mock.afterGetItemBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemBySKU implements mm_controller.IStockUsecase
func (mmGetItemBySKU *IStockUsecaseMock) GetItemBySKU(ctx context.Context, sku models.SKUID) (s1 usecase.StockDTO, err error) {
	mm_atomic.AddUint64(&mmGetItemBySKU.beforeGetItemBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemBySKU.afterGetItemBySKUCounter, 1)

	mmGetItemBySKU.t.Helper()

	if mmGetItemBySKU.inspectFuncGetItemBySKU != nil {
		mmGetItemBySKU.inspectFuncGetItemBySKU(ctx, sku)
	}

	mm_params := IStockUsecaseMockGetItemBySKUParams{ctx, sku}

	// Record call args
	mmGetItemBySKU.GetItemBySKUMock.mutex.Lock()
	mmGetItemBySKU.GetItemBySKUMock.callArgs = append(mmGetItemBySKU.GetItemBySKUMock.callArgs, &mm_params)
	mmGetItemBySKU.GetItemBySKUMock.mutex.Unlock()

	for _, e := range mmGetItemBySKU.GetItemBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetItemBySKU.GetItemBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.paramPtrs

		mm_got := IStockUsecaseMockGetItemBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemBySKU.t.Errorf("IStockUsecaseMock.GetItemBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetItemBySKU.t.Errorf("IStockUsecaseMock.GetItemBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemBySKU.t.Errorf("IStockUsecaseMock.GetItemBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemBySKU.GetItemBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemBySKU.t.Fatal("No results are set for the IStockUsecaseMock.GetItemBySKU")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetItemBySKU.funcGetItemBySKU != nil {
		return mmGetItemBySKU.funcGetItemBySKU(ctx, sku)
	}
	mmGetItemBySKU.t.Fatalf("Unexpected call to IStockUsecaseMock.GetItemBySKU. %v %v", ctx, sku)
	return
}

// GetItemBySKUAfterCounter returns a count of finished IStockUsecaseMock.GetItemBySKU invocations
func (mmGetItemBySKU *IStockUsecaseMock) GetItemBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemBySKU.afterGetItemBySKUCounter)
}

// GetItemBySKUBeforeCounter returns a count of IStockUsecaseMock.GetItemBySKU invocations
func (mmGetItemBySKU *IStockUsecaseMock) GetItemBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemBySKU.beforeGetItemBySKUCounter)
}

// Calls returns a list of arguments used in each call to IStockUsecaseMock.GetItemBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemBySKU *mIStockUsecaseMockGetItemBySKU) Calls() []*IStockUsecaseMockGetItemBySKUParams {
	mmGetItemBySKU.mutex.RLock()

	argCopy := make([]*IStockUsecaseMockGetItemBySKUParams, len(mmGetItemBySKU.callArgs))
	copy(argCopy, mmGetItemBySKU.callArgs)

	mmGetItemBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemBySKUDone returns true if the count of the GetItemBySKU invocations corresponds
// the number of defined expectations
func (m *IStockUsecaseMock) MinimockGetItemBySKUDone() bool {
	if m.GetItemBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemBySKUMock.invocationsDone()
}

// MinimockGetItemBySKUInspect logs each unmet expectation
func (m *IStockUsecaseMock) MinimockGetItemBySKUInspect() {
	for _, e := range m.GetItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetItemBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemBySKUCounter := mm_atomic.LoadUint64(&m.afterGetItemBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemBySKUMock.defaultExpectation != nil && afterGetItemBySKUCounter < 1 {
		if m.GetItemBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetItemBySKU at\n%s", m.GetItemBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetItemBySKU at\n%s with params: %#v", m.GetItemBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetItemBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemBySKU != nil && afterGetItemBySKUCounter < 1 {
		m.t.Errorf("Expected call to IStockUsecaseMock.GetItemBySKU at\n%s", m.funcGetItemBySKUOrigin)
	}

	if !m.GetItemBySKUMock.invocationsDone() && afterGetItemBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockUsecaseMock.GetItemBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemBySKUMock.expectedInvocations), m.GetItemBySKUMock.expectedInvocationsOrigin, afterGetItemBySKUCounter)
	}
}

type mIStockUsecaseMockGetStocksByLocation struct {
	optional           bool
	mock               *IStockUsecaseMock
	defaultExpectation *IStockUsecaseMockGetStocksByLocationExpectation
	expectations       []*IStockUsecaseMockGetStocksByLocationExpectation

	callArgs []*IStockUsecaseMockGetStocksByLocationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockUsecaseMockGetStocksByLocationExpectation specifies expectation struct of the IStockUsecase.GetStocksByLocation
type IStockUsecaseMockGetStocksByLocationExpectation struct {
	mock               *IStockUsecaseMock
	params             *IStockUsecaseMockGetStocksByLocationParams
	paramPtrs          *IStockUsecaseMockGetStocksByLocationParamPtrs
	expectationOrigins IStockUsecaseMockGetStocksByLocationExpectationOrigins
	results            *IStockUsecaseMockGetStocksByLocationResults
	returnOrigin       string
	Counter            uint64
}

// IStockUsecaseMockGetStocksByLocationParams contains parameters of the IStockUsecase.GetStocksByLocation
type IStockUsecaseMockGetStocksByLocationParams struct {
	ctx   context.Context
	param usecase.GetItemByLocDTO
}

// IStockUsecaseMockGetStocksByLocationParamPtrs contains pointers to parameters of the IStockUsecase.GetStocksByLocation
type IStockUsecaseMockGetStocksByLocationParamPtrs struct {
	ctx   *context.Context
	param *usecase.GetItemByLocDTO
}

// IStockUsecaseMockGetStocksByLocationResults contains results of the IStockUsecase.GetStocksByLocation
type IStockUsecaseMockGetStocksByLocationResults struct {
	i1  usecase.ItemsByLocDTO
	err error
}

// IStockUsecaseMockGetStocksByLocationOrigins contains origins of expectations of the IStockUsecase.GetStocksByLocation
type IStockUsecaseMockGetStocksByLocationExpectationOrigins struct {
	origin      string
	originCtx   string
	originParam string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Optional() *mIStockUsecaseMockGetStocksByLocation {
	mmGetStocksByLocation.optional = true
	return mmGetStocksByLocation
}

// Expect sets up expected params for IStockUsecase.GetStocksByLocation
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Expect(ctx context.Context, param usecase.GetItemByLocDTO) *mIStockUsecaseMockGetStocksByLocation {
	if mmGetStocksByLocation.mock.funcGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Set")
	}

	if mmGetStocksByLocation.defaultExpectation == nil {
		mmGetStocksByLocation.defaultExpectation = &IStockUsecaseMockGetStocksByLocationExpectation{}
	}

	if mmGetStocksByLocation.defaultExpectation.paramPtrs != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by ExpectParams functions")
	}

	mmGetStocksByLocation.defaultExpectation.params = &IStockUsecaseMockGetStocksByLocationParams{ctx, param}
	mmGetStocksByLocation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStocksByLocation.expectations {
		if minimock.Equal(e.params, mmGetStocksByLocation.defaultExpectation.params) {
			mmGetStocksByLocation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStocksByLocation.defaultExpectation.params)
		}
	}

	return mmGetStocksByLocation
}

// ExpectCtxParam1 sets up expected param ctx for IStockUsecase.GetStocksByLocation
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) ExpectCtxParam1(ctx context.Context) *mIStockUsecaseMockGetStocksByLocation {
	if mmGetStocksByLocation.mock.funcGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Set")
	}

	if mmGetStocksByLocation.defaultExpectation == nil {
		mmGetStocksByLocation.defaultExpectation = &IStockUsecaseMockGetStocksByLocationExpectation{}
	}

	if mmGetStocksByLocation.defaultExpectation.params != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Expect")
	}

	if mmGetStocksByLocation.defaultExpectation.paramPtrs == nil {
		mmGetStocksByLocation.defaultExpectation.paramPtrs = &IStockUsecaseMockGetStocksByLocationParamPtrs{}
	}
	mmGetStocksByLocation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStocksByLocation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStocksByLocation
}

// ExpectParamParam2 sets up expected param param for IStockUsecase.GetStocksByLocation
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) ExpectParamParam2(param usecase.GetItemByLocDTO) *mIStockUsecaseMockGetStocksByLocation {
	if mmGetStocksByLocation.mock.funcGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Set")
	}

	if mmGetStocksByLocation.defaultExpectation == nil {
		mmGetStocksByLocation.defaultExpectation = &IStockUsecaseMockGetStocksByLocationExpectation{}
	}

	if mmGetStocksByLocation.defaultExpectation.params != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Expect")
	}

	if mmGetStocksByLocation.defaultExpectation.paramPtrs == nil {
		mmGetStocksByLocation.defaultExpectation.paramPtrs = &IStockUsecaseMockGetStocksByLocationParamPtrs{}
	}
	mmGetStocksByLocation.defaultExpectation.paramPtrs.param = &param
	mmGetStocksByLocation.defaultExpectation.expectationOrigins.originParam = minimock.CallerInfo(1)

	return mmGetStocksByLocation
}

// Inspect accepts an inspector function that has same arguments as the IStockUsecase.GetStocksByLocation
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Inspect(f func(ctx context.Context, param usecase.GetItemByLocDTO)) *mIStockUsecaseMockGetStocksByLocation {
	if mmGetStocksByLocation.mock.inspectFuncGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("Inspect function is already set for IStockUsecaseMock.GetStocksByLocation")
	}

	mmGetStocksByLocation.mock.inspectFuncGetStocksByLocation = f

	return mmGetStocksByLocation
}

// Return sets up results that will be returned by IStockUsecase.GetStocksByLocation
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Return(i1 usecase.ItemsByLocDTO, err error) *IStockUsecaseMock {
	if mmGetStocksByLocation.mock.funcGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Set")
	}

	if mmGetStocksByLocation.defaultExpectation == nil {
		mmGetStocksByLocation.defaultExpectation = &IStockUsecaseMockGetStocksByLocationExpectation{mock: mmGetStocksByLocation.mock}
	}
	mmGetStocksByLocation.defaultExpectation.results = &IStockUsecaseMockGetStocksByLocationResults{i1, err}
	mmGetStocksByLocation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStocksByLocation.mock
}

// Set uses given function f to mock the IStockUsecase.GetStocksByLocation method
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Set(f func(ctx context.Context, param usecase.GetItemByLocDTO) (i1 usecase.ItemsByLocDTO, err error)) *IStockUsecaseMock {
	if mmGetStocksByLocation.defaultExpectation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("Default expectation is already set for the IStockUsecase.GetStocksByLocation method")
	}

	if len(mmGetStocksByLocation.expectations) > 0 {
		mmGetStocksByLocation.mock.t.Fatalf("Some expectations are already set for the IStockUsecase.GetStocksByLocation method")
	}

	mmGetStocksByLocation.mock.funcGetStocksByLocation = f
	mmGetStocksByLocation.mock.funcGetStocksByLocationOrigin = minimock.CallerInfo(1)
	return mmGetStocksByLocation.mock
}

// When sets expectation for the IStockUsecase.GetStocksByLocation which will trigger the result defined by the following
// Then helper
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) When(ctx context.Context, param usecase.GetItemByLocDTO) *IStockUsecaseMockGetStocksByLocationExpectation {
	if mmGetStocksByLocation.mock.funcGetStocksByLocation != nil {
		mmGetStocksByLocation.mock.t.Fatalf("IStockUsecaseMock.GetStocksByLocation mock is already set by Set")
	}

	expectation := &IStockUsecaseMockGetStocksByLocationExpectation{
		mock:               mmGetStocksByLocation.mock,
		params:             &IStockUsecaseMockGetStocksByLocationParams{ctx, param},
		expectationOrigins: IStockUsecaseMockGetStocksByLocationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStocksByLocation.expectations = append(mmGetStocksByLocation.expectations, expectation)
	return expectation
}

// Then sets up IStockUsecase.GetStocksByLocation return parameters for the expectation previously defined by the When method
func (e *IStockUsecaseMockGetStocksByLocationExpectation) Then(i1 usecase.ItemsByLocDTO, err error) *IStockUsecaseMock {
	e.results = &IStockUsecaseMockGetStocksByLocationResults{i1, err}
	return e.mock
}

// Times sets number of times IStockUsecase.GetStocksByLocation should be invoked
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Times(n uint64) *mIStockUsecaseMockGetStocksByLocation {
	if n == 0 {
		mmGetStocksByLocation.mock.t.Fatalf("Times of IStockUsecaseMock.GetStocksByLocation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStocksByLocation.expectedInvocations, n)
	mmGetStocksByLocation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStocksByLocation
}

func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) invocationsDone() bool {
	if len(mmGetStocksByLocation.expectations) == 0 && mmGetStocksByLocation.defaultExpectation == nil && mmGetStocksByLocation.mock.funcGetStocksByLocation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStocksByLocation.mock.afterGetStocksByLocationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStocksByLocation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStocksByLocation implements mm_controller.IStockUsecase
func (mmGetStocksByLocation *IStockUsecaseMock) GetStocksByLocation(ctx context.Context, param usecase.GetItemByLocDTO) (i1 usecase.ItemsByLocDTO, err error) {
	mm_atomic.AddUint64(&mmGetStocksByLocation.beforeGetStocksByLocationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStocksByLocation.afterGetStocksByLocationCounter, 1)

	mmGetStocksByLocation.t.Helper()

	if mmGetStocksByLocation.inspectFuncGetStocksByLocation != nil {
		mmGetStocksByLocation.inspectFuncGetStocksByLocation(ctx, param)
	}

	mm_params := IStockUsecaseMockGetStocksByLocationParams{ctx, param}

	// Record call args
	mmGetStocksByLocation.GetStocksByLocationMock.mutex.Lock()
	mmGetStocksByLocation.GetStocksByLocationMock.callArgs = append(mmGetStocksByLocation.GetStocksByLocationMock.callArgs, &mm_params)
	mmGetStocksByLocation.GetStocksByLocationMock.mutex.Unlock()

	for _, e := range mmGetStocksByLocation.GetStocksByLocationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.params
		mm_want_ptrs := mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.paramPtrs

		mm_got := IStockUsecaseMockGetStocksByLocationParams{ctx, param}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStocksByLocation.t.Errorf("IStockUsecaseMock.GetStocksByLocation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.param != nil && !minimock.Equal(*mm_want_ptrs.param, mm_got.param) {
				mmGetStocksByLocation.t.Errorf("IStockUsecaseMock.GetStocksByLocation got unexpected parameter param, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.expectationOrigins.originParam, *mm_want_ptrs.param, mm_got.param, minimock.Diff(*mm_want_ptrs.param, mm_got.param))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStocksByLocation.t.Errorf("IStockUsecaseMock.GetStocksByLocation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStocksByLocation.GetStocksByLocationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStocksByLocation.t.Fatal("No results are set for the IStockUsecaseMock.GetStocksByLocation")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetStocksByLocation.funcGetStocksByLocation != nil {
		return mmGetStocksByLocation.funcGetStocksByLocation(ctx, param)
	}
	mmGetStocksByLocation.t.Fatalf("Unexpected call to IStockUsecaseMock.GetStocksByLocation. %v %v", ctx, param)
	return
}

// GetStocksByLocationAfterCounter returns a count of finished IStockUsecaseMock.GetStocksByLocation invocations
func (mmGetStocksByLocation *IStockUsecaseMock) GetStocksByLocationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksByLocation.afterGetStocksByLocationCounter)
}

// GetStocksByLocationBeforeCounter returns a count of IStockUsecaseMock.GetStocksByLocation invocations
func (mmGetStocksByLocation *IStockUsecaseMock) GetStocksByLocationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStocksByLocation.beforeGetStocksByLocationCounter)
}

// Calls returns a list of arguments used in each call to IStockUsecaseMock.GetStocksByLocation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStocksByLocation *mIStockUsecaseMockGetStocksByLocation) Calls() []*IStockUsecaseMockGetStocksByLocationParams {
	mmGetStocksByLocation.mutex.RLock()

	argCopy := make([]*IStockUsecaseMockGetStocksByLocationParams, len(mmGetStocksByLocation.callArgs))
	copy(argCopy, mmGetStocksByLocation.callArgs)

	mmGetStocksByLocation.mutex.RUnlock()

	return argCopy
}

// MinimockGetStocksByLocationDone returns true if the count of the GetStocksByLocation invocations corresponds
// the number of defined expectations
func (m *IStockUsecaseMock) MinimockGetStocksByLocationDone() bool {
	if m.GetStocksByLocationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStocksByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStocksByLocationMock.invocationsDone()
}

// MinimockGetStocksByLocationInspect logs each unmet expectation
func (m *IStockUsecaseMock) MinimockGetStocksByLocationInspect() {
	for _, e := range m.GetStocksByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetStocksByLocation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStocksByLocationCounter := mm_atomic.LoadUint64(&m.afterGetStocksByLocationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStocksByLocationMock.defaultExpectation != nil && afterGetStocksByLocationCounter < 1 {
		if m.GetStocksByLocationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetStocksByLocation at\n%s", m.GetStocksByLocationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockUsecaseMock.GetStocksByLocation at\n%s with params: %#v", m.GetStocksByLocationMock.defaultExpectation.expectationOrigins.origin, *m.GetStocksByLocationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStocksByLocation != nil && afterGetStocksByLocationCounter < 1 {
		m.t.Errorf("Expected call to IStockUsecaseMock.GetStocksByLocation at\n%s", m.funcGetStocksByLocationOrigin)
	}

	if !m.GetStocksByLocationMock.invocationsDone() && afterGetStocksByLocationCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockUsecaseMock.GetStocksByLocation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStocksByLocationMock.expectedInvocations), m.GetStocksByLocationMock.expectedInvocationsOrigin, afterGetStocksByLocationCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStockUsecaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddStockInspect()

			m.MinimockDeleteStockBySKUInspect()

			m.MinimockGetItemBySKUInspect()

			m.MinimockGetStocksByLocationInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStockUsecaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStockUsecaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddStockDone() &&
		m.MinimockDeleteStockBySKUDone() &&
		m.MinimockGetItemBySKUDone() &&
		m.MinimockGetStocksByLocationDone()
}
